<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · Documenter.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-136089579-2"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-136089579-2', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliadocs.github.io/Documenter.jl/stable/lib/public/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Documenter.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Documenter.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Documenter.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/guide/">Guide</a></li><li><a class="tocitem" href="../../man/examples/">Examples</a></li><li><a class="tocitem" href="../../man/syntax/">Syntax</a></li><li><a class="tocitem" href="../../man/doctests/">Doctests</a></li><li><a class="tocitem" href="../../man/latex/"><span>$\LaTeX$</span> Syntax</a></li><li><a class="tocitem" href="../../man/hosting/">Hosting Documentation</a></li><li><a class="tocitem" href="../../man/other-formats/">Other Output Formats</a></li></ul></li><li><a class="tocitem" href="../../showcase/">Showcase</a></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Public-Interface"><span>Public Interface</span></a></li><li><a class="tocitem" href="#DocumenterTools"><span>DocumenterTools</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../internals/anchors/">Anchors</a></li><li><a class="tocitem" href="../internals/builder/">Builder</a></li><li><a class="tocitem" href="../internals/cross-references/">CrossReferences</a></li><li><a class="tocitem" href="../internals/docchecks/">DocChecks</a></li><li><a class="tocitem" href="../internals/docmeta/">DocMeta</a></li><li><a class="tocitem" href="../internals/docsystem/">DocSystem</a></li><li><a class="tocitem" href="../internals/doctests/">DocTests</a></li><li><a class="tocitem" href="../internals/documenter/">Documenter</a></li><li><a class="tocitem" href="../internals/documentertools/">DocumenterTools</a></li><li><a class="tocitem" href="../internals/documents/">Documents</a></li><li><a class="tocitem" href="../internals/dom/">DOM</a></li><li><a class="tocitem" href="../internals/expanders/">Expanders</a></li><li><a class="tocitem" href="../internals/jsdependencies/">JSDependencies</a></li><li><a class="tocitem" href="../internals/markdown2/">Markdown2</a></li><li><a class="tocitem" href="../internals/mdflatten/">MDFlatten</a></li><li><a class="tocitem" href="../internals/selectors/">Selectors</a></li><li><a class="tocitem" href="../internals/textdiff/">TextDiff</a></li><li><a class="tocitem" href="../internals/utilities/">Utilities</a></li><li><a class="tocitem" href="../internals/writers/">Writers</a></li></ul></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDocs/Documenter.jl/blob/master/docs/src/lib/public.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page">Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)<p>Documentation for <code>Documenter.jl</code>&#39;s public interface.</p><p>See the Internals section of the manual for internal package docs covering all submodules.</p>Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))])Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#)]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#)]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(#= circular reference @-5 =#), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode(#= circular reference @-6 =#), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), &quot;public.md&quot;, DocumenterTools, :function)])Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)])))])Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1)Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)]))), Documenter.Documents.DocsNode(```julia
generate([io::IO = stdout,] root::String;force = false)
```

This function adds a warning (and `noindex` meta tag) to all versions of the documentation in `root`.

`force` overwrites a previous injected warning message created by this function.

A typical use case is to run this on the `gh-pages` branch of a packge.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), 191, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.OutdatedWarning.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.Page(&quot;src/lib/public.md&quot;, &quot;build/lib/public.md&quot;, &quot;build/lib&quot;, Any[Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]), Markdown.Header{2}(Any[&quot;Contents&quot;]), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Index&quot;]), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Markdown.Header{2}(Any[&quot;Public Interface&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)], IdDict{Any, Any}(Markdown.Code(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;) =&gt; Documenter.Documents.DocsNodes(#= circular reference @-5 =#), Markdown.Code(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.ContentsNode([&quot;public.md&quot;], 2, &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(36, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1)), (37, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1)), (38, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1)), (39, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1)), (40, &quot;public.md&quot;, Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1))]), Markdown.Code(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;) =&gt; Documenter.Documents.DocsNodes(Union{Documenter.Documents.DocsNode, Markdown.Admonition}[Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#)), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-5 =#))]), Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;Documentation for &quot;, Markdown.Code(&quot;&quot;, &quot;Documenter.jl&quot;), &quot;&#39;s public interface.&quot;]), Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;DocumenterTools&quot;]), 40, &quot;build/lib/public.md&quot;, &quot;DocumenterTools&quot;, 1), Markdown.Header{1}(Any[&quot;Public Documentation&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{1}(Any[&quot;Public Documentation&quot;]), 36, &quot;build/lib/public.md&quot;, &quot;Public-Documentation&quot;, 1), Markdown.Header{2}(Any[&quot;Contents&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Contents&quot;]), 37, &quot;build/lib/public.md&quot;, &quot;Contents&quot;, 1), Markdown.Header{2}(Any[&quot;Index&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Index&quot;]), 38, &quot;build/lib/public.md&quot;, &quot;Index&quot;, 1), Markdown.Code(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;) =&gt; Documenter.Documents.IndexNode([&quot;public.md&quot;], Module[], [:module, :constant, :type, :function, :macro], &quot;build/lib/public.md&quot;, &quot;src/lib/public.md&quot;, Any[(Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.DocsNode(Main module for `Documenter.jl` – a documentation generation package for Julia.

Two functions are exported from this module for public use:

  * [`makedocs`](public.md#Documenter.makedocs). Generates documentation from docstrings and templated markdown files.
  * [`deploydocs`](public.md#Documenter.deploydocs). Deploys generated documentation from *Travis-CI* to *GitHub Pages*.

# Exports

  * [`Deps`](public.md#Documenter.Deps)
  * [`DocMeta`](public.md#Documenter.DocMeta)
  * [`KaTeX`](internals/writers.md#Documenter.Writers.HTMLWriter.KaTeX)
  * [`MathJax`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax)
  * [`MathJax2`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax2)
  * [`MathJax3`](internals/writers.md#Documenter.Writers.HTMLWriter.MathJax3)
  * [`asset`](public.md#Documenter.Writers.HTMLWriter.asset)
  * [`deploydocs`](public.md#Documenter.deploydocs)
  * [`doctest`](public.md#Documenter.doctest)
  * [`hide`](public.md#Documenter.hide)
  * [`makedocs`](public.md#Documenter.makedocs)
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter, Union{}), 178, &quot;build/lib/public.md&quot;, &quot;Documenter&quot;, 1), Documenter.Utilities.Object(Documenter, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Main, :module), (Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.DocsNode(Exported module that provides build and deploy dependencies and related functions.

Currently only [`pip`](public.md#Documenter.Deps.pip) is implemented.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps, Union{}), 183, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps&quot;, 1), Documenter.Utilities.Object(Documenter.Deps, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.DocsNode(This module provides APIs for handling documentation metadata in modules.

The implementation is similar to how docstrings are handled in `Base` by the `Base.Docs` module — a special variable is created in each module that has documentation metadata.

# Public API

  * [`DocMeta.getdocmeta`](public.md#Documenter.DocMeta.getdocmeta)
  * [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!)

# Supported metadata

  * `DocTestSetup`: contains the doctest setup code for doctests in the module.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta, Union{}), 186, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :module), (Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.DocsNode(```julia
pip(deps)

```

Installs (as non-root user) all python packages listed in `deps`.

# Examples

```julia
using Documenter

makedocs(
    # ...
)

deploydocs(
    deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;, &quot;mkdocs-material&quot;),
    # ...
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), 184, &quot;build/lib/public.md&quot;, &quot;Documenter.Deps.pip&quot;, 1), Documenter.Utilities.Object(Documenter.Deps.pip, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Deps, :function), (Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.DocsNode(```julia
getdocmeta(m::Module)
```

Returns the documentation metadata dictionary for the module `m`. The dictionary should be considered immutable and assigning values to it is not well-defined. To set documentation metadata values, [`DocMeta.setdocmeta!`](public.md#Documenter.DocMeta.setdocmeta!) should be used instead.

```
getdocmeta(m::Module, key::Symbol, default=nothing)
```

Return the `key` entry from the documentation metadata for module `m`, or `default` if the value is unset.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), 187, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.getdocmeta&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.getdocmeta, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.DocsNode(```julia
setdocmeta!(m::Module, key::Symbol, value; recursive=false, warn=true)
```

Set the documentation metadata value `key` for module `m` to `value`.

If `recursive` is set to `true`, it sets the same metadata value for all the submodules too. If `warn` is `true`, it prints a warning when `key` already exists and is gets rewritten.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), 188, &quot;build/lib/public.md&quot;, &quot;Documenter.DocMeta.setdocmeta!&quot;, 1), Documenter.Utilities.Object(Documenter.DocMeta.setdocmeta!, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.DocMeta, :function), (Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.DocsNode(```julia
asset(uri)
```

Can be used to pass non-local web assets to [`HTML`](writers.md#Documenter.Writers.HTMLWriter.HTML), where `uri` should be an absolute HTTP or HTTPS URL.

It accepts the following keyword arguments:

**`class`** can be used to override the asset class, which determines how exactly the asset gets included in the HTML page. This is necessary if the class can not be determined automatically (default).

Should be one of: `:js`, `:css` or `:ico`. They become a `&lt;script&gt;`, `&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;` and `&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot;&gt;` elements in `&lt;head&gt;`, respectively.

**`islocal`** can be used to declare the asset to be local. The `uri` should then be a path relative to the documentation source directory (conventionally `src/`). This can be useful when it is necessary to override the asset class of a local asset.

# Usage

```julia
Documenter.HTML(assets = [
    # Standard local asset
    &quot;assets/extra_styles.css&quot;,
    # Standard remote asset (extension used to determine that class = :js)
    asset(&quot;https://example.com/jslibrary.js&quot;),
    # Setting asset class manually, since it can&#39;t be determined manually
    asset(&quot;https://example.com/fonts&quot;, class = :css),
    # Same as above, but for a local asset
    asset(&quot;asset/foo.script&quot;, class=:js, islocal=true),
])
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), 181, &quot;build/lib/public.md&quot;, &quot;Documenter.Writers.HTMLWriter.asset&quot;, 1), Documenter.Utilities.Object(Documenter.Writers.HTMLWriter.asset, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter.Writers.HTMLWriter, :function), (Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.DocsNode(```julia
deploydocs(
    root   = &quot;&lt;current-directory&gt;&quot;,
    target = &quot;build&quot;,
    repo   = &quot;&lt;required&gt;&quot;,
    branch = &quot;gh-pages&quot;,
    deps   = nothing | &lt;Function&gt;,
    make   = nothing | &lt;Function&gt;,
    devbranch = &quot;master&quot;,
    devurl = &quot;dev&quot;,
    versions = [&quot;stable&quot; =&gt; &quot;v^&quot;, &quot;v#.#&quot;, devurl =&gt; devurl],
    push_preview    = false,
    repo_previews   = repo,
    branch_previews = branch,
)
```

Converts markdown files generated by [`makedocs`](public.md#Documenter.makedocs) to HTML and pushes them to `repo`. This function should be called from within a package&#39;s `docs/make.jl` file after the call to [`makedocs`](public.md#Documenter.makedocs), like so

```julia
using Documenter, PACKAGE_NAME
makedocs(
    # options...
)
deploydocs(
    repo = &quot;github.com/...&quot;
)
```

When building the docs for a tag (i.e. a release) the documentation is deployed to a directory with the tag name (i.e. `vX.Y.Z`) and to the `stable` directory. Otherwise the docs are deployed to the directory determined by the `devurl` argument.

# Required keyword arguments

**`repo`** is the remote repository where generated HTML content should be pushed to. Do not specify any protocol - &quot;https://&quot; or &quot;git@&quot; should not be present. This keyword *must* be set and will throw an error when left undefined. For example this package uses the following `repo` value:

```julia
repo = &quot;github.com/JuliaDocs/Documenter.jl.git&quot;
```

# Optional keyword arguments

**`deploy_config`** determines configuration for the deployment. If this is not specified Documenter will try to autodetect from the currently running environment. See the manual section about [Deployment systems](../man/hosting.md#Deployment-systems).

**`root`** has the same purpose as the `root` keyword for [`makedocs`](public.md#Documenter.makedocs).

**`target`** is the directory, relative to `root`, where generated content that should be deployed to `gh-pages` is written to. It should generally be the same as [`makedocs`](public.md#Documenter.makedocs)&#39;s `build` and defaults to `&quot;build&quot;`.

**`branch`** is the branch where the generated documentation is pushed. If the branch does not exist, a new orphaned branch is created automatically. It defaults to `&quot;gh-pages&quot;`.

**`deps`** is the function used to install any additional dependencies needed to build the documentation. By default nothing is installed.

It can be used e.g. for a Markdown build. The following example installed the `pygments` and `mkdocs` Python packages using the [`Deps.pip`](public.md#Documenter.Deps.pip) function:

```julia
deps = Deps.pip(&quot;pygments&quot;, &quot;mkdocs&quot;)
```

**`make`** is the function used to specify an additional build phase. By default, nothing gets executed.

**`devbranch`** is the branch that &quot;tracks&quot; the in-development version of the generated documentation. By default this value is set to `&quot;master&quot;`.

**`devurl`** the folder that in-development version of the docs will be deployed. Defaults to `&quot;dev&quot;`.

**`forcepush`** a boolean that specifies the behavior of the git-deployment. The default (`forcepush = false`) is to push a new commit, but when `forcepush = true` the changes will be combined with the previous commit and force pushed, erasing the Git history on the deployment branch.

**`versions`** determines content and order of the resulting version selector in the generated html. The following entries are valid in the `versions` vector:

  * `&quot;v#&quot;`: includes links to the latest documentation for each major release cycle (i.e. `v2.0`, `v1.1`).
  * `&quot;v#.#&quot;`: includes links to the latest documentation for each minor release cycle (i.e. `v2.0`, `v1.1`, `v1.0`, `v0.1`).
  * `&quot;v#.#.#&quot;`: includes links to all released versions.
  * `&quot;v^&quot;`: includes a link to the docs for the maximum version (i.e. a link `vX.Y` pointing to `vX.Y.Z` for highest `X`, `Y`, `Z`, respectively).
  * A pair, e.g. `&quot;first&quot; =&gt; &quot;second&quot;`, which will put `&quot;first&quot;` in the selector, and generate a url from which `&quot;second&quot;` can be accessed. The second argument can be `&quot;v^&quot;`, to point to the maximum version docs (as in e.g. `&quot;stable&quot; =&gt; &quot;v^&quot;`).

If `versions = nothing` documentation will be deployed directly to the &quot;root&quot;, i.e. not to a versioned subfolder. See the manual section on [Deploying without the versioning scheme](../man/hosting.md#Deploying-without-the-versioning-scheme) for more details.

**`push_preview`** a boolean that specifies if preview documentation should be deployed from pull requests or not. If your published documentation is hosted at `&quot;https://USER.github.io/PACKAGE.jl/stable`, by default the preview will be hosted at `&quot;https://USER.github.io/PACKAGE.jl/previews/PR##&quot;`. This feature works for pull requests with head branch in the same repository, i.e. not from forks.

**`branch_previews`** is the branch to which pull request previews are deployed. It defaults to the value of `branch`.

**`repo_previews`** is the remote repository to which pull request previews are deployed. It defaults to the value of `repo`.

!!! note
    Pull requests made from forks will not have previews. Hosting previews requires access to the deploy key. Therefore, previews are available only for pull requests that were submitted directly from the main repository.


# Releases vs development branches

[`deploydocs`](public.md#Documenter.deploydocs) will automatically figure out whether it is deploying the documentation for a tagged release or just a development branch (usually, based on the environment variables set by the CI system).

With versioned tags, [`deploydocs`](public.md#Documenter.deploydocs) discards the build metadata (i.e. `+` and everything that follows it) from the version number when determining the name of the directory into which the documentation gets deployed. Pre-release identifiers are preserved.

# See Also

The [Hosting Documentation](../man/hosting.md#Hosting-Documentation) section of the manual provides a step-by-step guide to using the [`deploydocs`](public.md#Documenter.deploydocs) function to automatically generate docs and push them to GitHub.
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.deploydocs, Union{}), 182, &quot;build/lib/public.md&quot;, &quot;Documenter.deploydocs&quot;, 1), Documenter.Utilities.Object(Documenter.deploydocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.DocsNode(```julia
doctest(package::Module; kwargs...)
```

Convenience method that runs and checks all the doctests for a given Julia package. `package` must be the `Module` object corresponding to the top-level module of the package. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

# Keywords

**`manual`** controls how manual pages are handled. By default (`manual = true`), `doctest` assumes that manual pages are located under `docs/src`. If that is not the case, the `manual` keyword argument can be passed to specify the directory. Setting `manual = false` will skip doctesting of manual pages altogether.

Additional keywords are passed on to the main [`doctest`](public.md#Documenter.doctest) method.

```
doctest(source, modules; kwargs...)
```

Runs all the doctests in the given modules and on manual pages under the `source` directory. Behaves like an `@testset` call, returning a testset if all the doctests are successful or throwing a `TestSetException` if there are any failures. Can be included in other testsets.

The manual pages are searched recursively in subdirectories of `source` too. Doctesting of manual pages can be disabled if `source` is set to `nothing`.

# Keywords

**`testset`** specifies the name of test testset (default `Doctests`).

**`doctestfilters`** vector of regex to filter tests (see the manual on [Filtering Doctests](../man/doctests.md#Filtering-Doctests))

**`fix`**, if set to `true`, updates all the doctests that fail with the correct output (default `false`).

!!! warning
    When running `doctest(...; fix=true)`, Documenter will modify the Markdown and Julia source files. It is strongly recommended that you only run it on packages in Pkg&#39;s develop mode and commit any staged changes. You should also review all the changes made by `doctest` before committing them, as there may be edge cases when the automatic fixing fails.

, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.doctest, Union{}), 185, &quot;build/lib/public.md&quot;, &quot;Documenter.doctest&quot;, 1), Documenter.Utilities.Object(Documenter.doctest, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.DocsNode(```julia
hide(page)

```

Allows a page to be hidden in the navigation menu. It will only show up if it happens to be the current page. The hidden page will still be present in the linear page list that can be accessed via the previous and next page links. The title of the hidden page can be overridden using the `=&gt;` operator as usual.

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;page1.md&quot;),
        hide(&quot;Title&quot; =&gt; &quot;page2.md&quot;)
    ]
)
```

```julia
hide(root, children)

```

Allows a subsection of pages to be hidden from the navigation menu. `root` will be linked to in the navigation menu, with the title determined as usual. `children` should be a list of pages (note that it **can not** be hierarchical).

# Usage

```julia
makedocs(
    ...,
    pages = [
        ...,
        hide(&quot;Hidden section&quot; =&gt; &quot;hidden_index.md&quot;, [
            &quot;hidden1.md&quot;,
            &quot;Hidden 2&quot; =&gt; &quot;hidden2.md&quot;
        ]),
        hide(&quot;hidden_index.md&quot;, [...])
    ]
)
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.hide, Union{}), 180, &quot;build/lib/public.md&quot;, &quot;Documenter.hide&quot;, 1), Documenter.Utilities.Object(Documenter.hide, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.DocsNode(```julia
makedocs(
    root    = &quot;&lt;current-directory&gt;&quot;,
    source  = &quot;src&quot;,
    build   = &quot;build&quot;,
    clean   = true,
    doctest = true,
    modules = Module[],
    repo    = &quot;&quot;,
    highlightsig = true,
    sitename = &quot;&quot;,
    expandfirst = [],
)
```

Combines markdown files and inline docstrings into an interlinked document. In most cases [`makedocs`](public.md#Documenter.makedocs) should be run from a `make.jl` file:

```julia
using Documenter
makedocs(
    # keywords...
)
```

which is then run from the command line with:

```sh
$ julia make.jl
```

The folder structure that [`makedocs`](public.md#Documenter.makedocs) expects looks like:

```
docs/
    build/
    src/
    make.jl
```

# Keywords

**`root`** is the directory from which `makedocs` should run. When run from a `make.jl` file this keyword does not need to be set. It is, for the most part, needed when repeatedly running `makedocs` from the Julia REPL like so:

```
julia&gt; makedocs(root = joinpath(dirname(pathof(MyModule)), &quot;..&quot;, &quot;docs&quot;))
```

**`source`** is the directory, relative to `root`, where the markdown source files are read from. By convention this folder is called `src`. Note that any non-markdown files stored in `source` are copied over to the build directory when [`makedocs`](public.md#Documenter.makedocs) is run.

**`build`** is the directory, relative to `root`, into which generated files and folders are written when [`makedocs`](public.md#Documenter.makedocs) is run. The name of the build directory is, by convention, called `build`, though, like with `source`, users are free to change this to anything else to better suit their project needs.

**`clean`** tells [`makedocs`](public.md#Documenter.makedocs) whether to remove all the content from the `build` folder prior to generating new content from `source`. By default this is set to `true`.

**`doctest`** instructs [`makedocs`](public.md#Documenter.makedocs) on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to `true`. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it&#39;s encouraged to always make sure that documentation examples are runnable and produce the expected results. See the [Doctests](../man/doctests.md#Doctests) manual section for details about running doctests.

Setting `doctest` to `:only` allows for doctesting without a full build. In this mode, most build stages are skipped and the `strict` keyword is ignore (a doctesting error will always make `makedocs` throw an error).

**`modules`** specifies a vector of modules that should be documented in `source`. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of [`makedocs`](public.md#Documenter.makedocs). By default no modules are passed to `modules` and so no warnings will appear. This setting can be used as an indicator of the &quot;coverage&quot; of the generated documentation. For example Documenter&#39;s `make.jl` file contains:

```julia
makedocs(
    modules = [Documenter],
    # ...
)
```

and so any docstring from the module `Documenter` that is not spliced into the generated documentation in `build` will raise a warning.

**`repo`** specifies a template for the &quot;link to source&quot; feature. If you are using GitHub, this is automatically generated from the remote. If you are using a different host, you can use this option to tell Documenter how URLs should be generated. The following placeholders will be replaced with the respective value of the generated link:

  * `{commit}` Git branch or tag name, or commit hash
  * `{path}` Path to the file in the repository
  * `{line}` Line (or range of lines) in the source file

BitBucket, GitLab and Azure DevOps are supported along with GitHub, for example:

```julia
makedocs(repo = &quot;https://gitlab.com/user/project/blob/{commit}{path}#{line}&quot;) # GitLab
makedocs(repo = &quot;https://dev.azure.com/org/project/_git/repo?path={path}&amp;version={commit}{line}&amp;lineStartColumn=1&amp;lineEndColumn=1&quot;) # Azure DevOps
makedocs(repo = &quot;https://bitbucket.org/user/project/src/{commit}/{path}#lines-{line}&quot;) # BitBucket
```

**`highlightsig`** enables or disables automatic syntax highlighting of leading, unlabeled code blocks in docstrings (as Julia code). For example, if your docstring begins with an indented code block containing the function signature, then that block would be highlighted as if it were a labeled Julia code block. No other code blocks are affected. This feature is enabled by default.

**`sitename`** is displayed in the title bar and/or the navigation menu when applicable.

**`expandfirst`** allows some of the pages to be *expanded* (i.e. at-blocks evaluated etc.) before the others. Documenter normally evaluates the files in the alphabetic order of their file paths relative to `src`, but `expandfirst` allows some pages to be prioritized.

For example, if you have `foo.md` and `bar.md`, `bar.md` would normally be evaluated before `foo.md`. But with `expandfirst = [&quot;foo.md&quot;]`, you can force `foo.md` to be evaluated first.

Evaluation order among the `expandfirst` pages is according to the order they appear in the argument.

# Experimental keywords

In addition to standard arguments there is a set of non-finalized experimental keyword arguments. The behaviour of these may change or they may be removed without deprecation when a minor version changes (i.e. except in patch releases).

**`checkdocs`** instructs [`makedocs`](public.md#Documenter.makedocs) to check whether all names within the modules defined in the `modules` keyword that have a docstring attached have the docstring also listed in the manual (e.g. there&#39;s a `@docs` block with that docstring). Possible values are `:all` (check all names; the default), `:exports` (check only exported names) and `:none` (no checks are performed). If `strict` is also enabled then the build will fail if any missing docstrings are encountered.

**`linkcheck`** – if set to `true` [`makedocs`](public.md#Documenter.makedocs) uses `curl` to check the status codes of external-pointing links, to make sure that they are up-to-date. The links and their status codes are printed to the standard output. If `strict` is also enabled then the build will fail if there are any broken (400+ status code) links. Default: `false`.

**`linkcheck_ignore`** allows certain URLs to be ignored in `linkcheck`. The values should be a list of strings (which get matched exactly) or `Regex` objects. By default nothing is ignored.

**`linkcheck_timeout`** configures how long `curl` waits (in seconds) for a link request to return a response before giving up. The default is 10 seconds.

**`strict`** – [`makedocs`](public.md#Documenter.makedocs) fails the build right before rendering if it encountered any errors with the document in the previous build phases.

**`workdir`** determines the working directory where `@example` and `@repl` code blocks are executed. It can be either a path or the special value `:build` (default).

If the `workdir` is set to a path, the working directory is reset to that path for each code block being evaluated. Relative paths are taken to be relative to `root`, but using absolute paths is recommended (e.g. `workdir = joinpath(@__DIR__, &quot;..&quot;)` for executing in the package root for the usual `docs/make.jl` setup).

With the default `:build` option, the working directory is set to a subdirectory of `build`, determined from the source file path. E.g. for `src/foo.md` it is set to `build/`, for `src/foo/bar.md` it is set to `build/foo` etc.

Note that `workdir` does not affect doctests.

## Output formats

**`format`** allows the output format to be specified. The default format is [`Documenter.HTML`](internals/writers.md#Documenter.Writers.HTMLWriter.HTML) which creates a set of HTML files, but Documenter also provides PDF output via the [`Documenter.LaTeX`](internals/writers.md#Documenter.Writers.LaTeXWriter.LaTeX) writer.

Other formats can be enabled by using other addon-packages. For example, the [DocumenterMarkdown](https://github.com/JuliaDocs/DocumenterMarkdown.jl) package provides the original Markdown -&gt; Markdown output. See the [Other Output Formats](../man/other-formats.md#Other-Output-Formats) for more information.

# See Also

A guide detailing how to document a package using Documenter&#39;s [`makedocs`](public.md#Documenter.makedocs) is provided in the [setup guide in the manual](../man/guide.md#Package-Guide).
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(Documenter.makedocs, Union{}), 179, &quot;build/lib/public.md&quot;, &quot;Documenter.makedocs&quot;, 1), Documenter.Utilities.Object(Documenter.makedocs, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, Documenter, :function), (Documenter.Utilities.Object(DocumenterTools.OutdatedWarning.generate, Union{}), Documenter.Documents.DocsNode(#= circular reference @-6 =#), &quot;public.md&quot;, DocumenterTools.OutdatedWarning, :function), (Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.generate(path::String = &quot;docs&quot;; name = nothing, format = :html)
```

Create a documentation stub in `path`, which is usually a sub folder in the package root. The name of the package is determined automatically, but can be given with the `name` keyword argument.

`generate` can also be called without any arguments, in which case it simply puts all the generated files into a `docs` directory in the current working directory. This way, if you are already in the root directory of your package, you generally only need to call `generate()` to generate the documentation stub.

`generate` creates the following files in `path`:

```
.gitignore
src/index.md
make.jl
mkdocs.yml
Project.toml
```

# Arguments

**`path`** file path to the documentation directory to be created (default is `&quot;docs&quot;`).

# Keywords Arguments

**`name`** is the name of the package (without `.jl`). If `name` is not given `generate` tries to detect it automatically.

**`format`** can be either `:html` (default), `:markdown` or `:pdf` corresponding to the `format` keyword to Documenter&#39;s `makedocs` function, see [Documenter&#39;s manual](https://juliadocs.github.io/Documenter.jl/stable/man/other-formats/).

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.generate(&quot;path/to/MyPackage/docs&quot;)
[ ... output ... ]
```

```
DocumenterTools.generate(pkg::Module; dir = &quot;docs&quot;, format = :html)
```

Same as `generate(path::String)` but the `path` and name is determined automatically from the module.

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating docs.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; using MyPackage

julia&gt; DocumenterTools.generate(MyPackage)
[ ... output ... ]
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.generate, Union{}), 189, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.generate&quot;, 1), Documenter.Utilities.Object(DocumenterTools.generate, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function), (Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.DocsNode(```julia
DocumenterTools.genkeys(; user=&quot;$USER&quot;, repo=&quot;$REPO&quot;)
```

Generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages.

By default the links in the instructions need to be modified to correspond to actual URLs. The optional `user` and `repo` keyword arguments can be specified so that the URLs in the printed instructions could be copied directly. They should be the name of the GitHub user or organization where the repository is hosted and the full name of the repository, respectively.

This method of [`genkeys`](public.md#DocumenterTools.genkeys) requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `ssh-keygen`

# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys()
[ Info: add the public key below to https://github.com/$USER/$REPO/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/$USER/$REPO/settings (if you deploy using Travis CI) or https://github.com/$USER/$REPO/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==


julia&gt; DocumenterTools.genkeys(user=&quot;JuliaDocs&quot;, repo=&quot;DocumenterTools.jl&quot;)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```

```
genkeys(package::Module; remote=&quot;origin&quot;)
```

Like the other method, this generates the SSH keys necessary for the automatic deployment of documentation with Documenter from a builder to GitHub Pages, but attempts to guess the package URLs from the Git remote.

`package` needs to be the top level module of the package. The `remote` keyword argument can be used to specify which Git remote is used for guessing the repository&#39;s GitHub URL.

This method requires the following command lines programs to be installed:

  * `which` (Unix) or `where` (Windows)
  * `git`
  * `ssh-keygen`

!!! note
    The package must be in development mode. Make sure you run `pkg&gt; develop pkg` from the Pkg REPL, or `Pkg.develop(&quot;pkg&quot;)` before generating the SSH keys.


# Examples

```julia-repl
julia&gt; using DocumenterTools

julia&gt; DocumenterTools.genkeys(DocumenterTools)
[Info: add the public key below to https://github.com/JuliaDocs/DocumenterTools.jl/settings/keys with read/write access:

ssh-rsa AAAAB3NzaC2yc2EAAAaDAQABAAABAQDrNsUZYBWJtXYUk21wxZbX3KxcH8EqzR3ZdTna0Wgk...jNmUiGEMKrr0aqQMZEL2BG7 username@hostname

[ Info: add a secure environment variable named &#39;DOCUMENTER_KEY&#39; to https://travis-ci.com/JuliaDocs/DocumenterTools.jl/settings (if you deploy using Travis CI) or https://github.com/JuliaDocs/DocumenterTools.jl/settings/secrets (if you deploy using GitHub Actions) with value:

LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNnpiRkdXQVZpYlIy...QkVBRWFjY3BxaW9uNjFLaVdOcDU5T2YrUkdmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
```
, Documenter.Anchors.Anchor(Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), 190, &quot;build/lib/public.md&quot;, &quot;DocumenterTools.genkeys&quot;, 1), Documenter.Utilities.Object(DocumenterTools.genkeys, Union{}), Documenter.Documents.Page(#= circular reference @-6 =#)), &quot;public.md&quot;, DocumenterTools, :function)]), Markdown.Header{2}(Any[&quot;Public Interface&quot;]) =&gt; Documenter.Anchors.Anchor(Markdown.Header{2}(Any[&quot;Public Interface&quot;]), 39, &quot;build/lib/public.md&quot;, &quot;Public-Interface&quot;, 1), Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;]) =&gt; Markdown.Paragraph(Any[&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;])), Documenter.Documents.Globals(Main, Dict{Symbol, Any}(:CurrentFile =&gt; &quot;src/lib/public.md&quot;)), Documenter.Utilities.Markdown2.MD(Documenter.Utilities.Markdown2.MarkdownBlockNode[Documenter.Utilities.Markdown2.Heading(1, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Documentation&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Documentation for &quot;), Documenter.Utilities.Markdown2.CodeSpan(&quot;Documenter.jl&quot;), Documenter.Utilities.Markdown2.Text(&quot;&#39;s public interface.&quot;)]), Documenter.Utilities.Markdown2.Paragraph(Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;See the Internals section of the manual for internal package docs covering all submodules.&quot;)]), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Contents&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@contents&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Index&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@index&quot;, &quot;Pages = [\&quot;public.md\&quot;]&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;Public Interface&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;Documenter\nmakedocs\nhide\nasset\ndeploydocs\nDeps\nDeps.pip\ndoctest\nDocMeta\nDocMeta.getdocmeta\nDocMeta.setdocmeta!&quot;), Documenter.Utilities.Markdown2.Heading(2, Documenter.Utilities.Markdown2.MarkdownInlineNode[Documenter.Utilities.Markdown2.Text(&quot;DocumenterTools&quot;)]), Documenter.Utilities.Markdown2.CodeBlock(&quot;@docs&quot;, &quot;DocumenterTools.generate\nDocumenterTools.genkeys\nDocumenterTools.OutdatedWarning.generate&quot;)])))])</article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../showcase/">« Showcase</a><a class="docs-footer-nextpage" href="../internals/anchors/">Anchors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Wednesday 7 July 2021 16:40">Wednesday 7 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
