{
    "docs": [
        {
            "location": "/", 
            "text": "Lapidary Documentation Outline\n\n\n\n\nPackage Manual\n\n\n\n\nDoctests\n\n\n\"Script\" Examples\n\n\nREPL Examples\n\n\nSkipping Doctests\n\n\n\n\n\n\nPackage Guide\n\n\nInstallation\n\n\nUsage\n\n\nSyntax\n\n\n\n\n\n\n\n\n\n\nPackage Reference\n\n\n\n\nInternal Documentation\n\n\nTypes\n\n\nStages\n\n\nExpanders\n\n\nUtilities\n\n\n\n\n\n\nPublic Documentation\n\n\n\n\n\n\nDocumentation Index\n\n\n\n\nCheckDocs\n\n\nContentsBlock\n\n\nContentsNode\n\n\nCopyAssetsDirectory\n\n\nCrossReferenceLinks\n\n\nDefaultExpander\n\n\nDocsBlock\n\n\nDocsNode\n\n\nEnv\n\n\nExpandTemplates\n\n\nFindHeaders\n\n\nHeaderPath\n\n\nIndexBlock\n\n\nIndexNode\n\n\nMetaBlock\n\n\nMetaNode\n\n\nParseTemplates\n\n\nParsedPath\n\n\nPath\n\n\nRenderDocument\n\n\nRunDocTests\n\n\nSetupBuildDirectory\n\n\nState\n\n\nassetsdir\n\n\ncar\n\n\ncdr\n\n\ncurrentdir\n\n\ndoctest\n\n\nexpand\n\n\nlog\n\n\nnodocs\n\n\nparseblock\n\n\nprocess\n\n\nslugify\n\n\nwalk\n\n\nmakedocs", 
            "title": "Home"
        }, 
        {
            "location": "/#lapidary-documentation-outline", 
            "text": "", 
            "title": "Lapidary Documentation Outline"
        }, 
        {
            "location": "/#package-manual", 
            "text": "Doctests  \"Script\" Examples  REPL Examples  Skipping Doctests    Package Guide  Installation  Usage  Syntax", 
            "title": "Package Manual"
        }, 
        {
            "location": "/#package-reference", 
            "text": "Internal Documentation  Types  Stages  Expanders  Utilities    Public Documentation", 
            "title": "Package Reference"
        }, 
        {
            "location": "/#documentation-index", 
            "text": "CheckDocs  ContentsBlock  ContentsNode  CopyAssetsDirectory  CrossReferenceLinks  DefaultExpander  DocsBlock  DocsNode  Env  ExpandTemplates  FindHeaders  HeaderPath  IndexBlock  IndexNode  MetaBlock  MetaNode  ParseTemplates  ParsedPath  Path  RenderDocument  RunDocTests  SetupBuildDirectory  State  assetsdir  car  cdr  currentdir  doctest  expand  log  nodocs  parseblock  process  slugify  walk  makedocs", 
            "title": "Documentation Index"
        }, 
        {
            "location": "/man/guide/", 
            "text": "Package Guide\n\n\n\n\nInstallation\n\n\nLapidary is currently not registered and so must be installed via \nPkg.clone\n.\n\n\nPkg\n.\nclone\n(\nhttps://github.com/MichaelHatherly/Lapidary.jl\n)\n\n\n\n\n\n\nThis package supports Julia \n0.4\n and \n0.5\n.\n\n\n\n\nUsage\n\n\nLapidary is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.\n\n\n\n\nSetting up the folder structure\n\n\nFirstly, we need a Julia module to document. This could be a package generated via \nPkgDev.generate\n or a single \n.jl\n script. For this guide we'll be using a package called \nExample.jl\n that has the following directory layout:\n\n\nExample/\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nNote that the \n...\n just represent unimportant files and folders.\n\n\nWe must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named \ndocs/\n in the toplevel of the package, like so\n\n\nExample/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nInside the \ndocs/\n folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended\n\n\ndocs/\n    src/\n    make.jl\n\n\n\n\n\n\n\nBuilding an empty document\n\n\nWith our \ndocs/\n directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.\n\n\nAdd the following to your \nmake.jl\n file\n\n\nusing\n \nLapidary\n,\n \nExample\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nThis assumes you've installed Lapidary as discussed in \nInstallation\n and that your Examples package can be found by Julia.\n\n\nNow add an \nindex.md\n file to the \nsrc/\n directory. The name has no particular significance though and you may name it whatever you like. We'll stick to \nindex.md\n for this guide.\n\n\nLeave the newly added file empty and the run the following command from the \ndocs/\n directory\n\n\n$ julia make.jl\n\n\n\n\n\nNote that \n$\n just represents the prompt character. You don't need to type that.\n\n\nIf you'd like to see the output from this command in color use\n\n\n$ julia --color\n=\nyes make.jl\n\n\n\n\n\nWe you run that you should see the following output\n\n\nLAPIDARY\n:\n \nsetting\n \nup\n \nbuild\n \ndirectory\n.\n\n\nLAPIDARY\n:\n \ncopying\n \nassets\n \nto\n \nbuild\n \ndirectory\n.\n\n\nLAPIDARY\n:\n \nparsing\n \nmarkdown\n \ntemplates\n.\n\n\nLAPIDARY\n:\n \nexpanding\n \nparsed\n \ntemplate\n \nfiles\n.\n\n\nLAPIDARY\n:\n \ngenerating\n \ncross\n-\nreference\n \nlinks\n.\n\n\nLAPIDARY\n:\n \nrunning\n \ndoctests\n.\n\n\nLAPIDARY\n:\n \nchecking\n \ndocument\n \nconsistency\n.\n\n\nLAPIDARY\n:\n \nwriting\n \ndocument\n \nto\n \nfile\n.\n\n\n\n\n\n\nThe \ndocs/\n folder should contain a new directory \u2013 called \nbuild/\n. It's structure should look like the following\n\n\nbuild/\n    assets/\n        Lapidary.css\n        mathjaxhelper.js\n    index.md\n\n\n\n\n\nAt the moment \nbuild/index.md\n should be empty since \nsrc/index.md\n is empty.\n\n\nAt this point you can add some text to \nsrc/index.md\n and rerun the \nmake.jl\n file to see the changes if you'd like to.\n\n\n\n\nAdding some docstrings\n\n\nNext we'll splice a docstring defined in the \nExample\n module into the \nindex.md\n file. To do this first document a function in that module:\n\n\nmodule\n \nExample\n\n\n\nexport\n \nfunc\n\n\n\n\n\n    func(x)\n\n\n\nReturns double the number `x` plus `1`.\n\n\n\n\nfunc\n(\nx\n)\n \n=\n \n2\nx\n \n+\n \n1\n\n\n\nend\n\n\n\n\n\n\nThen in the \nsrc/index.md\n file add the following\n\n\n# Example.jl Documentation\n\n    {docs}\n    func(x)\n\n\n\n\n\nWhen we next run \nmake.jl\n the docstring for \nExample.func(x)\n should appear in place of the \n{docs}\n block in \nbuild/index.md\n. Note that \nmore than one\n object can be referenced inside a \n{docs}\n block \u2013 just place each one on a separate line.\n\n\nNote that the module in which a \n{docs}\n block is evaluated is determined by \ncurrent_module()\n and so will more than likely be \nMain\n. This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a \n{meta}\n block as in the following\n\n\n# Example.jl Documentation\n\n    {meta}\n    CurrentModule = Lapidary\n\n...\n\n    {docs}\n    func(x)\n\n\n\n\n\nNote that the \n...\n in the example above is just there to stop the code blocks from merging into a single block. You could use fenced code blocks instead to avoid needing to have to break up the blocks using extra text.\n\n\n\n\nCross Referencing\n\n\nIt may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Lapidary's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of \nsrc/index.md\n with the following\n\n\n# Example.jl Documentation\n\n    {docs}\n    func(x)\n\n- link to [Example.jl Documentation]({ref})\n- link to [`func(x)`]({ref})\n\n\n\n\n\nSo we just have to replace each link's url with \n{ref}\n and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.\n\n\nThis also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.\n\n\n\n\nNavigation\n\n\nLapidary can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our \nindex.md\n file from the previous sections. Add the following to that file\n\n\n# Example.jl Documentation\n\n    {contents}\n\n## Functions\n\n    {docs}\n    func(x)\n\n## Index\n\n    {index}\n\n\n\n\n\nThe \n{contents}\n block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using \nPages\n and \nDepth\n settings as in the following\n\n\n    {contents}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n    Depth = 3\n\n\n\n\n\nThe \n{index}\n block will generate a flat list of links to all the docs that that have been spliced into the document using \n{docs}\n blocks. As with the \n{contents}\n block the pages to be included can be set with a \nPages = [...]\n line. Since the list is not nested \nDepth\n is not supported for \n{index}\n.\n\n\n\n\nSyntax\n\n\nThis section provides a quick summary of the available syntax and it's meaning.\n\n\n\n\n{ref}\n\n\nUsed in markdown links as the url to tell Lapidary to generate a cross-reference automatically. The text part of the link can be either a docstring or header name.\n\n\n[Foo]({ref})   # Link to the section called \nFoo\n.\n[`bar`]({ref}) # Link to the docstring called `bar`.\n\n\n\n\n\n\n\n{docs}\n\n\nSplice a collection of docstrings into a document.\n\n\n    {docs}\n    Foo\n    bar(x)\n    @baz(x, y)\n\n\n\n\n\n\n\n{meta}\n\n\nUsed to define any number of metadata key/value pairs that can then be used elsewhere in the page. Currently \nCurrentModule = ...\n is the only recognised pair.\n\n\n    {meta}\n    CurrentModule = FooBar\n\n\n\n\n\n\n\n{index}\n\n\nGenerates a list of links to docstrings that have been spliced into a document. The only valid setting is currently \nPages = ...\n.\n\n\n    {index}\n    Pages = [\nfoo.md\n]\n\n\n\n\n\nWhen \nPages\n is not provided all pages in the document are included.\n\n\n\n\n{contents}\n\n\nGenerates a nested list of links to document sections. Valid settings are \nPages\n and \nDepth\n.\n\n\n    {contents}\n    Pages = [\nfoo.md\n]\n    Depth = 5\n\n\n\n\n\nAs with \n{index}\n if \nPages\n is not provided then all pages are included. The default \nDepth\n value is \n2\n.", 
            "title": "Guide"
        }, 
        {
            "location": "/man/guide/#package-guide", 
            "text": "", 
            "title": "Package Guide"
        }, 
        {
            "location": "/man/guide/#installation", 
            "text": "Lapidary is currently not registered and so must be installed via  Pkg.clone .  Pkg . clone ( https://github.com/MichaelHatherly/Lapidary.jl )   This package supports Julia  0.4  and  0.5 .", 
            "title": "Installation"
        }, 
        {
            "location": "/man/guide/#usage", 
            "text": "Lapidary is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.", 
            "title": "Usage"
        }, 
        {
            "location": "/man/guide/#setting-up-the-folder-structure", 
            "text": "Firstly, we need a Julia module to document. This could be a package generated via  PkgDev.generate  or a single  .jl  script. For this guide we'll be using a package called  Example.jl  that has the following directory layout:  Example/\n    src/\n        Example.jl\n    ...  Note that the  ...  just represent unimportant files and folders.  We must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named  docs/  in the toplevel of the package, like so  Example/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...  Inside the  docs/  folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended  docs/\n    src/\n    make.jl", 
            "title": "Setting up the folder structure"
        }, 
        {
            "location": "/man/guide/#building-an-empty-document", 
            "text": "With our  docs/  directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.  Add the following to your  make.jl  file  using   Lapidary ,   Example  makedocs ()   This assumes you've installed Lapidary as discussed in  Installation  and that your Examples package can be found by Julia.  Now add an  index.md  file to the  src/  directory. The name has no particular significance though and you may name it whatever you like. We'll stick to  index.md  for this guide.  Leave the newly added file empty and the run the following command from the  docs/  directory  $ julia make.jl  Note that  $  just represents the prompt character. You don't need to type that.  If you'd like to see the output from this command in color use  $ julia --color = yes make.jl  We you run that you should see the following output  LAPIDARY :   setting   up   build   directory .  LAPIDARY :   copying   assets   to   build   directory .  LAPIDARY :   parsing   markdown   templates .  LAPIDARY :   expanding   parsed   template   files .  LAPIDARY :   generating   cross - reference   links .  LAPIDARY :   running   doctests .  LAPIDARY :   checking   document   consistency .  LAPIDARY :   writing   document   to   file .   The  docs/  folder should contain a new directory \u2013 called  build/ . It's structure should look like the following  build/\n    assets/\n        Lapidary.css\n        mathjaxhelper.js\n    index.md  At the moment  build/index.md  should be empty since  src/index.md  is empty.  At this point you can add some text to  src/index.md  and rerun the  make.jl  file to see the changes if you'd like to.", 
            "title": "Building an empty document"
        }, 
        {
            "location": "/man/guide/#adding-some-docstrings", 
            "text": "Next we'll splice a docstring defined in the  Example  module into the  index.md  file. To do this first document a function in that module:  module   Example  export   func       func(x)  Returns double the number `x` plus `1`.   func ( x )   =   2 x   +   1  end   Then in the  src/index.md  file add the following  # Example.jl Documentation\n\n    {docs}\n    func(x)  When we next run  make.jl  the docstring for  Example.func(x)  should appear in place of the  {docs}  block in  build/index.md . Note that  more than one  object can be referenced inside a  {docs}  block \u2013 just place each one on a separate line.  Note that the module in which a  {docs}  block is evaluated is determined by  current_module()  and so will more than likely be  Main . This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a  {meta}  block as in the following  # Example.jl Documentation\n\n    {meta}\n    CurrentModule = Lapidary\n\n...\n\n    {docs}\n    func(x)  Note that the  ...  in the example above is just there to stop the code blocks from merging into a single block. You could use fenced code blocks instead to avoid needing to have to break up the blocks using extra text.", 
            "title": "Adding some docstrings"
        }, 
        {
            "location": "/man/guide/#cross-referencing", 
            "text": "It may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Lapidary's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of  src/index.md  with the following  # Example.jl Documentation\n\n    {docs}\n    func(x)\n\n- link to [Example.jl Documentation]({ref})\n- link to [`func(x)`]({ref})  So we just have to replace each link's url with  {ref}  and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.  This also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.", 
            "title": "Cross Referencing"
        }, 
        {
            "location": "/man/guide/#navigation", 
            "text": "Lapidary can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our  index.md  file from the previous sections. Add the following to that file  # Example.jl Documentation\n\n    {contents}\n\n## Functions\n\n    {docs}\n    func(x)\n\n## Index\n\n    {index}  The  {contents}  block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using  Pages  and  Depth  settings as in the following      {contents}\n    Pages = [ foo.md ,  bar.md ]\n    Depth = 3  The  {index}  block will generate a flat list of links to all the docs that that have been spliced into the document using  {docs}  blocks. As with the  {contents}  block the pages to be included can be set with a  Pages = [...]  line. Since the list is not nested  Depth  is not supported for  {index} .", 
            "title": "Navigation"
        }, 
        {
            "location": "/man/guide/#syntax", 
            "text": "This section provides a quick summary of the available syntax and it's meaning.", 
            "title": "Syntax"
        }, 
        {
            "location": "/man/guide/#ref", 
            "text": "Used in markdown links as the url to tell Lapidary to generate a cross-reference automatically. The text part of the link can be either a docstring or header name.  [Foo]({ref})   # Link to the section called  Foo .\n[`bar`]({ref}) # Link to the docstring called `bar`.", 
            "title": "{ref}"
        }, 
        {
            "location": "/man/guide/#docs", 
            "text": "Splice a collection of docstrings into a document.      {docs}\n    Foo\n    bar(x)\n    @baz(x, y)", 
            "title": "{docs}"
        }, 
        {
            "location": "/man/guide/#meta", 
            "text": "Used to define any number of metadata key/value pairs that can then be used elsewhere in the page. Currently  CurrentModule = ...  is the only recognised pair.      {meta}\n    CurrentModule = FooBar", 
            "title": "{meta}"
        }, 
        {
            "location": "/man/guide/#index", 
            "text": "Generates a list of links to docstrings that have been spliced into a document. The only valid setting is currently  Pages = ... .      {index}\n    Pages = [ foo.md ]  When  Pages  is not provided all pages in the document are included.", 
            "title": "{index}"
        }, 
        {
            "location": "/man/guide/#contents", 
            "text": "Generates a nested list of links to document sections. Valid settings are  Pages  and  Depth .      {contents}\n    Pages = [ foo.md ]\n    Depth = 5  As with  {index}  if  Pages  is not provided then all pages are included. The default  Depth  value is  2 .", 
            "title": "{contents}"
        }, 
        {
            "location": "/man/doctests/", 
            "text": "Doctests\n\n\nLapidary will, by default, try to run Julia code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Lapidary's doctest.\n\n\nThis section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.\n\n\n\n\n\"Script\" Examples\n\n\nThe first, of two, types of doctests is the \"script\" code block. To make Lapidary detect this kind of code block the following format must be used:\n\n\n```julia\na = 1\nb = 2\na + b\n\n# output\n\n3\n```\n\n\n\n\n\nThe code block's \"language\" must be \njulia\n and must include a line containing the text \n# output\n. The text before this line is the contents of the script which is run. The text that appears after \n# output\n is the textual representation that would be shown in the Julia REPL if the script had been \ninclude\nd.\n\n\nThe actual output produced by running the \"script\" is compared to the expected result and any difference will result in \nmakedocs\n throwing an error and terminating.\n\n\nNote that the amount of whitespace appearing above and below the \n# output\n line is not significant and can be increased or decreased if desired.\n\n\n\n\nREPL Examples\n\n\nThe other kind of doctest is a simulated Julia REPL session. The following format is detected by Lapidary as a REPL doctest:\n\n\n```julia\njulia\n a = 1;\n\njulia\n b = 2\n2\n\njulia\n a + b\n3\n\n```\n\n\n\n\n\nAs with script doctests, the code block must have it's language set to \njulia\n. When a code block contains one or more \njulia\n at the start of a line then it is assumed to be a REPL doctest. Semi-colons, \n;\n, at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.\n\n\nNote that not all features of the REPL are supported such as shell and help modes.\n\n\n\n\nSkipping Doctests\n\n\nDoctesting can be disabled by setting the \nmakedocs\n keyword \ndoctest = false\n. This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/doctests/#doctests", 
            "text": "Lapidary will, by default, try to run Julia code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Lapidary's doctest.  This section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/doctests/#script-examples", 
            "text": "The first, of two, types of doctests is the \"script\" code block. To make Lapidary detect this kind of code block the following format must be used:  ```julia\na = 1\nb = 2\na + b\n\n# output\n\n3\n```  The code block's \"language\" must be  julia  and must include a line containing the text  # output . The text before this line is the contents of the script which is run. The text that appears after  # output  is the textual representation that would be shown in the Julia REPL if the script had been  include d.  The actual output produced by running the \"script\" is compared to the expected result and any difference will result in  makedocs  throwing an error and terminating.  Note that the amount of whitespace appearing above and below the  # output  line is not significant and can be increased or decreased if desired.", 
            "title": "\"Script\" Examples"
        }, 
        {
            "location": "/man/doctests/#repl-examples", 
            "text": "The other kind of doctest is a simulated Julia REPL session. The following format is detected by Lapidary as a REPL doctest:  ```julia\njulia  a = 1;\n\njulia  b = 2\n2\n\njulia  a + b\n3\n\n```  As with script doctests, the code block must have it's language set to  julia . When a code block contains one or more  julia  at the start of a line then it is assumed to be a REPL doctest. Semi-colons,  ; , at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.  Note that not all features of the REPL are supported such as shell and help modes.", 
            "title": "REPL Examples"
        }, 
        {
            "location": "/man/doctests/#skipping-doctests", 
            "text": "Doctesting can be disabled by setting the  makedocs  keyword  doctest = false . This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.", 
            "title": "Skipping Doctests"
        }, 
        {
            "location": "/man/internals/", 
            "text": "Package Internals", 
            "title": "Internals"
        }, 
        {
            "location": "/man/internals/#package-internals", 
            "text": "", 
            "title": "Package Internals"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\n#\n\n\nFunction\n\n\nmakedocs(\n    root    = \ncurrent-directory\n,\n    source  = \nsrc\n,\n    build   = \nbuild\n,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n)\n\n\n\n\n\nCombines markdown files and inline docstrings into an interlinked document.\n\n\nIn most cases \nmakedocs\n should be run from a \nmake.jl\n file:\n\n\nusing\n \nLapidary\n\n\n\nmakedocs\n(\n\n    \n# keywords...\n\n\n)\n\n\n\n\n\n\nwhich is then run from the command line with:\n\n\n$ julia make.jl\n\n\n\n\n\nThe folder structure that \nmakedocs\n expects looks like:\n\n\ndocs/\n    build/\n    src/\n    make.jl\n\n\n\n\n\nKeywords\n\n\nroot\n is the directory from which \nmakedocs\n should run. When run from a \nmake.jl\n file this keyword does not need to be set. It is, for the most part, needed when repeatedly running \nmakedocs\n from the Julia REPL like so:\n\n\njulia\n makedocs(root = Pkg.dir(\nMyPackage\n, \ndocs\n))\n\n\n\n\n\nsource\n is the directory, relative to \nroot\n, where the markdown source files are read from. By convention this folder is called \nsrc\n. Note that any non-markdown files stored in \nsource\n are copied over to the build directory when \nmakedocs\n is run.\n\n\nbuild\n is the directory, relative to \nroot\n, into which generated files and folders are written when \nmakedocs\n is run. The name of the build directory is, by convention, called \nbuild\n, though, like with \nsource\n, users are free to change this to anything else to better suit their project needs.\n\n\nclean\n tells \nmakedocs\n whether to remove all the content from the \nbuild\n folder prior to generating new content from \nsource\n. By default this is set to \ntrue\n.\n\n\ndoctest\n instructs \nmakedocs\n on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to \ntrue\n. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the \nDoctests\n manual section for details about running doctests.\n\n\nmodules\n specifies a vector of modules that should be documented in \nsource\n. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of \nmakedocs\n. By default no modules are passed to \nmodules\n and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation.\n\n\nFor example Lapidary's \nmake.jl\n file contains:\n\n\nusing\n \nLapidary\n\n\n\n# Build documentation.\n\n\n# ====================\n\n\n\nmakedocs\n(\n\n    \n# options\n\n    \nmodules\n \n=\n \n[\nLapidary\n],\n\n    \nclean\n   \n=\n \nfalse\n\n\n)\n\n\n\n# Deploy built documentation from Travis.\n\n\n# =======================================\n\n\n\n# Needs to install an additional dep, mkdocs-material, so provide a custom `deps`.\n\n\ncustom_deps\n()\n \n=\n \nrun\n(\n`pip install --user pygments mkdocs mkdocs-material`\n)\n\n\n\ndeploydocs\n(\n\n    \n# options\n\n    \ndeps\n \n=\n \ncustom_deps\n,\n\n    \nrepo\n \n=\n \ngithub.com/MichaelHatherly/Lapidary.jl.git\n\n\n)\n\n\n\n\n\n\nand so any docstring from the module \nLapidary\n that is not spliced into the generated documentation in \nbuild\n will raise a warning.\n\n\nNotes\n\n\nA guide detailing how to document a package using Lapidary's \nmakedocs\n is provided in the \nUsage\n section of the manual.", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "#  Function  makedocs(\n    root    =  current-directory ,\n    source  =  src ,\n    build   =  build ,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n)  Combines markdown files and inline docstrings into an interlinked document.  In most cases  makedocs  should be run from a  make.jl  file:  using   Lapidary  makedocs ( \n     # keywords...  )   which is then run from the command line with:  $ julia make.jl  The folder structure that  makedocs  expects looks like:  docs/\n    build/\n    src/\n    make.jl  Keywords  root  is the directory from which  makedocs  should run. When run from a  make.jl  file this keyword does not need to be set. It is, for the most part, needed when repeatedly running  makedocs  from the Julia REPL like so:  julia  makedocs(root = Pkg.dir( MyPackage ,  docs ))  source  is the directory, relative to  root , where the markdown source files are read from. By convention this folder is called  src . Note that any non-markdown files stored in  source  are copied over to the build directory when  makedocs  is run.  build  is the directory, relative to  root , into which generated files and folders are written when  makedocs  is run. The name of the build directory is, by convention, called  build , though, like with  source , users are free to change this to anything else to better suit their project needs.  clean  tells  makedocs  whether to remove all the content from the  build  folder prior to generating new content from  source . By default this is set to  true .  doctest  instructs  makedocs  on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to  true . Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the  Doctests  manual section for details about running doctests.  modules  specifies a vector of modules that should be documented in  source . If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of  makedocs . By default no modules are passed to  modules  and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation.  For example Lapidary's  make.jl  file contains:  using   Lapidary  # Build documentation.  # ====================  makedocs ( \n     # options \n     modules   =   [ Lapidary ], \n     clean     =   false  )  # Deploy built documentation from Travis.  # =======================================  # Needs to install an additional dep, mkdocs-material, so provide a custom `deps`.  custom_deps ()   =   run ( `pip install --user pygments mkdocs mkdocs-material` )  deploydocs ( \n     # options \n     deps   =   custom_deps , \n     repo   =   github.com/MichaelHatherly/Lapidary.jl.git  )   and so any docstring from the module  Lapidary  that is not spliced into the generated documentation in  build  will raise a warning.  Notes  A guide detailing how to document a package using Lapidary's  makedocs  is provided in the  Usage  section of the manual.", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internal Documentation\n\n\n\n\nTypes\n\n\n#\n\n\nType\n\n\nState\n\n\n\n\n\nUsed to store the current state of the markdown template expansion. This simplifies the \nexpand\n methods by avoiding having to thread all the state between each call manually.\n\n\n\n\n#\n\n\nType\n\n\nPath\n\n\n\n\n\nRepresents a file mapping from source file \n.src\n to destination file \n.dst\n.\n\n\n\n\n#\n\n\nType\n\n\nParsedPath\n\n\n\n\n\nSame as \nPath\n, but also includes the parsed content of the markdown file.\n\n\n\n\n#\n\n\nType\n\n\nHeaderPath\n\n\n\n\n\nRepresents a file mapping from \n.src\n to \n.dst\n of a markdown header element. The \n.nth\n field tracks the ordering of the headers within the file.\n\n\n\n\n#\n\n\nType\n\n\nEnv\n\n\n\n\n\nStores all the state associated with a document. An instance of this type is threaded through the sequence of transformations used to build the document.\n\n\nEnv(kwargs...)\n\n\n\n\n\nHelper method used to simplidy the construction of \nEnv\n objects. Takes any number of keyword arguments. Note that unknown keyword arguments are discarded by this method.\n\n\n\n\n\n\nStages\n\n\n#\n\n\nType\n\n\nSetupBuildDirectory\n\n\n\n\n\nCleans out previous \nbuild\n directory and rebuilds the folder structure to match that of the \nsrc\n directory. Copies all non-markdown files from \nsrc\n to \nbuild\n.\n\n\n\n\n#\n\n\nType\n\n\nCopyAssetsDirectory\n\n\n\n\n\nCopies the contents of the Lapidary \nassets\n folder to \nbuild/assets\n.\n\n\nWill throw an error if the directory already exists.\n\n\n\n\n#\n\n\nType\n\n\nParseTemplates\n\n\n\n\n\nReads the contents of each markdown file found in \nsrc\n and them into \nMarkdown.MD\n objects using \nMarkdown.parse\n.\n\n\n\n\n#\n\n\nType\n\n\nExpandTemplates\n\n\n\n\n\nRuns all the expanders stored in \n.expanders\n on each element of the parsed markdown files.\n\n\n\n\n#\n\n\nType\n\n\nRunDocTests\n\n\n\n\n\nFinds all code blocks in an expanded document where the language is set to \njulia\n and tries to run them. Any failure will currently just terminate the entire document generation.\n\n\nNotes\n\n\nThis stage can be disabled in \nmakedocs\n by setting the keyword \ndoctest = false\n.\n\n\n\n\n#\n\n\nType\n\n\nCheckDocs\n\n\n\n\n\nConsistency checks for the generated documentation. Have all the available docs from the specified modules been added to the external docs?\n\n\n\n\n#\n\n\nType\n\n\nCrossReferenceLinks\n\n\n\n\n\nFinds all \nMarkdown.Link\n elements in an expanded document and tries to find where the link should point to. Will terminate the entire document generation process when a link cannot successfully be found.\n\n\n\n\n#\n\n\nType\n\n\nRenderDocument\n\n\n\n\n\nWrite the contents of the expanded document tree to file. Currently only supports markdown output.\n\n\n\n\n\n\nExpanders\n\n\n#\n\n\nFunction\n\n\nexpand\n\n\n\n\n\nExpand a single element, \nblock\n, of a markdown file.\n\n\n\n\n#\n\n\nType\n\n\nDefaultExpander\n\n\n\n\n\nBy default block expansion just pushes the block onto the end of the vector of expanded blocks.\n\n\n\n\n#\n\n\nType\n\n\nFindHeaders\n\n\n\n\n\nAn expander that tracks all header elements in a document. The data gathered by this expander is used in later stages to build cross-reference links and tables of contents.\n\n\n\n\n#\n\n\nType\n\n\nMetaBlock\n\n\n\n\n\nExpands markdown code blocks where the first line contains \n{meta}\n. The expander parses the contents of the block expecting key/value pairs such as\n\n\n{meta}\nCurrentModule = Lapidary\n\n\n\n\n\nNote that all syntax used in the block must be valid Julia syntax.\n\n\n\n\n#\n\n\nType\n\n\nMetaNode\n\n\n\n\n\nStores the parsed and evaluated key/value pairs found in a \n{meta}\n block.\n\n\n\n\n#\n\n\nType\n\n\nDocsBlock\n\n\n\n\n\nExpands code blocks where the first line contains \n{docs}\n. Subsequent lines should be names of objects whose documentation should be retrieved from the Julia docsystem.\n\n\n{docs}\nfoo\nbar(x, y)\nBaz.@baz\n\n\n\n\n\nEach object is evaluated in the \ncurrent_module()\n or \nCurrentModule\n if that has been set in a \n{meta}\n block of the current page prior to the \n{docs}\n block.\n\n\n\n\n#\n\n\nType\n\n\nDocsNode\n\n\n\n\n\nStores the object and related docstring for a single object found in a \n{docs}\n block. When a \n{docs}\n block contains multiple entries then each one is expanded into a separate \nDocsNode\n.\n\n\n\n\n#\n\n\nType\n\n\nIndexBlock\n\n\n\n\n\nExpands code blocks where the first line contains \n{index}\n. Subsequent lines can contain key/value pairs relevant to the index. Currently \nPages = [\"...\", ..., \"...\"]\n is supported for filtering the contents of the index based on source page.\n\n\nIndexes are used to display links to all the docstrings, generated with \n{docs}\n blocks, on any number of pages.\n\n\n\n\n#\n\n\nType\n\n\nIndexNode\n\n\n\n\n\n{index}\n code blocks are expanded into this object which is used to store the key/value pairs needed to build the actual index during the later rendering state.\n\n\n\n\n#\n\n\nType\n\n\nContentsBlock\n\n\n\n\n\nExpands code blocks where the first line contains \n{contents}\n. Subsequent lines can, like the \n{index}\n block, contains key/value pairs. Supported pairs are\n\n\nPages = [\n...\n, ..., \n...\n]\nDepth = 2\n\n\n\n\n\nwhere \nPages\n acts the same as for \n{index}\n and \nDepth\n limits the header level displayed in the generated contents.\n\n\nContents blocks are used to a display nested list of the headers found in one or more pages.\n\n\n\n\n#\n\n\nType\n\n\nContentsNode\n\n\n\n\n\n{contents}\n blocks are expanded into these objects, which, like with \nIndexNode\n, store the key/value pairs needed to render the contents during the later rendering stage.\n\n\n\n\n\n\nUtilities\n\n\n#\n\n\nFunction\n\n\ncar(x)\n\n\n\n\n\nHead element of the \nTuple\n \nx\n. See also \ncdr\n.\n\n\n\n\n#\n\n\nFunction\n\n\ncdr(x)\n\n\n\n\n\nTail elements of the \nTuple\n \nx\n. See also \ncar\n.\n\n\n\n\n#\n\n\nFunction\n\n\nassetsdir()\n\n\n\n\n\nDirectory containing Lapidary asset files.\n\n\n\n\n#\n\n\nFunction\n\n\ncurrentdir()\n\n\n\n\n\nReturns the current source directory. When \nisinteractive() \u2261 true\n then the present working directory, \npwd()\n is returned instead.\n\n\n\n\n#\n\n\nFunction\n\n\nwalk(f, meta, element)\n\n\n\n\n\nScan a document tree and run function \nf\n on each \nelement\n that is encountered.\n\n\n\n\n#\n\n\nFunction\n\n\nlog\n\n\n\n\n\nPrint a formatted message to \nSTDOUT\n. Each document \"stage\" type must provide an implementation of this function.\n\n\n\n\n#\n\n\nFunction\n\n\nprocess(env, stages...)\n\n\n\n\n\nFor each stage in \nstages\n execute stage with the given \nenv\n as it's argument.\n\n\n\n\n#\n\n\nFunction\n\n\nparseblock(code; skip = 0)\n\n\n\n\n\nReturns an array of (expression, string) tuples for each complete toplevel expression from \ncode\n. The \nskip\n keyword argument will drop the provided number of leading lines.\n\n\n\n\n#\n\n\nFunction\n\n\nnodocs(x)\n\n\n\n\n\nDoes the document returned from the docsystem contain any useful documentation.\n\n\n\n\n#\n\n\nFunction\n\n\ndoctest(source)\n\n\n\n\n\nTry to run the Julia source code found in \nsource\n.\n\n\n\n\n#\n\n\nFunction\n\n\nslugify(s)\n\n\n\n\n\nSlugify a string \ns\n by removing special characters. Used in the url generation process.", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#internal-documentation", 
            "text": "", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/lib/internals/#types", 
            "text": "#  Type  State  Used to store the current state of the markdown template expansion. This simplifies the  expand  methods by avoiding having to thread all the state between each call manually.   #  Type  Path  Represents a file mapping from source file  .src  to destination file  .dst .   #  Type  ParsedPath  Same as  Path , but also includes the parsed content of the markdown file.   #  Type  HeaderPath  Represents a file mapping from  .src  to  .dst  of a markdown header element. The  .nth  field tracks the ordering of the headers within the file.   #  Type  Env  Stores all the state associated with a document. An instance of this type is threaded through the sequence of transformations used to build the document.  Env(kwargs...)  Helper method used to simplidy the construction of  Env  objects. Takes any number of keyword arguments. Note that unknown keyword arguments are discarded by this method.", 
            "title": "Types"
        }, 
        {
            "location": "/lib/internals/#stages", 
            "text": "#  Type  SetupBuildDirectory  Cleans out previous  build  directory and rebuilds the folder structure to match that of the  src  directory. Copies all non-markdown files from  src  to  build .   #  Type  CopyAssetsDirectory  Copies the contents of the Lapidary  assets  folder to  build/assets .  Will throw an error if the directory already exists.   #  Type  ParseTemplates  Reads the contents of each markdown file found in  src  and them into  Markdown.MD  objects using  Markdown.parse .   #  Type  ExpandTemplates  Runs all the expanders stored in  .expanders  on each element of the parsed markdown files.   #  Type  RunDocTests  Finds all code blocks in an expanded document where the language is set to  julia  and tries to run them. Any failure will currently just terminate the entire document generation.  Notes  This stage can be disabled in  makedocs  by setting the keyword  doctest = false .   #  Type  CheckDocs  Consistency checks for the generated documentation. Have all the available docs from the specified modules been added to the external docs?   #  Type  CrossReferenceLinks  Finds all  Markdown.Link  elements in an expanded document and tries to find where the link should point to. Will terminate the entire document generation process when a link cannot successfully be found.   #  Type  RenderDocument  Write the contents of the expanded document tree to file. Currently only supports markdown output.", 
            "title": "Stages"
        }, 
        {
            "location": "/lib/internals/#expanders", 
            "text": "#  Function  expand  Expand a single element,  block , of a markdown file.   #  Type  DefaultExpander  By default block expansion just pushes the block onto the end of the vector of expanded blocks.   #  Type  FindHeaders  An expander that tracks all header elements in a document. The data gathered by this expander is used in later stages to build cross-reference links and tables of contents.   #  Type  MetaBlock  Expands markdown code blocks where the first line contains  {meta} . The expander parses the contents of the block expecting key/value pairs such as  {meta}\nCurrentModule = Lapidary  Note that all syntax used in the block must be valid Julia syntax.   #  Type  MetaNode  Stores the parsed and evaluated key/value pairs found in a  {meta}  block.   #  Type  DocsBlock  Expands code blocks where the first line contains  {docs} . Subsequent lines should be names of objects whose documentation should be retrieved from the Julia docsystem.  {docs}\nfoo\nbar(x, y)\nBaz.@baz  Each object is evaluated in the  current_module()  or  CurrentModule  if that has been set in a  {meta}  block of the current page prior to the  {docs}  block.   #  Type  DocsNode  Stores the object and related docstring for a single object found in a  {docs}  block. When a  {docs}  block contains multiple entries then each one is expanded into a separate  DocsNode .   #  Type  IndexBlock  Expands code blocks where the first line contains  {index} . Subsequent lines can contain key/value pairs relevant to the index. Currently  Pages = [\"...\", ..., \"...\"]  is supported for filtering the contents of the index based on source page.  Indexes are used to display links to all the docstrings, generated with  {docs}  blocks, on any number of pages.   #  Type  IndexNode  {index}  code blocks are expanded into this object which is used to store the key/value pairs needed to build the actual index during the later rendering state.   #  Type  ContentsBlock  Expands code blocks where the first line contains  {contents} . Subsequent lines can, like the  {index}  block, contains key/value pairs. Supported pairs are  Pages = [ ... , ...,  ... ]\nDepth = 2  where  Pages  acts the same as for  {index}  and  Depth  limits the header level displayed in the generated contents.  Contents blocks are used to a display nested list of the headers found in one or more pages.   #  Type  ContentsNode  {contents}  blocks are expanded into these objects, which, like with  IndexNode , store the key/value pairs needed to render the contents during the later rendering stage.", 
            "title": "Expanders"
        }, 
        {
            "location": "/lib/internals/#utilities", 
            "text": "#  Function  car(x)  Head element of the  Tuple   x . See also  cdr .   #  Function  cdr(x)  Tail elements of the  Tuple   x . See also  car .   #  Function  assetsdir()  Directory containing Lapidary asset files.   #  Function  currentdir()  Returns the current source directory. When  isinteractive() \u2261 true  then the present working directory,  pwd()  is returned instead.   #  Function  walk(f, meta, element)  Scan a document tree and run function  f  on each  element  that is encountered.   #  Function  log  Print a formatted message to  STDOUT . Each document \"stage\" type must provide an implementation of this function.   #  Function  process(env, stages...)  For each stage in  stages  execute stage with the given  env  as it's argument.   #  Function  parseblock(code; skip = 0)  Returns an array of (expression, string) tuples for each complete toplevel expression from  code . The  skip  keyword argument will drop the provided number of leading lines.   #  Function  nodocs(x)  Does the document returned from the docsystem contain any useful documentation.   #  Function  doctest(source)  Try to run the Julia source code found in  source .   #  Function  slugify(s)  Slugify a string  s  by removing special characters. Used in the url generation process.", 
            "title": "Utilities"
        }
    ]
}