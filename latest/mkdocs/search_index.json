{
    "docs": [
        {
            "location": "/", 
            "text": "Documenter.jl\n\n\nA documentation generator for Julia.\n\n\nA package for building documentation from docstrings and markdown files.\n\n\n\n\nPackage Features\n\n\n\n\nMinimal configuration.\n\n\nSupports Julia \n0.4\n and \n0.5-dev\n.\n\n\nDoctests Julia code blocks.\n\n\nCross references for docs and section headers.\n\n\nChecks for missing docstrings and incorrect cross references.\n\n\nGenerates tables of contents and docstring indexes.\n\n\nUse \ngit push\n to automatically build and deploy docs from Travis to GitHub Pages.\n\n\n\n\nThe \nPackage Guide\n provides a tutorial explaining how to get started using Documenter.\n\n\nSome examples of packages using Documenter can be found on the \nExamples\n page.\n\n\nSee the \nIndex\n for the complete list of documented functions and types.\n\n\n\n\nManual Outline\n\n\n\n\nPackage Guide\n\n\nInstallation\n\n\nUsage\n\n\n\n\n\n\nExamples\n\n\nRegistered\n\n\nUnregistered\n\n\n\n\n\n\nSyntax\n\n\n{docs}\n\n\n{autodocs}\n\n\n{ref}\n\n\n{meta}\n\n\n{index}\n\n\n{contents}\n\n\n{example}\n\n\n{repl}\n\n\n{eval}\n\n\n\n\n\n\nDoctests\n\n\n\"Script\" Examples\n\n\nREPL Examples\n\n\nSkipping Doctests\n\n\nSetup Code\n\n\n\n\n\n\nHosting Documentation\n\n\nOverview\n\n\nGitHub Security Key\n\n\nTravis Environment Settings\n\n\n.travis.yml\n Configuration\n\n\nThe \ndeploydocs\n Function\n\n\nThe MkDocs \nmkdocs.yml\n File\n\n\n.gitignore\n\n\ngh-pages\n Branch\n\n\nDocumentation Versions\n\n\n\n\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nDocumenter\n\n\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\nAnchors\n\n\nBuilder\n\n\nCrossReferences\n\n\nDocChecks\n\n\nDocuments\n\n\nExpanders\n\n\nFormats\n\n\nWalkers\n\n\nWriters\n\n\nUtilities\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDocumenter\n\n\nDocumenter.Deps\n\n\nDocumenter.Deps.pip\n\n\nDocumenter.deploydocs\n\n\nDocumenter.makedocs\n\n\nDocumenter.Anchors\n\n\nDocumenter.Anchors.Anchor\n\n\nDocumenter.Anchors.AnchorMap\n\n\nDocumenter.Anchors.add!\n\n\nDocumenter.Anchors.anchor\n\n\nDocumenter.Anchors.exists\n\n\nDocumenter.Anchors.isunique\n\n\nDocumenter.Builder\n\n\nDocumenter.Builder.CheckDocument\n\n\nDocumenter.Builder.ContentsBlocks\n\n\nDocumenter.Builder.CopyAssetsDirectory\n\n\nDocumenter.Builder.CrossReferences\n\n\nDocumenter.Builder.DocsBlocks\n\n\nDocumenter.Builder.EvalBlocks\n\n\nDocumenter.Builder.ExpandTemplates\n\n\nDocumenter.Builder.IndexBlocks\n\n\nDocumenter.Builder.MetaBlocks\n\n\nDocumenter.Builder.RenderDocument\n\n\nDocumenter.Builder.SetupBuildDirectory\n\n\nDocumenter.Builder.TrackHeaders\n\n\nDocumenter.CrossReferences\n\n\nDocumenter.CrossReferences.crossref\n\n\nDocumenter.DocChecks\n\n\nDocumenter.DocChecks.doctest\n\n\nDocumenter.DocChecks.missingdocs\n\n\nDocumenter.Documents\n\n\nDocumenter.Documents.Document\n\n\nDocumenter.Documents.Globals\n\n\nDocumenter.Documents.Internal\n\n\nDocumenter.Documents.Page\n\n\nDocumenter.Documents.User\n\n\nDocumenter.Expanders\n\n\nDocumenter.Expanders.expand\n\n\nDocumenter.Formats\n\n\nDocumenter.Formats.Format\n\n\nDocumenter.Formats.mimetype\n\n\nDocumenter.Utilities\n\n\nDocumenter.Utilities.Object\n\n\nDocumenter.Utilities.assetsdir\n\n\nDocumenter.Utilities.check_kwargs\n\n\nDocumenter.Utilities.currentdir\n\n\nDocumenter.Utilities.doccat\n\n\nDocumenter.Utilities.docs\n\n\nDocumenter.Utilities.filterdocs\n\n\nDocumenter.Utilities.log\n\n\nDocumenter.Utilities.logging\n\n\nDocumenter.Utilities.nodocs\n\n\nDocumenter.Utilities.object\n\n\nDocumenter.Utilities.parseblock\n\n\nDocumenter.Utilities.slugify\n\n\nDocumenter.Utilities.submodules\n\n\nDocumenter.Utilities.warn\n\n\nDocumenter.Walkers\n\n\nDocumenter.Walkers.walk\n\n\nDocumenter.Writers\n\n\nDocumenter.Writers.render", 
            "title": "Home"
        }, 
        {
            "location": "/man/guide/", 
            "text": "Package Guide\n\n\n\n\nInstallation\n\n\nDocumenter is currently not registered and so must be installed via \nPkg.clone\n.\n\n\nPkg\n.\nclone\n(\nhttps://github.com/MichaelHatherly/Documenter.jl\n)\n\n\n\n\n\n\nThis package supports Julia \n0.4\n and \n0.5\n.\n\n\n\n\nUsage\n\n\nDocumenter is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.\n\n\n\n\nSetting up the folder structure\n\n\nFirstly, we need a Julia module to document. This could be a package generated via \nPkgDev.generate\n or a single \n.jl\n script. For this guide we'll be using a package called \nExample.jl\n that has the following directory layout:\n\n\nExample/\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nNote that the \n...\n just represent unimportant files and folders.\n\n\nWe must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named \ndocs/\n in the toplevel of the package, like so\n\n\nExample/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nInside the \ndocs/\n folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended\n\n\ndocs/\n    src/\n    make.jl\n\n\n\n\n\n\n\nBuilding an empty document\n\n\nWith our \ndocs/\n directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.\n\n\nAdd the following to your \nmake.jl\n file\n\n\nusing\n \nDocumenter\n,\n \nExample\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nThis assumes you've installed Documenter as discussed in \nInstallation\n and that your Examples package can be found by Julia.\n\n\nNow add an \nindex.md\n file to the \nsrc/\n directory. The name has no particular significance though and you may name it whatever you like. We'll stick to \nindex.md\n for this guide.\n\n\nLeave the newly added file empty and the run the following command from the \ndocs/\n directory\n\n\n$ julia make.jl\n\n\n\n\n\nNote that \n$\n just represents the prompt character. You don't need to type that.\n\n\nIf you'd like to see the output from this command in color use\n\n\n$ julia --color\n=\nyes make.jl\n\n\n\n\n\nWe you run that you should see the following output\n\n\nDocumenter\n:\n \nsetting\n \nup\n \nbuild\n \ndirectory\n.\n\n\nDocumenter\n:\n \ncopying\n \nassets\n \nto\n \nbuild\n \ndirectory\n.\n\n\nDocumenter\n:\n \nexpanding\n \nmarkdown\n \ntemplates\n.\n\n\nDocumenter\n:\n \nbuilding\n \ncross\n-\nreferences\n.\n\n\nDocumenter\n:\n \nrunning\n \ndocument\n \nchecks\n.\n\n\nDocumenter\n:\n \nrendering\n \ndocument\n.\n\n\n\n\n\n\nThe \ndocs/\n folder should contain a new directory \u2013 called \nbuild/\n. It's structure should look like the following\n\n\nbuild/\n    assets/\n        Documenter.css\n        mathjaxhelper.js\n    index.md\n\n\n\n\n\nAt the moment \nbuild/index.md\n should be empty since \nsrc/index.md\n is empty.\n\n\nAt this point you can add some text to \nsrc/index.md\n and rerun the \nmake.jl\n file to see the changes if you'd like to.\n\n\n\n\nAdding some docstrings\n\n\nNext we'll splice a docstring defined in the \nExample\n module into the \nindex.md\n file. To do this first document a function in that module:\n\n\nmodule\n \nExample\n\n\n\nexport\n \nfunc\n\n\n\n\n\n    func(x)\n\n\n\nReturns double the number `x` plus `1`.\n\n\n\n\nfunc\n(\nx\n)\n \n=\n \n2\nx\n \n+\n \n1\n\n\n\nend\n\n\n\n\n\n\nThen in the \nsrc/index.md\n file add the following\n\n\n# Example.jl Documentation\n\n    {docs}\n    func(x)\n\n\n\n\n\nWhen we next run \nmake.jl\n the docstring for \nExample.func(x)\n should appear in place of the \n{docs}\n block in \nbuild/index.md\n. Note that \nmore than one\n object can be referenced inside a \n{docs}\n block \u2013 just place each one on a separate line.\n\n\nNote that the module in which a \n{docs}\n block is evaluated is determined by \ncurrent_module()\n and so will more than likely be \nMain\n. This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a \n{meta}\n block as in the following\n\n\n# Example.jl Documentation\n\n    {meta}\n    CurrentModule = Documenter\n\n...\n\n    {docs}\n    func(x)\n\n\n\n\n\nNote that the \n...\n in the example above is just there to stop the code blocks from merging into a single block. You could use fenced code blocks instead to avoid needing to have to break up the blocks using extra text.\n\n\n\n\nFiltering Included Docstrings\n\n\nIn some cases you may want to include a docstring for a \nMethod\n that extends a \nFunction\n from a different module \u2013 such as \nBase\n. In the following example we extend \nBase.length\n with a new definition for type \nT\n and also add a docstring:\n\n\ntype\n T\n\n    \n# ...\n\n\nend\n\n\n\n\n\nCustom `length` docs for `T`.\n\n\n\n\nBase\n.\nlength\n(::\nT\n)\n \n=\n \n1\n\n\n\n\n\n\nWhen trying to include this docstring with\n\n\n    {docs}\n    length\n\n\n\n\n\nall the docs for \nlength\n will be included \u2013 even those from other modules. There are two ways to solve this problem. Either include the type in the signature with\n\n\n    {docs}\n    length(::T)\n\n\n\n\n\nor declare the specific modules that \nmakedocs\n should include with\n\n\nmakedocs\n(\n\n    \n# options\n\n    \nmodules\n \n=\n \n[\nMyModule\n]\n\n\n)\n\n\n\n\n\n\n\n\nCross Referencing\n\n\nIt may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Documenter's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of \nsrc/index.md\n with the following\n\n\n# Example.jl Documentation\n\n    {docs}\n    func(x)\n\n- link to [Example.jl Documentation]({ref})\n- link to [`func(x)`]({ref})\n\n\n\n\n\nSo we just have to replace each link's url with \n{ref}\n and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.\n\n\nThis also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.\n\n\n\n\nNavigation\n\n\nDocumenter can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our \nindex.md\n file from the previous sections. Add the following to that file\n\n\n# Example.jl Documentation\n\n    {contents}\n\n## Functions\n\n    {docs}\n    func(x)\n\n## Index\n\n    {index}\n\n\n\n\n\nThe \n{contents}\n block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using \nPages\n and \nDepth\n settings as in the following\n\n\n    {contents}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n    Depth = 3\n\n\n\n\n\nThe \n{index}\n block will generate a flat list of links to all the docs that that have been spliced into the document using \n{docs}\n blocks. As with the \n{contents}\n block the pages to be included can be set with a \nPages = [...]\n line. Since the list is not nested \nDepth\n is not supported for \n{index}\n.", 
            "title": "Guide"
        }, 
        {
            "location": "/man/examples/", 
            "text": "Examples\n\n\nSometimes the best way to learn how to use a new package is to look for examples of what others have already built with it.\n\n\nThe following packages use Documenter to build their documentation and so should give a good overview of what this package is currently able to do.\n\n\n\n\nNote\n\n\nPackages are listed alphabetically. If you have a package that uses Documenter then please open a PR that adds it to the appropriate list below.\n\n\nThe \nmake.jl\n file for all listed packages will be tested to check for potential regressions prior to tagging new Documenter releases whenever possible.\n\n\n\n\n\n\nRegistered\n\n\nPackages that have tagged versions available in \nMETADATA.jl\n.\n\n\n\n\nControlSystems.jl\n\n\nMergedMethods.jl\n\n\nNumericSuffixes.jl\n\n\nPrivateModules.jl\n\n\nWeave.jl\n\n\n\n\n\n\nUnregistered\n\n\nPackages that are not available in \nMETADATA.jl\n and may be works-in-progress. Please do take that into consideration when browsing this list.\n\n\n\n\nAnonymousTypes.jl\n\n\nDocumenter.jl", 
            "title": "Examples"
        }, 
        {
            "location": "/man/syntax/", 
            "text": "Syntax\n\n\nThis section of the manual describes the syntax used by Documenter to build documentation.\n\n\n\n\nSyntax\n\n\n{docs}\n\n\n{autodocs}\n\n\n{ref}\n\n\n{meta}\n\n\n{index}\n\n\n{contents}\n\n\n{example}\n\n\n{repl}\n\n\n{eval}\n\n\n\n\n\n\n\n\n\n\n{docs}\n\n\nSplice one or more docstrings into a document in place of the code block, i.e.\n\n\n    {docs}\n    Documenter\n    makedocs\n    deploydocs\n\n\n\n\n\nThis block type is evaluated within the \nCurrentModule\n module if defined, otherwise within \ncurrent_module()\n, and so each object listed in the block should be visible from that module. Undefined objects will raise warnings during documentation generation and cause the code block to be rendered in the final document unchanged.\n\n\nObjects may not be listed more than once within the document. When duplicate objects are detected an error will be raised and the build process will be terminated.\n\n\nTo ensure that all docstrings from a module are included in the final document the \nmodules\n keyword for \nmakedocs\n can be set to the desired module or modules, i.e.\n\n\nmakedocs\n(\n\n    \nmodules\n \n=\n \n[\nLapidary\n],\n\n\n)\n\n\n\n\n\n\nwhich will cause any unlisted docstrings to raise warnings when \nmakedocs\n is called. If \nmodules\n is not defined then no warnings are printed, even if a document has missing docstrings.\n\n\n\n\n{autodocs}\n\n\nAutomatically splices all docstrings from the provided modules in place of the code block. This is equivalent to manually adding all the docstrings in a \n{docs}\n block.\n\n\n```\n\n\n{\nautodocs\n}\n\n\nModules\n \n=\n \n[\nFoo\n,\n \nBar\n]\n\n\nOrder\n   \n=\n \n[\n:\nfunction\n,\n \n:\ntype\n]\n\n\n```\n\n\n\n\n\n\nThe above \n{autodocs}\n block adds all the docstrings found in modules \nFoo\n and \nBar\n that refer to functions or types to the document.\n\n\nEach module is added in order and so all docs from \nFoo\n will appear before those of \nBar\n. Possible values for the \nOrder\n vector are\n\n\n\n\n:module\n\n\n:constant\n\n\n:type\n\n\n:function\n\n\n:macro\n\n\n\n\nIf no \nOrder\n is provided then the order listed above is used.\n\n\nWhen a potential docstring is found in one of the listed modules, but does not match any value from \nOrder\n then it will be omitted from the document. Hence \nOrder\n acts as a basic filter as well as sorter.\n\n\nNote\n\n\nWhen more complex sorting and filtering is needed then use \n{docs}\n to define it explicitly.\n\n\n\n\n{ref}\n\n\nUsed in markdown links as the URL to tell Documenter to generate a cross-reference automatically. The text part of the link can be either a docstring or header name.\n\n\n# Syntax\n\n... [`makedocs`]({ref}) ...\n\n# Functions\n\n    {docs}\n    makedocs\n\n... [Syntax]({ref}) ...\n\n\n\n\n\nPlain text in the \"text\" part of a link will cross-reference a header, while text in backticks will cross-reference a docstring from a \n{docs}\n block. The text should match the name of the header exactly.\n\n\n{ref}\ns may refer to docstrings or headers on different pages as well as the current page using the same syntax.\n\n\nNote that depending on what the \nCurrentModule\n is set to, a docstring \n{ref}\n may need to be prefixed by the module which defines it.\n\n\nDuplicate Headers\n\n\nIn some cases a document may contain multiple headers with the same name, but on different pages or of different levels. To allow \n{ref}\n to cross-reference a duplicate header it must be given a name as in the following example\n\n\n# [Header]({ref#my-custom-header-name})\n\n\n\n...\n\n\n\n## Header\n\n\n\n...\n \n[\nCustom\n \nHeader\n]({\nref\n#\nmy\n-\ncustom\n-\nheader\n-\nname\n})\n \n...\n\n\n\n\n\n\nThe link that wraps the named header is removed in the final document. The text for a named \n{ref#...}\n does not need to match the header that it references. Named \n{ref#...}\ns may refer to headers on different pages in the same way as unnamed ones do.\n\n\nDuplicate docstring references do not occur since splicing the same docstring into a document more than once is disallowed.\n\n\n\n\n{meta}\n\n\nThis block type is used to define metadata key/value pairs that can be used elsewhere in the page. Currently \nCurrentModule\n and \nDocTestSetup\n are the only recognised keys.\n\n\n    {meta}\n    CurrentModule = FooBar\n    DocTestSetup  = quote\n        using MyPackage\n    end\n\n\n\n\n\nNote that \n{meta}\n blocks are always evaluated with the \ncurrent_module()\n, which is typically \nMain\n.\n\n\nSee \nSetup Code\n section of the Doctests page for an explanation of \nDocTestSetup\n.\n\n\n\n\n{index}\n\n\nGenerates a list of links to docstrings that have been spliced into a document. The only valid setting is currently \nPages = ...\n.\n\n\n    {index}\n    Pages = [\nfoo.md\n]\n\n\n\n\n\nWhen \nPages\n is not provided all pages in the document are included.\n\n\nNote that the \nPages\n value can be any valid Julia code and so can be something more complex that an array literal if a large number of pages must be included, i.e.\n\n\n    {index}\n    Pages = map(file -\n joinpath(\nman\n, file), readdir(\nman\n))\n\n\n\n\n\nIt should be noted though that in this case \nPages\n may not be sorted in the order that is expected by the user. Try to stick to array literals for \nPages\n as much as possible.\n\n\n\n\n{contents}\n\n\nGenerates a nested list of links to document sections. Valid settings are \nPages\n and \nDepth\n.\n\n\n    {contents}\n    Pages = [\nfoo.md\n]\n    Depth = 5\n\n\n\n\n\nAs with \n{index}\n if \nPages\n is not provided then all pages are included. The default \nDepth\n value is \n2\n.\n\n\n\n\n{example}\n\n\nEvaluates the code block and inserts the result into the final document along with the original source code.\n\n\n    {example}\n    a = 1\n    b = 2\n    a + b\n\n\n\n\n\nThe above \n{example}\n block will splice the following into the final document\n\n\n```julia\na = 1\nb = 2\na + b\n```\n\n```\n3\n```\n\n\n\n\n\nLeading and trailing newlines are removed from the rendered code blocks. Trailing whitespace on each line is also removed.\n\n\nHiding Source Code\n\n\nCode blocks may have some content that does not need to be displayed in the final document. \n# hide\n comments can be appended to lines that should not be rendered, i.e.\n\n\n```julia\n{example}\nsrand(1) # hide\nA = rand(3, 3)\nb = [1, 2, 3]\nA \\ b\n```\n\n\n\n\n\nNote that appending \n# hide\n to every line in an \n{example}\n block will result in the block being hidden in the rendered document. The results block will still be rendered though.\n\n\nSTDOUT\n and \nSTDERR\n\n\nThe Julia output streams are redirected to the results block when evaluating \n{example}\n blocks in the same way as when running doctest code blocks.\n\n\nnothing\n Results\n\n\nWhen the \n{example}\n block evaluates to \nnothing\n then the second block is not displayed. Only the source code block will be shown in the rendered document. Note that if any output from either \nSTDOUT\n or \nSTDERR\n is captured then the results block will be displayed even if \nnothing\n is returned.\n\n\nNamed \n{example}\n Blocks\n\n\nBy default \n{example}\n blocks are run in their own anonymous \nModule\ns to avoid side-effects between blocks. To share the same module between different blocks on a page the \n{example}\n can be named with the following syntax\n\n\n```julia\n{example 1}\na = 1\n```\n\n```julia\n{example 1}\nprintln(a)\n```\n\n\n\n\n\nThe name can be any text, not just integers as in the example above, i.e. \n{example foo}\n.\n\n\nNamed \n{example}\n blocks can be useful when generating documentation that requires intermediate explanation or multimedia such as plots as illustrated in the following example\n\n\nFirst we define some functions\n\n```julia\n{example 1}\nusing PyPlot # hide\nf(x) = sin(2x) + 1\ng(x) = cos(x) - x\n```\n\nand then we plot `f` over the interval from ``-\u03c0`` to ``\u03c0``\n\n```julia\n{example 1}\nx = linspace(-\u03c0, \u03c0)\nplot(x, f(x), color = \nred\n)\nsavefig(\nf-plot.svg\n); nothing # hide\n```\n\n![](f-plot.svg)\n\nand then we do the same with `g`\n\n```julia\n{example 1}\nplot(x, g(x), color = \nblue\n)\nsavefig(\ng-plot.svg\n); nothing # hide\n```\n\n![](g-plot.svg)\n\n\n\n\n\nNote that \n{example}\n blocks are evaluated within the directory of \nbuild\n where the file will be rendered . This means than in the above example \nsavefig\n will output the \n.svg\n files into that directory. This allows the images to be easily referenced without needing to worry about relative paths.\n\n\n{example}\n blocks automatically define \nans\n which, as in the Julia REPL, is bound to the value of the last evaluated expression. This can be useful in situations such as the following one where where binding the object returned by \nplot\n to a named variable would look out of place in the final rendered documentation:\n\n\n```julia\n{example}\nusing Gadfly # hide\nplot([sin, x -\n 2sin(x) + x], -2\u03c0, 2\u03c0)\ndraw(SVG(\nplot.svg\n, 6inch, 4inch), ans); nothing # hide\n```\n\n![](plot.svg)\n\n\n\n\n\n\n\n{repl}\n\n\nThese are similar to \n{example}\n blocks, but adds a \njulia\n prompt before each toplevel expression. \n;\n and \n# hide\n syntax may be used in \n{repl}\n blocks in the same way as in the Julia REPL and \n{example}\n blocks.\n\n\n```julia\n{repl}\na = 1\nb = 2\na + b\n```\n\n\n\n\n\nwill generate\n\n\n```julia\njulia\n a = 1\n1\n\njulia\n b = 2\n2\n\njulia\n a + b\n3\n```\n\n\n\n\n\nNamed \n{repl \nname\n}\n blocks behave in the same way as named \n{example \nname\n}\n blocks.\n\n\n\n\n{eval}\n\n\nEvaluates the contents of the block and inserts the resulting value into the final document.\n\n\nIn the following example we use the PyPlot package to generate a plot and display it in the final document.\n\n\n    {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color = \nred\n)\n    savefig(\nplot.svg\n)\n\n    nothing\n\n![](plot.svg)\n\n\n\n\n\nNote that each \n{eval}\n block evaluates its contents within a separate module. When evaluating each block the present working directory, \npwd\n, is set to the directory in \nbuild\n where the file will be written to.\n\n\nAlso, instead of returning \nnothing\n in the example above we could have returned a new \nMarkdown.Image\n object directly. This can be more appropriate when the filename is not known until evaluation of the block itself.\n\n\nNote\n\n\nIn most cases \n{example}\n is preferred over \n{eval}\n. Just like in normal Julia code where \neval\n should be only be considered as a last resort, \n{eval}\n should be treated in the same way.", 
            "title": "Syntax"
        }, 
        {
            "location": "/man/doctests/", 
            "text": "Doctests\n\n\nDocumenter will, by default, try to run Julia code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Documenter's doctest.\n\n\nThis section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.\n\n\n\n\n\"Script\" Examples\n\n\nThe first, of two, types of doctests is the \"script\" code block. To make Documenter detect this kind of code block the following format must be used:\n\n\n```julia\na = 1\nb = 2\na + b\n\n# output\n\n3\n```\n\n\n\n\n\nThe code block's \"language\" must be \njulia\n and must include a line containing the text \n# output\n. The text before this line is the contents of the script which is run. The text that appears after \n# output\n is the textual representation that would be shown in the Julia REPL if the script had been \ninclude\nd.\n\n\nThe actual output produced by running the \"script\" is compared to the expected result and any difference will result in \nmakedocs\n throwing an error and terminating.\n\n\nNote that the amount of whitespace appearing above and below the \n# output\n line is not significant and can be increased or decreased if desired.\n\n\n\n\nREPL Examples\n\n\nThe other kind of doctest is a simulated Julia REPL session. The following format is detected by Documenter as a REPL doctest:\n\n\n```julia\njulia\n a = 1\n1\n\njulia\n b = 2;\n\njulia\n c = 3;  # comment\n\njulia\n a + b + c\n6\n\n```\n\n\n\n\n\nAs with script doctests, the code block must have it's language set to \njulia\n. When a code block contains one or more \njulia\n at the start of a line then it is assumed to be a REPL doctest. Semi-colons, \n;\n, at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.\n\n\nNote that not all features of the REPL are supported such as shell and help modes.\n\n\n\n\nSkipping Doctests\n\n\nDoctesting can be disabled by setting the \nmakedocs\n keyword \ndoctest = false\n. This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.\n\n\n\n\nSetup Code\n\n\nDoctests may require some setup code that must be evaluated prior to that of the actual example, but that should not be displayed in the final documentation. It could also be that several separate doctests require the same definitions. For both of these cases a \n{meta}\n block containing a \nDocTestSetup = ...\n value can be used as follows:\n\n\n```\njulia\n\n\njulia\n \nusing\n \nDataFrames\n\n\n\njulia\n \ndf\n \n=\n \nDataFrame\n(\nA\n \n=\n \n1\n:10\n,\n \nB\n \n=\n \n2\n:2:20\n);\n\n\n\n```\n\n\n\nSome\n \ntext\n \ndiscussing\n \n`\ndf\n`\n...\n\n\n    \n{\nmeta\n}\n\n    \nDocTestSetup\n \n=\n \nquote\n\n        \nusing\n \nDataFrames\n\n        \ndf\n \n=\n \nDataFrame\n(\nA\n \n=\n \n1\n:10\n,\n \nB\n \n=\n \n2\n:2:20\n)\n\n    \nend\n\n\n\n```\njulia\n\n\njulia\n \ndf\n[\n1\n,\n \n1\n]\n\n\n1\n\n\n```\n\n\n\nSome\n \nmore\n \ntext\n...\n\n\n\n```\njulia\n\n\njulia\n \ndf\n[\n1\n,\n \n:\n]\n\n\n1x2\n \nDataFrames\n.DataFrame\n\n\n|\n \nRow\n \n|\n \nA\n \n|\n \nB\n \n|\n\n\n|\n-----\n|\n---\n|\n---\n|\n\n\n|\n \n1\n   \n|\n \n1\n \n|\n \n2\n \n|\n\n\n```\n\n\n    \n{\nmeta\n}\n\n    \nDocTestSetup\n \n=\n \nnothing\n\n\n\n\n\n\nNote that the \nDocTestSetup\n value is \nre-evaluated\n at the start of \neach\n doctest block and no state is shared between any code blocks. The \nDocTestSetup = nothing\n is not strictly necessary, but good practice nonetheless to help avoid unintentional definitions later on a page.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/hosting/", 
            "text": "Hosting Documentation\n\n\nAfter going through the \nPackage Guide\n and \nDoctests\n page you will need to host the generated documentation somewhere for potential users to read. This guide will describe how to setup automatic updates for your package docs using the Travis build service and GitHub Pages. This is the same approach used by this package to host it's own docs \u2013 the docs you're currently reading.\n\n\n\n\nNotes\n\n\nFollowing this guide should be the \nfinal\n step you take after you are comfortable with the syntax and build process used by \nDocumenter.jl\n. Only proceed with the steps outlined on this page once you have successfully used \nmkdocs\n locally to build your documentation. \nmkdocs\n can typically be installed using \npip install mkdocs\n in your terminal.\n\n\nThis guide assumes that you already have GitHub and Travis accounts setup. If not then go set those up first and then return here.\n\n\n\n\n\n\nOverview\n\n\nOnce setup correctly the following will happen each time you push new updates to your package repository:\n\n\n\n\ntravis buildbots startup and run your tests;\n\n\neach buildbot will build the package docs using your \ndocs/make.jl\n script;\n\n\na single buildbot will then try to push the generated docs back the github.\n\n\n\n\nThe following sections outline how to enable this for your own package.\n\n\n\n\nGitHub Security Key\n\n\nFirstly, generate a new \npersonal access token\n.\n\n\nEnter a description for this new token. We'll be calling ours \"Travis\", but any other name will do. For the \"Select scopes\" option choose \"public_repo\" \nonly\n. Then generate the token and save it somewhere safe. We'll be needing it during the next section.\n\n\n\n\nTravis Environment Settings\n\n\nNext we'll add the generated token to our repository's Travis page. Go to the settings page for the repository and under the \"Environment Variables\" section add a new variable called \nGITHUB_API_KEY\n. Copy the generated key from the \nGitHub Security Key\n section as the value and \nmake sure\n that \"Display value in build log\" is \noff\n. Be careful to remove any leading white-space from the key. Then add the key.\n\n\n\n\n.travis.yml\n Configuration\n\n\nIn the \nafter_success\n section of the \n.travis.yml\n file, where code coverage is processed, run your \ndocs/make.jl\n file:\n\n\nafter_success\n:\n\n  \n-\n \njulia -e \nPkg.clone(\nhttps://github.com/MichaelHatherly/Documenter.jl\n)\n\n  \n-\n \njulia -e \ncd(Pkg.dir(\nPACKAGE_NAME\n)); include(joinpath(\ndocs\n, \nmake.jl\n))\n\n\n\n\n\n\nNote that once the package is registered in \nMETADATA.jl\n the \nPkg.clone\n call can be replaced with \nPkg.add(\"Documenter\")\n.\n\n\n\n\nThe \ndeploydocs\n Function\n\n\nAt the moment your \ndocs/make.jl\n file probably only contains\n\n\nusing\n \nDocumenter\n,\n \nPACKAGE_NAME\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nWe'll need to add an additional call to this file after \nmakedocs\n. Add the following at the end of the file:\n\n\ndeploydocs\n(\n\n    \nrepo\n \n=\n \ngithub.com/USER_NAME/PACKAGE_NAME.jl.git\n\n\n)\n\n\n\n\n\n\nwhere \nUSER_NAME\n and \nPACKAGE_NAME\n must be set to the appropriate names.\n\n\nBy default \ndeploydocs\n will deploy the documentation from the \nnightly\n Julia build for Linux. This can be changed using the \njulia\n and \nosname\n keywords as follows:\n\n\ndeploydocs\n(\n\n    \ndeps\n   \n=\n \nDeps\n.\npip\n(\nmkdocs\n,\n \npython-markdown-math\n),\n\n    \nrepo\n   \n=\n \ngithub.com/USER_NAME/PACKAGE_NAME.jl.git\n,\n\n    \njulia\n  \n=\n \n0.4\n,\n\n    \nosname\n \n=\n \nosx\n\n\n)\n\n\n\n\n\n\nThis will deploy the docs from the OSX Julia 0.4 Travis build bot.\n\n\nThe keyword \ndeps\n serves to provide the required dependencies to deploy the documentation. In the example above we include the dependencies \nmkdocs\n and \npython-markdown-math\n. The former makes sure that MkDocs is installed to deploy the documentation, and the latter provides the \nmdx_math\n markdown extension to exploit MathJax rendering of latex equations in markdown. Other dependencies should be included here.\n\n\nSee the \ndeploydocs\n function documentation for more details.\n\n\n\n\nThe MkDocs \nmkdocs.yml\n File\n\n\nWe'll be using \nMkDocs\n to convert the markdown files generated by Documenter to HTML. (This, of course, is not the only option you have for this step. Any markdown to HTML converter should work fine with some amount of setting up.)\n\n\nAdd an \nmkdocs.yml\n file to your \ndocs/\n directory with the following content:\n\n\nsite_name\n:\n        \nPACKAGE_NAME.jl\n\n\nrepo_url\n:\n         \nhttps://github.com/USER_NAME/PACKAGE_NAME.jl\n\n\nsite_description\n:\n \nDescription...\n\n\nsite_author\n:\n      \nUSER_NAME\n\n\n\ntheme\n:\n \nreadthedocs\n\n\n\nextra_css\n:\n\n  \n-\n \nassets/Documenter.css\n\n\n\nextra_javascript\n:\n\n  \n-\n \nhttps://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\n\n  \n-\n \nassets/mathjaxhelper.js\n\n\n\nmarkdown_extensions\n:\n\n  \n-\n \nextra\n\n  \n-\n \ntables\n\n  \n-\n \nfenced_code\n\n  \n-\n \nmdx_math\n\n\n\ndocs_dir\n:\n \nbuild\n\n\n\npages\n:\n\n  \n-\n \nHome\n:\n \nindex.md\n\n\n\n\n\n\nThis is only a basic skeleton. Read through the MkDocs documentation if you would like to know more about the available settings.\n\n\n\n\n.gitignore\n\n\nAdd the following to your package's \n.gitignore\n file\n\n\ndocs/build/\ndocs/site/\n\n\n\n\n\nThese are needed to avoid committing generated content to your repository.\n\n\n\n\ngh-pages\n Branch\n\n\nCreate a new branch called \ngh-pages\n and push it to GitHub. If this branch already exists then you can skip this step, but do note that the generated content is automatically pushed to this branch from Travis.\n\n\n\n\nDocumentation Versions\n\n\nWhen documentation is generated it is stored in one of the following folders:\n\n\n\n\n\n\nlatest\n stores the most recent documentation that is committed to the \nmaster\n branch.\n\n\n\n\n\n\nstable\n stores the most recent documentation from a tagged commit. Older tagged versions   are stored in directories named after their tags. These tagged directories are persistent   and must be manually removed from the \ngh-pages\n branch if necessary.\n\n\n\n\n\n\nOnce your documentation has been pushed to the \ngh-pages\n branch you should add links to your \nREADME.md\n pointing to the \nstable\n and \nlatest\n documentation URLs. It is common practice to make use of \"badges\" similar to those used for Travis and AppVeyor build statuses or code coverage. Adding the following to your package \nREADME.md\n should be all that is necessary:\n\n\n[![](https://img.shields.io/badge/docs-stable-blue.svg)](https://USER_NAME.github.io/PACKAGE_NAME.jl/stable)\n[![](https://img.shields.io/badge/docs-latest-blue.svg)](https://USER_NAME.github.io/PACKAGE_NAME.jl/latest)\n\n\n\n\n\nPACKAGE_NAME\n and \nUSER_NAME\n should be replaced with their appropriate values. The colour and text of the image can be changed by altering \ndocs-stable-blue\n as described on \nshields.io\n, though it is recommended that package authors follow this standard to make it easier for potential users to find documentation links across multiple package README files.\n\n\n\n\nFinal Remarks\n\n\nThat should be all that is needed to enable automatic documentation building. Pushing new commits to your \nmaster\n branch should trigger doc builds. Note that other branches do not trigger these builds and neither do pull requests by potential contributors.\n\n\nIf you would like to see a more complete example of how this process is setup then take a look at this package's repository for some inspiration.", 
            "title": "Hosting Documentation"
        }, 
        {
            "location": "/man/internals/", 
            "text": "Package Internals", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\nDocumentation for \nDocumenter.jl\n's public interface.\n\n\nSee \nInternal Documentation\n for internal package docs covering all submodules.\n\n\n\n\nContents\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nDocumenter\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDocumenter\n\n\nDocumenter.Deps\n\n\nDocumenter.Deps.pip\n\n\nDocumenter.deploydocs\n\n\nDocumenter.makedocs\n\n\n\n\n\n\nDocumenter\n\n\n#\n\n\nDocumenter\n \n \nModule\n.\n\n\nMain module for \nDocumenter.jl\n \u2013 a documentation generation package for Julia.\n\n\nTwo functions are exported from this module for public use:\n\n\n\n\nmakedocs\n. Generates documentation from docstrings and templated markdown files.\n\n\ndeploydocs\n. Deploys generated documentation from \nTravis-CI\n to \nGitHub Pages\n.\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.makedocs\n \n \nFunction\n.\n\n\nmakedocs(\n    root    = \ncurrent-directory\n,\n    source  = \nsrc\n,\n    build   = \nbuild\n,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n)\n\n\n\n\n\nCombines markdown files and inline docstrings into an interlinked document. In most cases \nmakedocs\n should be run from a \nmake.jl\n file:\n\n\nusing\n \nDocumenter\n\n\nmakedocs\n(\n\n    \n# keywords...\n\n\n)\n\n\n\n\n\n\nwhich is then run from the command line with:\n\n\n$ julia make.jl\n\n\n\n\n\nThe folder structure that \nmakedocs\n expects looks like:\n\n\ndocs/\n    build/\n    src/\n    make.jl\n\n\n\n\n\nKeywords\n\n\nroot\n is the directory from which \nmakedocs\n should run. When run from a \nmake.jl\n file this keyword does not need to be set. It is, for the most part, needed when repeatedly running \nmakedocs\n from the Julia REPL like so:\n\n\njulia\n makedocs(root = Pkg.dir(\nMyPackage\n, \ndocs\n))\n\n\n\n\n\nsource\n is the directory, relative to \nroot\n, where the markdown source files are read from. By convention this folder is called \nsrc\n. Note that any non-markdown files stored in \nsource\n are copied over to the build directory when \nmakedocs\n is run.\n\n\nbuild\n is the directory, relative to \nroot\n, into which generated files and folders are written when \nmakedocs\n is run. The name of the build directory is, by convention, called \nbuild\n, though, like with \nsource\n, users are free to change this to anything else to better suit their project needs.\n\n\nclean\n tells \nmakedocs\n whether to remove all the content from the \nbuild\n folder prior to generating new content from \nsource\n. By default this is set to \ntrue\n.\n\n\ndoctest\n instructs \nmakedocs\n on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to \ntrue\n. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the \nDoctests\n manual section for details about running doctests.\n\n\nmodules\n specifies a vector of modules that should be documented in \nsource\n. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of \nmakedocs\n. By default no modules are passed to \nmodules\n and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation. For example Documenter's \nmake.jl\n file contains:\n\n\nusing\n \nDocumenter\n\n\n\nmakedocs\n(\n\n    \nmodules\n \n=\n \nDocumenter\n,\n\n    \nclean\n   \n=\n \nfalse\n,\n\n\n)\n\n\n\ndeploydocs\n(\n\n    \ndeps\n \n=\n \nDeps\n.\npip\n(\npygments\n,\n \nmkdocs\n,\n \nmkdocs-material\n),\n\n    \nrepo\n \n=\n \ngithub.com/MichaelHatherly/Documenter.jl.git\n,\n\n\n)\n\n\n\n\n\n\nand so any docstring from the module \nDocumenter\n that is not spliced into the generated documentation in \nbuild\n will raise a warning.\n\n\nSee Also\n\n\nA guide detailing how to document a package using Documenter's \nmakedocs\n is provided in the \nUsage\n section of the manual.\n\n\nsource\n\n\n#\n\n\nDocumenter.deploydocs\n \n \nFunction\n.\n\n\ndeploydocs(\n    root   = \ncurrent-directory\n,\n    target = \nsite\n,\n    repo   = \nrequired\n,\n    branch = \ngh-pages\n,\n    latest = \nmaster\n,\n    osname = \nlinux\n,\n    julia  = \nnightly\n,\n    deps   = \nFunction\n,\n    make   = \nFunction\n,\n)\n\n\n\n\n\nConverts markdown files generated by \nmakedocs\n to HTML and pushes them to \nrepo\n. This function should be called from within a package's \ndocs/make.jl\n file after the call to \nmakedocs\n, like so\n\n\nusing\n \nDocumenter\n,\n \nPACKAGE_NAME\n\n\nmakedocs\n(\n\n    \n# options...\n\n\n)\n\n\ndeploydocs\n(\n\n    \nrepo\n \n=\n \ngithub.com/...\n\n\n)\n\n\n\n\n\n\nKeywords\n\n\nroot\n has the same purpose as the \nroot\n keyword for \nmakedocs\n.\n\n\ntarget\n is the directory, relative to \nroot\n, where generated HTML content should be written to. This directory \nmust\n be added to the repository's \n.gitignore\n file. The default value is \n\"site\"\n.\n\n\nrepo\n is the remote repository where generated HTML content should be pushed to. This keyword \nmust\n be set and will throw an error when left undefined. For example this package uses the following \nrepo\n value:\n\n\nrepo = \ngithub.com/MichaelHatherly/Documenter.jl.git\n\n\n\n\n\n\nbranch\n is the branch where the generated documentation is pushed. By default this value is set to \n\"gh-pages\"\n.\n\n\nlatest\n is the branch that \"tracks\" the latest generated documentation. By default this value is set to \n\"master\"\n.\n\n\nosname\n is the operating system which will be used to deploy generated documentation. This defaults to \n\"linux\"\n. This value must be one of those specified in the \nos:\n section of the \n.travis.yml\n configuration file.\n\n\njulia\n is the version of Julia that will be used to deploy generated documentation. This defaults to \n\"nightly\"\n. This value must be one of those specified in the \njulia:\n section of the \n.travis.yml\n configuration file.\n\n\ndeps\n is the function used to install any dependancies needed to build the documentation. By default this function installs \npygments\n and \nmkdocs\n using the \nDeps.pip\n function:\n\n\ndeps = Deps.pip(\npygments\n, \nmkdocs\n)\n\n\n\n\n\nmake\n is the function used to convert the markdown files to HTML. By default this just runs \nmkdocs build\n which populates the \ntarget\n directory.\n\n\nSee Also\n\n\nThe \nHosting Documentation\n section of the manual provides a step-by-step guide to using the \ndeploydocs\n function to automatically generate docs and push then to GitHub.\n\n\nsource\n\n\n#\n\n\nDocumenter.Deps\n \n \nModule\n.\n\n\nExported module that provides build and deploy dependancies and related functions.\n\n\nCurrently only \npip\n is implemented.\n\n\nsource\n\n\n#\n\n\nDocumenter.Deps.pip\n \n \nFunction\n.\n\n\npip(deps...)\n\n\n\n\n\nInstalls (as non-root user) all python packages listed in \ndeps\n.\n\n\nExamples\n\n\nusing\n \nDocumenter\n\n\n\nmakedocs\n(\n\n    \n# ...\n\n\n)\n\n\n\ndeploydocs\n(\n\n    \ndeps\n \n=\n \nDeps\n.\npip\n(\npygments\n,\n \nmkdocs\n,\n \nmkdocs-material\n),\n\n    \n# ...\n\n\n)\n\n\n\n\n\n\nsource", 
            "title": "Public"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internal Documentation\n\n\n\n\nContents\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\nAnchors\n\n\nBuilder\n\n\nCrossReferences\n\n\nDocChecks\n\n\nDocuments\n\n\nExpanders\n\n\nFormats\n\n\nWalkers\n\n\nWriters\n\n\nUtilities\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDocumenter.Anchors\n\n\nDocumenter.Anchors.Anchor\n\n\nDocumenter.Anchors.AnchorMap\n\n\nDocumenter.Anchors.add!\n\n\nDocumenter.Anchors.anchor\n\n\nDocumenter.Anchors.exists\n\n\nDocumenter.Anchors.isunique\n\n\nDocumenter.Builder\n\n\nDocumenter.Builder.CheckDocument\n\n\nDocumenter.Builder.ContentsBlocks\n\n\nDocumenter.Builder.CopyAssetsDirectory\n\n\nDocumenter.Builder.CrossReferences\n\n\nDocumenter.Builder.DocsBlocks\n\n\nDocumenter.Builder.EvalBlocks\n\n\nDocumenter.Builder.ExpandTemplates\n\n\nDocumenter.Builder.IndexBlocks\n\n\nDocumenter.Builder.MetaBlocks\n\n\nDocumenter.Builder.RenderDocument\n\n\nDocumenter.Builder.SetupBuildDirectory\n\n\nDocumenter.Builder.TrackHeaders\n\n\nDocumenter.CrossReferences\n\n\nDocumenter.CrossReferences.crossref\n\n\nDocumenter.DocChecks\n\n\nDocumenter.DocChecks.doctest\n\n\nDocumenter.DocChecks.missingdocs\n\n\nDocumenter.Documents\n\n\nDocumenter.Documents.Document\n\n\nDocumenter.Documents.Globals\n\n\nDocumenter.Documents.Internal\n\n\nDocumenter.Documents.Page\n\n\nDocumenter.Documents.User\n\n\nDocumenter.Expanders\n\n\nDocumenter.Expanders.expand\n\n\nDocumenter.Formats\n\n\nDocumenter.Formats.Format\n\n\nDocumenter.Formats.mimetype\n\n\nDocumenter.Utilities\n\n\nDocumenter.Utilities.Object\n\n\nDocumenter.Utilities.assetsdir\n\n\nDocumenter.Utilities.check_kwargs\n\n\nDocumenter.Utilities.currentdir\n\n\nDocumenter.Utilities.doccat\n\n\nDocumenter.Utilities.docs\n\n\nDocumenter.Utilities.filterdocs\n\n\nDocumenter.Utilities.log\n\n\nDocumenter.Utilities.logging\n\n\nDocumenter.Utilities.nodocs\n\n\nDocumenter.Utilities.object\n\n\nDocumenter.Utilities.parseblock\n\n\nDocumenter.Utilities.slugify\n\n\nDocumenter.Utilities.submodules\n\n\nDocumenter.Utilities.warn\n\n\nDocumenter.Walkers\n\n\nDocumenter.Walkers.walk\n\n\nDocumenter.Writers\n\n\nDocumenter.Writers.render\n\n\n\n\n\n\nAnchors\n\n\n#\n\n\nDocumenter.Anchors\n \n \nModule\n.\n\n\nDefines the \nAnchor\n and \nAnchorMap\n types.\n\n\nAnchor\ns and \nAnchorMap\ns are used to represent links between objects within a document.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.Anchor\n \n \nType\n.\n\n\nStores an arbitrary object called \n.object\n and it's location within a document.\n\n\nFields\n\n\n\n\nobject\n \u2013 the stored object.\n\n\norder\n  \u2013 ordering of \nobject\n within the entire document.\n\n\nfile\n   \u2013 the destination file, in \nbuild\n, where the object will be written to.\n\n\nid\n     \u2013 the generated \"slug\" identifying the object.\n\n\nnth\n    \u2013 integer that unique-ifies anchors with the same \nid\n.\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.AnchorMap\n \n \nType\n.\n\n\nTree structure representating anchors in a document and their relationships with eachother.\n\n\nObject Hierarchy\n\n\nid -\n file -\n anchors\n\n\n\n\n\nEach \nid\n maps to a \nfile\n which in turn maps to a vector of \nAnchor\n objects.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.add!\n \n \nFunction\n.\n\n\nAdds a new \nAnchor\n to the \nAnchorMap\n for a given \nid\n and \nfile\n.\n\n\nEither an actual \nAnchor\n object may be provided or any other object which is automatically wrapped in an \nAnchor\n before being added to the \nAnchorMap\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.anchor\n \n \nFunction\n.\n\n\nanchor(m, id)\nanchor(m, id, file)\nanchor(m, id, file, n)\n\n\n\n\n\nReturns the \nAnchor\n object matching \nid\n. \nfile\n and \nn\n may also be provided. A \nNullable{Anchor}\n is returned which must be unwrapped with \nisnull\n and \nget\n before use.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.exists\n \n \nFunction\n.\n\n\nexists(m, id)\nexists(m, id, file)\nexists(m, id, file, n)\n\n\n\n\n\nDoes the given \nid\n exist within the \nAnchorMap\n? A \nfile\n and integer \nn\n may also be provided to narrow the search for existance.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.isunique\n \n \nFunction\n.\n\n\nisunique(m, id)\nisunique(m, id, file)\n\n\n\n\n\nIs the \nid\n unique within the given \nAnchorMap\n? May also specify the \nfile\n.\n\n\nsource\n\n\n\n\nBuilder\n\n\n#\n\n\nDocumenter.Builder\n \n \nModule\n.\n\n\nDefines the Documenter build \"pipeline\".\n\n\nThe default pipeline consists of the following:\n\n\n\n\nSetupBuildDirectory\n\n\nCopyAssetsDirectory\n\n\nExpandTemplates\n\n\nCrossReferences\n\n\nCheckDocument\n\n\nRenderDocument\n\n\n\n\nEach stage of the pipeline performs an action on a \nDocuments.Document\n. These actions may involve creating directory structures, expanding templates, running doctests, etc.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.SetupBuildDirectory\n \n \nType\n.\n\n\nCreates the correct directory layout within the \nbuild\n folder and parses markdown files.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.CopyAssetsDirectory\n \n \nType\n.\n\n\nCopies the contents of the \nassets\n directory into the \nbuild\n folder.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.ExpandTemplates\n \n \nType\n.\n\n\nExecutes a sequence of actions on each node of the parsed markdown files in turn. These actions may be any of:\n\n\n\n\nTrackHeaders\n\n\nMetaBlocks\n\n\nDocsBlocks\n\n\nEvalBlocks\n\n\nIndexBlocks\n\n\nContentsBlocks\n\n\n\n\nSee the docs for each of the listed \"expanders\" for their description.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.TrackHeaders\n \n \nType\n.\n\n\nTracks all \nMarkdown.Header\n nodes found in the parsed markdown files and stores an \nAnchors.Anchor\n object for each one.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.MetaBlocks\n \n \nType\n.\n\n\nParses each code block where the first line is \n{meta}\n and evaluates the key/value pairs found within the block, i.e.\n\n\n    {meta}\n    CurrentModule = Documenter\n    DocTestSetup  = quote\n        using Documenter\n    end\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.DocsBlocks\n \n \nType\n.\n\n\nParses each code block where the first line is \n{docs}\n and evaluates the expressions found within the block. Replaces the block with the docstrings associated with each expression.\n\n\n    {docs}\n    Documenter\n    makedocs\n    deploydocs\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.EvalBlocks\n \n \nType\n.\n\n\nParses each code block where the first line is \n{eval}\n and evaluates it's content. Replaces the block with the value resulting from the evaluation. This can be useful for inserting generated content into a document such as plots.\n\n\n    {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color = \nred\n)\n    savefig(\nplot.svg\n)\n\n    Markdown.Image(\nPlot\n, \nplot.svg\n)\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.IndexBlocks\n \n \nType\n.\n\n\nParses each code block where the first line is \n{index}\n and replaces it with an index of all docstrings spliced into the document. The pages that are included can be set using a key/value pair \nPages = [...]\n such as\n\n\n    {index}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.ContentsBlocks\n \n \nType\n.\n\n\nParses each code block where the first line is \n{contents}\n and replaces it with a nested list of all \nHeader\n nodes in the generated document. The pages and depth of the list can be set using \nPages = [...]\n and \nDepth = N\n where \nN\n is and integer.\n\n\n    {contents}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n    Depth = 1\n\n\n\n\n\nThe default \nDepth\n value is \n2\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.CrossReferences\n \n \nType\n.\n\n\nFinds and sets URLs for each \n{ref}\n link in the document to the correct destinations.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.CheckDocument\n \n \nType\n.\n\n\nChecks that all documented objects are included in the document and runs doctests on all valid Julia code blocks.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.RenderDocument\n \n \nType\n.\n\n\nWrites the document tree to the \nbuild\n directory.\n\n\nsource\n\n\n\n\nCrossReferences\n\n\n#\n\n\nDocumenter.CrossReferences\n \n \nModule\n.\n\n\nProvides the \ncrossref\n function used to automatically calculate link URLs.\n\n\nsource\n\n\n#\n\n\nDocumenter.CrossReferences.crossref\n \n \nFunction\n.\n\n\nTraverses a \nDocuments.Document\n and replaces links containg \n{ref}\n URLs with their real URLs.\n\n\nsource\n\n\n\n\nDocChecks\n\n\n#\n\n\nDocumenter.DocChecks\n \n \nModule\n.\n\n\nProvides two functions, \nmissingdocs\n and \ndoctest\n, for checking docs.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocChecks.missingdocs\n \n \nFunction\n.\n\n\nChecks that a \nDocuments.Document\n contains all available docstrings that are defined in the \nmodules\n keyword passed to \nDocumenter.makedocs\n.\n\n\nPrints out the name of each object that has not had its docs spliced into the document.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocChecks.doctest\n \n \nFunction\n.\n\n\nTraverses the document tree and tries to run each Julia code block encountered. Will abort the document generation when an error is thrown. Use \ndoctest = false\n keyword in \nDocumenter.makedocs\n to disable doctesting.\n\n\nsource\n\n\n\n\nDocuments\n\n\n#\n\n\nDocumenter.Documents\n \n \nModule\n.\n\n\nDefines \nDocument\n and its supporting types\n\n\n\n\nPage\n\n\nUser\n\n\nInternal\n\n\nGlobals\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Document\n \n \nType\n.\n\n\nRepresents an entire document.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Page\n \n \nType\n.\n\n\nRepresents a single markdown file.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.User\n \n \nType\n.\n\n\nUser-specified values used to control the generation process.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Internal\n \n \nType\n.\n\n\nPrivate state used to control the generation process.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Globals\n \n \nType\n.\n\n\nPage\n-local values such as current module that are shared between nodes in a page.\n\n\nsource\n\n\n\n\nExpanders\n\n\n#\n\n\nDocumenter.Expanders\n \n \nModule\n.\n\n\nDefines node \"expanders\" that transform nodes from the parsed markdown files.\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.expand\n \n \nFunction\n.\n\n\nexpand(ex, doc)\n\n\n\n\n\nExpands each node of a \nDocuments.Document\n using the expanders provided by \nex\n.\n\n\nsource\n\n\n\n\nFormats\n\n\n#\n\n\nDocumenter.Formats\n \n \nModule\n.\n\n\nFiletypes used to decide which rendering methods in \nDocumenter.Writers\n are called.\n\n\nThe only supported format is currently \nMarkdown\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Formats.Format\n \n \nType\n.\n\n\nRepresents the output format. Possible values are \nMarkdown\n, \nLaTeX\n, and \nHTML\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Formats.mimetype\n \n \nFunction\n.\n\n\nConverts a \nFormat\n value to a \nMIME\n type.\n\n\nsource\n\n\n\n\nWalkers\n\n\n#\n\n\nDocumenter.Walkers\n \n \nModule\n.\n\n\nProvides the \nwalk\n function.\n\n\nsource\n\n\n#\n\n\nDocumenter.Walkers.walk\n \n \nFunction\n.\n\n\nwalk(f, meta, element)\n\n\n\n\n\nCalls \nf\n on \nelement\n and any of its child elements. \nmeta\n is a \nDict\n containing metadata such as current module.\n\n\nsource\n\n\n\n\nWriters\n\n\n#\n\n\nDocumenter.Writers\n \n \nModule\n.\n\n\nProvides a rendering function, \nrender\n, for writing each supported \nFormats.Format\n to file.\n\n\nNote that currently \nFormats.Markdown\n is the \nonly\n supported format.\n\n\nsource\n\n\n#\n\n\nDocumenter.Writers.render\n \n \nFunction\n.\n\n\nWrites a \nDocuments.Document\n object to \nbuild\n directory in specified file format.\n\n\nsource\n\n\n\n\nUtilities\n\n\n#\n\n\nDocumenter.Utilities\n \n \nModule\n.\n\n\nProvides a collection of utility functions and types that are used in other submodules.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.currentdir\n \n \nFunction\n.\n\n\nReturns the current directory.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.assetsdir\n \n \nFunction\n.\n\n\nReturns the path to the Documenter \nassets\n directory.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.check_kwargs\n \n \nFunction\n.\n\n\nPrints a formatted warning to the user listing unrecognised keyword arguments.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.slugify\n \n \nFunction\n.\n\n\nSlugify a string into a suitable URL.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.parseblock\n \n \nFunction\n.\n\n\nReturns a vector of parsed expressions and their corresponding raw strings.\n\n\nThe keyword argument \nskip = N\n drops the leading \nN\n lines from the input string.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.log\n \n \nFunction\n.\n\n\nFormat and print a message to the user.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.warn\n \n \nFunction\n.\n\n\nwarn(file, msg)\nwarn(msg)\n\n\n\n\n\nFormat and print a warning message to the user. Passing a \nfile\n will include the filename where the warning was raised.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.logging\n \n \nFunction\n.\n\n\nlogging(flag::Bool)\n\n\n\n\n\nEnable or disable logging output for \nlog\n and \nwarn\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.submodules\n \n \nFunction\n.\n\n\nReturns the set of submodules of a given root module/s.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.filterdocs\n \n \nFunction\n.\n\n\nfilterdocs(doc, modules)\n\n\n\n\n\nRemove docstrings from the markdown object, \ndoc\n, that are not from one of \nmodules\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.Object\n \n \nType\n.\n\n\nRepresents an object stored in the docsystem by its binding and signature.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.object\n \n \nFunction\n.\n\n\nobject(ex, str)\n\n\n\n\n\nReturns a expression that, when evaluated, returns an \nObject\n representing \nex\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.docs\n \n \nFunction\n.\n\n\ndocs(ex, str)\n\n\n\n\n\nReturns an expression that, when evaluated, returns the docstrings associated with \nex\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.doccat\n \n \nFunction\n.\n\n\nReturns the category name of the provided \nObject\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.nodocs\n \n \nFunction\n.\n\n\nDoes the given docstring represent actual documentation or a no docs error message?\n\n\nsource", 
            "title": "Internals"
        }
    ]
}