{
    "docs": [
        {
            "location": "/", 
            "text": "Documenter.jl\n\n\nA documentation generator for Julia.\n\n\nA package for building documentation from docstrings and markdown files.\n\n\n\n\nPackage Features\n\n\n\n\nMinimal configuration.\n\n\nSupports Julia \n0.4\n and \n0.5-dev\n.\n\n\nDoctests Julia code blocks.\n\n\nCross references for docs and section headers.\n\n\nChecks for missing docstrings and incorrect cross references.\n\n\nGenerates tables of contents and docstring indexes.\n\n\nUse \ngit push\n to automatically build and deploy docs from Travis to GitHub Pages.\n\n\n\n\nThe \nPackage Guide\n provides a tutorial explaining how to get started using Documenter.\n\n\nSome examples of packages using Documenter can be found on the \nExamples\n page.\n\n\nSee the \nIndex\n for the complete list of documented functions and types.\n\n\n\n\nManual Outline\n\n\n\n\nPackage Guide\n\n\nInstallation\n\n\nUsage\n\n\n\n\n\n\nExamples\n\n\nRegistered\n\n\nUnregistered\n\n\n\n\n\n\nSyntax\n\n\n{docs}\n\n\n{autodocs}\n\n\n{ref}\n\n\n{meta}\n\n\n{index}\n\n\n{contents}\n\n\n{example}\n\n\n{repl}\n\n\n{eval}\n\n\n\n\n\n\nDoctests\n\n\n\"Script\" Examples\n\n\nREPL Examples\n\n\nSkipping Doctests\n\n\nSetup Code\n\n\n\n\n\n\nHosting Documentation\n\n\nOverview\n\n\nGitHub Security Key\n\n\nTravis Environment Settings\n\n\n.travis.yml\n Configuration\n\n\nThe \ndeploydocs\n Function\n\n\nThe MkDocs \nmkdocs.yml\n File\n\n\n.gitignore\n\n\ngh-pages\n Branch\n\n\nDocumentation Versions\n\n\n\n\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nDocumenter\n\n\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\nAnchors\n\n\nBuilder\n\n\nCrossReferences\n\n\nDocChecks\n\n\nDocuments\n\n\nExpanders\n\n\nFormats\n\n\nWalkers\n\n\nWriters\n\n\nUtilities\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDocumenter\n\n\nDocumenter.Deps\n\n\nDocumenter.Deps.pip\n\n\nDocumenter.deploydocs\n\n\nDocumenter.makedocs\n\n\nDocumenter.Anchors\n\n\nDocumenter.Anchors.Anchor\n\n\nDocumenter.Anchors.AnchorMap\n\n\nDocumenter.Anchors.add!\n\n\nDocumenter.Anchors.anchor\n\n\nDocumenter.Anchors.exists\n\n\nDocumenter.Anchors.isunique\n\n\nDocumenter.Builder\n\n\nDocumenter.Builder.CheckDocument\n\n\nDocumenter.Builder.ContentsBlocks\n\n\nDocumenter.Builder.CopyAssetsDirectory\n\n\nDocumenter.Builder.CrossReferences\n\n\nDocumenter.Builder.DocsBlocks\n\n\nDocumenter.Builder.EvalBlocks\n\n\nDocumenter.Builder.ExpandTemplates\n\n\nDocumenter.Builder.IndexBlocks\n\n\nDocumenter.Builder.MetaBlocks\n\n\nDocumenter.Builder.RenderDocument\n\n\nDocumenter.Builder.SetupBuildDirectory\n\n\nDocumenter.Builder.TrackHeaders\n\n\nDocumenter.CrossReferences\n\n\nDocumenter.CrossReferences.crossref\n\n\nDocumenter.DocChecks\n\n\nDocumenter.DocChecks.doctest\n\n\nDocumenter.DocChecks.missingdocs\n\n\nDocumenter.Documents\n\n\nDocumenter.Documents.Document\n\n\nDocumenter.Documents.Globals\n\n\nDocumenter.Documents.Internal\n\n\nDocumenter.Documents.Page\n\n\nDocumenter.Documents.User\n\n\nDocumenter.Expanders\n\n\nDocumenter.Expanders.expand\n\n\nDocumenter.Formats\n\n\nDocumenter.Formats.Format\n\n\nDocumenter.Formats.mimetype\n\n\nDocumenter.Utilities\n\n\nDocumenter.Utilities.Object\n\n\nDocumenter.Utilities.assetsdir\n\n\nDocumenter.Utilities.check_kwargs\n\n\nDocumenter.Utilities.currentdir\n\n\nDocumenter.Utilities.doccat\n\n\nDocumenter.Utilities.docs\n\n\nDocumenter.Utilities.filterdocs\n\n\nDocumenter.Utilities.log\n\n\nDocumenter.Utilities.logging\n\n\nDocumenter.Utilities.nodocs\n\n\nDocumenter.Utilities.object\n\n\nDocumenter.Utilities.parseblock\n\n\nDocumenter.Utilities.slugify\n\n\nDocumenter.Utilities.submodules\n\n\nDocumenter.Utilities.warn\n\n\nDocumenter.Walkers\n\n\nDocumenter.Walkers.walk\n\n\nDocumenter.Writers\n\n\nDocumenter.Writers.render", 
            "title": "Home"
        }, 
        {
            "location": "/#documenterjl", 
            "text": "A documentation generator for Julia.  A package for building documentation from docstrings and markdown files.", 
            "title": "Documenter.jl"
        }, 
        {
            "location": "/#package-features", 
            "text": "Minimal configuration.  Supports Julia  0.4  and  0.5-dev .  Doctests Julia code blocks.  Cross references for docs and section headers.  Checks for missing docstrings and incorrect cross references.  Generates tables of contents and docstring indexes.  Use  git push  to automatically build and deploy docs from Travis to GitHub Pages.   The  Package Guide  provides a tutorial explaining how to get started using Documenter.  Some examples of packages using Documenter can be found on the  Examples  page.  See the  Index  for the complete list of documented functions and types.", 
            "title": "Package Features"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "Package Guide  Installation  Usage    Examples  Registered  Unregistered    Syntax  {docs}  {autodocs}  {ref}  {meta}  {index}  {contents}  {example}  {repl}  {eval}    Doctests  \"Script\" Examples  REPL Examples  Skipping Doctests  Setup Code    Hosting Documentation  Overview  GitHub Security Key  Travis Environment Settings  .travis.yml  Configuration  The  deploydocs  Function  The MkDocs  mkdocs.yml  File  .gitignore  gh-pages  Branch  Documentation Versions", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/#library-outline", 
            "text": "Public Documentation  Contents  Index  Documenter    Internal Documentation  Contents  Index  Anchors  Builder  CrossReferences  DocChecks  Documents  Expanders  Formats  Walkers  Writers  Utilities", 
            "title": "Library Outline"
        }, 
        {
            "location": "/#index", 
            "text": "Documenter  Documenter.Deps  Documenter.Deps.pip  Documenter.deploydocs  Documenter.makedocs  Documenter.Anchors  Documenter.Anchors.Anchor  Documenter.Anchors.AnchorMap  Documenter.Anchors.add!  Documenter.Anchors.anchor  Documenter.Anchors.exists  Documenter.Anchors.isunique  Documenter.Builder  Documenter.Builder.CheckDocument  Documenter.Builder.ContentsBlocks  Documenter.Builder.CopyAssetsDirectory  Documenter.Builder.CrossReferences  Documenter.Builder.DocsBlocks  Documenter.Builder.EvalBlocks  Documenter.Builder.ExpandTemplates  Documenter.Builder.IndexBlocks  Documenter.Builder.MetaBlocks  Documenter.Builder.RenderDocument  Documenter.Builder.SetupBuildDirectory  Documenter.Builder.TrackHeaders  Documenter.CrossReferences  Documenter.CrossReferences.crossref  Documenter.DocChecks  Documenter.DocChecks.doctest  Documenter.DocChecks.missingdocs  Documenter.Documents  Documenter.Documents.Document  Documenter.Documents.Globals  Documenter.Documents.Internal  Documenter.Documents.Page  Documenter.Documents.User  Documenter.Expanders  Documenter.Expanders.expand  Documenter.Formats  Documenter.Formats.Format  Documenter.Formats.mimetype  Documenter.Utilities  Documenter.Utilities.Object  Documenter.Utilities.assetsdir  Documenter.Utilities.check_kwargs  Documenter.Utilities.currentdir  Documenter.Utilities.doccat  Documenter.Utilities.docs  Documenter.Utilities.filterdocs  Documenter.Utilities.log  Documenter.Utilities.logging  Documenter.Utilities.nodocs  Documenter.Utilities.object  Documenter.Utilities.parseblock  Documenter.Utilities.slugify  Documenter.Utilities.submodules  Documenter.Utilities.warn  Documenter.Walkers  Documenter.Walkers.walk  Documenter.Writers  Documenter.Writers.render", 
            "title": "Index"
        }, 
        {
            "location": "/man/guide/", 
            "text": "Package Guide\n\n\n\n\nInstallation\n\n\nDocumenter is currently not registered and so must be installed via \nPkg.clone\n.\n\n\nPkg\n.\nclone\n(\nhttps://github.com/MichaelHatherly/Documenter.jl\n)\n\n\n\n\n\n\nThis package supports Julia \n0.4\n and \n0.5\n.\n\n\n\n\nUsage\n\n\nDocumenter is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.\n\n\n\n\nSetting up the folder structure\n\n\nFirstly, we need a Julia module to document. This could be a package generated via \nPkgDev.generate\n or a single \n.jl\n script. For this guide we'll be using a package called \nExample.jl\n that has the following directory layout:\n\n\nExample/\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nNote that the \n...\n just represent unimportant files and folders.\n\n\nWe must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named \ndocs/\n in the toplevel of the package, like so\n\n\nExample/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nInside the \ndocs/\n folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended\n\n\ndocs/\n    src/\n    make.jl\n\n\n\n\n\n\n\nBuilding an empty document\n\n\nWith our \ndocs/\n directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.\n\n\nAdd the following to your \nmake.jl\n file\n\n\nusing\n \nDocumenter\n,\n \nExample\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nThis assumes you've installed Documenter as discussed in \nInstallation\n and that your Examples package can be found by Julia.\n\n\nNow add an \nindex.md\n file to the \nsrc/\n directory. The name has no particular significance though and you may name it whatever you like. We'll stick to \nindex.md\n for this guide.\n\n\nLeave the newly added file empty and the run the following command from the \ndocs/\n directory\n\n\n$ julia make.jl\n\n\n\n\n\nNote that \n$\n just represents the prompt character. You don't need to type that.\n\n\nIf you'd like to see the output from this command in color use\n\n\n$ julia --color\n=\nyes make.jl\n\n\n\n\n\nWhen you run that you should see the following output\n\n\nDocumenter\n:\n \nsetting\n \nup\n \nbuild\n \ndirectory\n.\n\n\nDocumenter\n:\n \ncopying\n \nassets\n \nto\n \nbuild\n \ndirectory\n.\n\n\nDocumenter\n:\n \nexpanding\n \nmarkdown\n \ntemplates\n.\n\n\nDocumenter\n:\n \nbuilding\n \ncross\n-\nreferences\n.\n\n\nDocumenter\n:\n \nrunning\n \ndocument\n \nchecks\n.\n\n\nDocumenter\n:\n \nrendering\n \ndocument\n.\n\n\n\n\n\n\nThe \ndocs/\n folder should contain a new directory \u2013 called \nbuild/\n. It's structure should look like the following\n\n\nbuild/\n    assets/\n        Documenter.css\n        mathjaxhelper.js\n    index.md\n\n\n\n\n\nAt the moment \nbuild/index.md\n should be empty since \nsrc/index.md\n is empty.\n\n\nAt this point you can add some text to \nsrc/index.md\n and rerun the \nmake.jl\n file to see the changes if you'd like to.\n\n\n\n\nAdding some docstrings\n\n\nNext we'll splice a docstring defined in the \nExample\n module into the \nindex.md\n file. To do this first document a function in that module:\n\n\nmodule\n \nExample\n\n\n\nexport\n \nfunc\n\n\n\n\n\n    func(x)\n\n\n\nReturns double the number `x` plus `1`.\n\n\n\n\nfunc\n(\nx\n)\n \n=\n \n2\nx\n \n+\n \n1\n\n\n\nend\n\n\n\n\n\n\nThen in the \nsrc/index.md\n file add the following\n\n\n# Example.jl Documentation\n\n    {docs}\n    func(x)\n\n\n\n\n\nWhen we next run \nmake.jl\n the docstring for \nExample.func(x)\n should appear in place of the \n{docs}\n block in \nbuild/index.md\n. Note that \nmore than one\n object can be referenced inside a \n{docs}\n block \u2013 just place each one on a separate line.\n\n\nNote that the module in which a \n{docs}\n block is evaluated is determined by \ncurrent_module()\n and so will more than likely be \nMain\n. This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a \n{meta}\n block as in the following\n\n\n# Example.jl Documentation\n\n    {meta}\n    CurrentModule = Documenter\n\n...\n\n    {docs}\n    func(x)\n\n\n\n\n\nNote that the \n...\n in the example above is just there to stop the code blocks from merging into a single block. You could use fenced code blocks instead to avoid needing to have to break up the blocks using extra text.\n\n\n\n\nFiltering Included Docstrings\n\n\nIn some cases you may want to include a docstring for a \nMethod\n that extends a \nFunction\n from a different module \u2013 such as \nBase\n. In the following example we extend \nBase.length\n with a new definition for type \nT\n and also add a docstring:\n\n\ntype\n T\n\n    \n# ...\n\n\nend\n\n\n\n\n\nCustom `length` docs for `T`.\n\n\n\n\nBase\n.\nlength\n(::\nT\n)\n \n=\n \n1\n\n\n\n\n\n\nWhen trying to include this docstring with\n\n\n    {docs}\n    length\n\n\n\n\n\nall the docs for \nlength\n will be included \u2013 even those from other modules. There are two ways to solve this problem. Either include the type in the signature with\n\n\n    {docs}\n    length(::T)\n\n\n\n\n\nor declare the specific modules that \nmakedocs\n should include with\n\n\nmakedocs\n(\n\n    \n# options\n\n    \nmodules\n \n=\n \n[\nMyModule\n]\n\n\n)\n\n\n\n\n\n\n\n\nCross Referencing\n\n\nIt may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Documenter's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of \nsrc/index.md\n with the following\n\n\n# Example.jl Documentation\n\n    {docs}\n    func(x)\n\n- link to [Example.jl Documentation]({ref})\n- link to [`func(x)`]({ref})\n\n\n\n\n\nSo we just have to replace each link's url with \n{ref}\n and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.\n\n\nThis also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.\n\n\n\n\nNavigation\n\n\nDocumenter can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our \nindex.md\n file from the previous sections. Add the following to that file\n\n\n# Example.jl Documentation\n\n    {contents}\n\n## Functions\n\n    {docs}\n    func(x)\n\n## Index\n\n    {index}\n\n\n\n\n\nThe \n{contents}\n block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using \nPages\n and \nDepth\n settings as in the following\n\n\n    {contents}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n    Depth = 3\n\n\n\n\n\nThe \n{index}\n block will generate a flat list of links to all the docs that that have been spliced into the document using \n{docs}\n blocks. As with the \n{contents}\n block the pages to be included can be set with a \nPages = [...]\n line. Since the list is not nested \nDepth\n is not supported for \n{index}\n.", 
            "title": "Guide"
        }, 
        {
            "location": "/man/guide/#package-guide", 
            "text": "", 
            "title": "Package Guide"
        }, 
        {
            "location": "/man/guide/#installation", 
            "text": "Documenter is currently not registered and so must be installed via  Pkg.clone .  Pkg . clone ( https://github.com/MichaelHatherly/Documenter.jl )   This package supports Julia  0.4  and  0.5 .", 
            "title": "Installation"
        }, 
        {
            "location": "/man/guide/#usage", 
            "text": "Documenter is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.", 
            "title": "Usage"
        }, 
        {
            "location": "/man/guide/#setting-up-the-folder-structure", 
            "text": "Firstly, we need a Julia module to document. This could be a package generated via  PkgDev.generate  or a single  .jl  script. For this guide we'll be using a package called  Example.jl  that has the following directory layout:  Example/\n    src/\n        Example.jl\n    ...  Note that the  ...  just represent unimportant files and folders.  We must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named  docs/  in the toplevel of the package, like so  Example/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...  Inside the  docs/  folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended  docs/\n    src/\n    make.jl", 
            "title": "Setting up the folder structure"
        }, 
        {
            "location": "/man/guide/#building-an-empty-document", 
            "text": "With our  docs/  directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.  Add the following to your  make.jl  file  using   Documenter ,   Example  makedocs ()   This assumes you've installed Documenter as discussed in  Installation  and that your Examples package can be found by Julia.  Now add an  index.md  file to the  src/  directory. The name has no particular significance though and you may name it whatever you like. We'll stick to  index.md  for this guide.  Leave the newly added file empty and the run the following command from the  docs/  directory  $ julia make.jl  Note that  $  just represents the prompt character. You don't need to type that.  If you'd like to see the output from this command in color use  $ julia --color = yes make.jl  When you run that you should see the following output  Documenter :   setting   up   build   directory .  Documenter :   copying   assets   to   build   directory .  Documenter :   expanding   markdown   templates .  Documenter :   building   cross - references .  Documenter :   running   document   checks .  Documenter :   rendering   document .   The  docs/  folder should contain a new directory \u2013 called  build/ . It's structure should look like the following  build/\n    assets/\n        Documenter.css\n        mathjaxhelper.js\n    index.md  At the moment  build/index.md  should be empty since  src/index.md  is empty.  At this point you can add some text to  src/index.md  and rerun the  make.jl  file to see the changes if you'd like to.", 
            "title": "Building an empty document"
        }, 
        {
            "location": "/man/guide/#adding-some-docstrings", 
            "text": "Next we'll splice a docstring defined in the  Example  module into the  index.md  file. To do this first document a function in that module:  module   Example  export   func       func(x)  Returns double the number `x` plus `1`.   func ( x )   =   2 x   +   1  end   Then in the  src/index.md  file add the following  # Example.jl Documentation\n\n    {docs}\n    func(x)  When we next run  make.jl  the docstring for  Example.func(x)  should appear in place of the  {docs}  block in  build/index.md . Note that  more than one  object can be referenced inside a  {docs}  block \u2013 just place each one on a separate line.  Note that the module in which a  {docs}  block is evaluated is determined by  current_module()  and so will more than likely be  Main . This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a  {meta}  block as in the following  # Example.jl Documentation\n\n    {meta}\n    CurrentModule = Documenter\n\n...\n\n    {docs}\n    func(x)  Note that the  ...  in the example above is just there to stop the code blocks from merging into a single block. You could use fenced code blocks instead to avoid needing to have to break up the blocks using extra text.", 
            "title": "Adding some docstrings"
        }, 
        {
            "location": "/man/guide/#filtering-included-docstrings", 
            "text": "In some cases you may want to include a docstring for a  Method  that extends a  Function  from a different module \u2013 such as  Base . In the following example we extend  Base.length  with a new definition for type  T  and also add a docstring:  type  T \n     # ...  end   Custom `length` docs for `T`.   Base . length (:: T )   =   1   When trying to include this docstring with      {docs}\n    length  all the docs for  length  will be included \u2013 even those from other modules. There are two ways to solve this problem. Either include the type in the signature with      {docs}\n    length(::T)  or declare the specific modules that  makedocs  should include with  makedocs ( \n     # options \n     modules   =   [ MyModule ]  )", 
            "title": "Filtering Included Docstrings"
        }, 
        {
            "location": "/man/guide/#cross-referencing", 
            "text": "It may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Documenter's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of  src/index.md  with the following  # Example.jl Documentation\n\n    {docs}\n    func(x)\n\n- link to [Example.jl Documentation]({ref})\n- link to [`func(x)`]({ref})  So we just have to replace each link's url with  {ref}  and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.  This also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.", 
            "title": "Cross Referencing"
        }, 
        {
            "location": "/man/guide/#navigation", 
            "text": "Documenter can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our  index.md  file from the previous sections. Add the following to that file  # Example.jl Documentation\n\n    {contents}\n\n## Functions\n\n    {docs}\n    func(x)\n\n## Index\n\n    {index}  The  {contents}  block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using  Pages  and  Depth  settings as in the following      {contents}\n    Pages = [ foo.md ,  bar.md ]\n    Depth = 3  The  {index}  block will generate a flat list of links to all the docs that that have been spliced into the document using  {docs}  blocks. As with the  {contents}  block the pages to be included can be set with a  Pages = [...]  line. Since the list is not nested  Depth  is not supported for  {index} .", 
            "title": "Navigation"
        }, 
        {
            "location": "/man/examples/", 
            "text": "Examples\n\n\nSometimes the best way to learn how to use a new package is to look for examples of what others have already built with it.\n\n\nThe following packages use Documenter to build their documentation and so should give a good overview of what this package is currently able to do.\n\n\n\n\nNote\n\n\nPackages are listed alphabetically. If you have a package that uses Documenter then please open a PR that adds it to the appropriate list below.\n\n\nThe \nmake.jl\n file for all listed packages will be tested to check for potential regressions prior to tagging new Documenter releases whenever possible.\n\n\n\n\n\n\nRegistered\n\n\nPackages that have tagged versions available in \nMETADATA.jl\n.\n\n\n\n\nControlSystems.jl\n\n\nMergedMethods.jl\n\n\nNumericSuffixes.jl\n\n\nPrivateModules.jl\n\n\nWeave.jl\n\n\n\n\n\n\nUnregistered\n\n\nPackages that are not available in \nMETADATA.jl\n and may be works-in-progress. Please do take that into consideration when browsing this list.\n\n\n\n\nAnonymousTypes.jl\n\n\nDocumenter.jl", 
            "title": "Examples"
        }, 
        {
            "location": "/man/examples/#examples", 
            "text": "Sometimes the best way to learn how to use a new package is to look for examples of what others have already built with it.  The following packages use Documenter to build their documentation and so should give a good overview of what this package is currently able to do.   Note  Packages are listed alphabetically. If you have a package that uses Documenter then please open a PR that adds it to the appropriate list below.  The  make.jl  file for all listed packages will be tested to check for potential regressions prior to tagging new Documenter releases whenever possible.", 
            "title": "Examples"
        }, 
        {
            "location": "/man/examples/#registered", 
            "text": "Packages that have tagged versions available in  METADATA.jl .   ControlSystems.jl  MergedMethods.jl  NumericSuffixes.jl  PrivateModules.jl  Weave.jl", 
            "title": "Registered"
        }, 
        {
            "location": "/man/examples/#unregistered", 
            "text": "Packages that are not available in  METADATA.jl  and may be works-in-progress. Please do take that into consideration when browsing this list.   AnonymousTypes.jl  Documenter.jl", 
            "title": "Unregistered"
        }, 
        {
            "location": "/man/syntax/", 
            "text": "Syntax\n\n\nThis section of the manual describes the syntax used by Documenter to build documentation.\n\n\n\n\nSyntax\n\n\n{docs}\n\n\n{autodocs}\n\n\n{ref}\n\n\n{meta}\n\n\n{index}\n\n\n{contents}\n\n\n{example}\n\n\n{repl}\n\n\n{eval}\n\n\n\n\n\n\n\n\n\n\n{docs}\n\n\nSplice one or more docstrings into a document in place of the code block, i.e.\n\n\n    {docs}\n    Documenter\n    makedocs\n    deploydocs\n\n\n\n\n\nThis block type is evaluated within the \nCurrentModule\n module if defined, otherwise within \ncurrent_module()\n, and so each object listed in the block should be visible from that module. Undefined objects will raise warnings during documentation generation and cause the code block to be rendered in the final document unchanged.\n\n\nObjects may not be listed more than once within the document. When duplicate objects are detected an error will be raised and the build process will be terminated.\n\n\nTo ensure that all docstrings from a module are included in the final document the \nmodules\n keyword for \nmakedocs\n can be set to the desired module or modules, i.e.\n\n\nmakedocs\n(\n\n    \nmodules\n \n=\n \n[\nDocumenter\n],\n\n\n)\n\n\n\n\n\n\nwhich will cause any unlisted docstrings to raise warnings when \nmakedocs\n is called. If \nmodules\n is not defined then no warnings are printed, even if a document has missing docstrings.\n\n\n\n\n{autodocs}\n\n\nAutomatically splices all docstrings from the provided modules in place of the code block. This is equivalent to manually adding all the docstrings in a \n{docs}\n block.\n\n\n```\n\n\n{\nautodocs\n}\n\n\nModules\n \n=\n \n[\nFoo\n,\n \nBar\n]\n\n\nOrder\n   \n=\n \n[\n:\nfunction\n,\n \n:\ntype\n]\n\n\n```\n\n\n\n\n\n\nThe above \n{autodocs}\n block adds all the docstrings found in modules \nFoo\n and \nBar\n that refer to functions or types to the document.\n\n\nEach module is added in order and so all docs from \nFoo\n will appear before those of \nBar\n. Possible values for the \nOrder\n vector are\n\n\n\n\n:module\n\n\n:constant\n\n\n:type\n\n\n:function\n\n\n:macro\n\n\n\n\nIf no \nOrder\n is provided then the order listed above is used.\n\n\nWhen a potential docstring is found in one of the listed modules, but does not match any value from \nOrder\n then it will be omitted from the document. Hence \nOrder\n acts as a basic filter as well as sorter.\n\n\nNote\n\n\nWhen more complex sorting and filtering is needed then use \n{docs}\n to define it explicitly.\n\n\n\n\n{ref}\n\n\nUsed in markdown links as the URL to tell Documenter to generate a cross-reference automatically. The text part of the link can be either a docstring or header name.\n\n\n# Syntax\n\n... [`makedocs`]({ref}) ...\n\n# Functions\n\n    {docs}\n    makedocs\n\n... [Syntax]({ref}) ...\n\n\n\n\n\nPlain text in the \"text\" part of a link will cross-reference a header, while text in backticks will cross-reference a docstring from a \n{docs}\n block. The text should match the name of the header exactly.\n\n\n{ref}\ns may refer to docstrings or headers on different pages as well as the current page using the same syntax.\n\n\nNote that depending on what the \nCurrentModule\n is set to, a docstring \n{ref}\n may need to be prefixed by the module which defines it.\n\n\nDuplicate Headers\n\n\nIn some cases a document may contain multiple headers with the same name, but on different pages or of different levels. To allow \n{ref}\n to cross-reference a duplicate header it must be given a name as in the following example\n\n\n# [Header]({ref#my-custom-header-name})\n\n\n\n...\n\n\n\n## Header\n\n\n\n...\n \n[\nCustom\n \nHeader\n]({\nref\n#\nmy\n-\ncustom\n-\nheader\n-\nname\n})\n \n...\n\n\n\n\n\n\nThe link that wraps the named header is removed in the final document. The text for a named \n{ref#...}\n does not need to match the header that it references. Named \n{ref#...}\ns may refer to headers on different pages in the same way as unnamed ones do.\n\n\nDuplicate docstring references do not occur since splicing the same docstring into a document more than once is disallowed.\n\n\n\n\n{meta}\n\n\nThis block type is used to define metadata key/value pairs that can be used elsewhere in the page. Currently \nCurrentModule\n and \nDocTestSetup\n are the only recognised keys.\n\n\n    {meta}\n    CurrentModule = FooBar\n    DocTestSetup  = quote\n        using MyPackage\n    end\n\n\n\n\n\nNote that \n{meta}\n blocks are always evaluated with the \ncurrent_module()\n, which is typically \nMain\n.\n\n\nSee \nSetup Code\n section of the Doctests page for an explanation of \nDocTestSetup\n.\n\n\n\n\n{index}\n\n\nGenerates a list of links to docstrings that have been spliced into a document. The only valid setting is currently \nPages = ...\n.\n\n\n    {index}\n    Pages = [\nfoo.md\n]\n\n\n\n\n\nWhen \nPages\n is not provided all pages in the document are included.\n\n\nNote that the \nPages\n value can be any valid Julia code and so can be something more complex that an array literal if a large number of pages must be included, i.e.\n\n\n    {index}\n    Pages = map(file -\n joinpath(\nman\n, file), readdir(\nman\n))\n\n\n\n\n\nIt should be noted though that in this case \nPages\n may not be sorted in the order that is expected by the user. Try to stick to array literals for \nPages\n as much as possible.\n\n\n\n\n{contents}\n\n\nGenerates a nested list of links to document sections. Valid settings are \nPages\n and \nDepth\n.\n\n\n    {contents}\n    Pages = [\nfoo.md\n]\n    Depth = 5\n\n\n\n\n\nAs with \n{index}\n if \nPages\n is not provided then all pages are included. The default \nDepth\n value is \n2\n.\n\n\n\n\n{example}\n\n\nEvaluates the code block and inserts the result into the final document along with the original source code.\n\n\n    {example}\n    a = 1\n    b = 2\n    a + b\n\n\n\n\n\nThe above \n{example}\n block will splice the following into the final document\n\n\n```julia\na = 1\nb = 2\na + b\n```\n\n```\n3\n```\n\n\n\n\n\nLeading and trailing newlines are removed from the rendered code blocks. Trailing whitespace on each line is also removed.\n\n\nHiding Source Code\n\n\nCode blocks may have some content that does not need to be displayed in the final document. \n# hide\n comments can be appended to lines that should not be rendered, i.e.\n\n\n```julia\n{example}\nsrand(1) # hide\nA = rand(3, 3)\nb = [1, 2, 3]\nA \\ b\n```\n\n\n\n\n\nNote that appending \n# hide\n to every line in an \n{example}\n block will result in the block being hidden in the rendered document. The results block will still be rendered though.\n\n\nSTDOUT\n and \nSTDERR\n\n\nThe Julia output streams are redirected to the results block when evaluating \n{example}\n blocks in the same way as when running doctest code blocks.\n\n\nnothing\n Results\n\n\nWhen the \n{example}\n block evaluates to \nnothing\n then the second block is not displayed. Only the source code block will be shown in the rendered document. Note that if any output from either \nSTDOUT\n or \nSTDERR\n is captured then the results block will be displayed even if \nnothing\n is returned.\n\n\nNamed \n{example}\n Blocks\n\n\nBy default \n{example}\n blocks are run in their own anonymous \nModule\ns to avoid side-effects between blocks. To share the same module between different blocks on a page the \n{example}\n can be named with the following syntax\n\n\n```julia\n{example 1}\na = 1\n```\n\n```julia\n{example 1}\nprintln(a)\n```\n\n\n\n\n\nThe name can be any text, not just integers as in the example above, i.e. \n{example foo}\n.\n\n\nNamed \n{example}\n blocks can be useful when generating documentation that requires intermediate explanation or multimedia such as plots as illustrated in the following example\n\n\nFirst we define some functions\n\n```julia\n{example 1}\nusing PyPlot # hide\nf(x) = sin(2x) + 1\ng(x) = cos(x) - x\n```\n\nand then we plot `f` over the interval from ``-\u03c0`` to ``\u03c0``\n\n```julia\n{example 1}\nx = linspace(-\u03c0, \u03c0)\nplot(x, f(x), color = \nred\n)\nsavefig(\nf-plot.svg\n); nothing # hide\n```\n\n![](f-plot.svg)\n\nand then we do the same with `g`\n\n```julia\n{example 1}\nplot(x, g(x), color = \nblue\n)\nsavefig(\ng-plot.svg\n); nothing # hide\n```\n\n![](g-plot.svg)\n\n\n\n\n\nNote that \n{example}\n blocks are evaluated within the directory of \nbuild\n where the file will be rendered . This means than in the above example \nsavefig\n will output the \n.svg\n files into that directory. This allows the images to be easily referenced without needing to worry about relative paths.\n\n\n{example}\n blocks automatically define \nans\n which, as in the Julia REPL, is bound to the value of the last evaluated expression. This can be useful in situations such as the following one where where binding the object returned by \nplot\n to a named variable would look out of place in the final rendered documentation:\n\n\n```julia\n{example}\nusing Gadfly # hide\nplot([sin, x -\n 2sin(x) + x], -2\u03c0, 2\u03c0)\ndraw(SVG(\nplot.svg\n, 6inch, 4inch), ans); nothing # hide\n```\n\n![](plot.svg)\n\n\n\n\n\n\n\n{repl}\n\n\nThese are similar to \n{example}\n blocks, but adds a \njulia\n prompt before each toplevel expression. \n;\n and \n# hide\n syntax may be used in \n{repl}\n blocks in the same way as in the Julia REPL and \n{example}\n blocks.\n\n\n```julia\n{repl}\na = 1\nb = 2\na + b\n```\n\n\n\n\n\nwill generate\n\n\n```julia\njulia\n a = 1\n1\n\njulia\n b = 2\n2\n\njulia\n a + b\n3\n```\n\n\n\n\n\nNamed \n{repl \nname\n}\n blocks behave in the same way as named \n{example \nname\n}\n blocks.\n\n\n\n\n{eval}\n\n\nEvaluates the contents of the block and inserts the resulting value into the final document.\n\n\nIn the following example we use the PyPlot package to generate a plot and display it in the final document.\n\n\n    {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color = \nred\n)\n    savefig(\nplot.svg\n)\n\n    nothing\n\n![](plot.svg)\n\n\n\n\n\nNote that each \n{eval}\n block evaluates its contents within a separate module. When evaluating each block the present working directory, \npwd\n, is set to the directory in \nbuild\n where the file will be written to.\n\n\nAlso, instead of returning \nnothing\n in the example above we could have returned a new \nMarkdown.Image\n object directly. This can be more appropriate when the filename is not known until evaluation of the block itself.\n\n\nNote\n\n\nIn most cases \n{example}\n is preferred over \n{eval}\n. Just like in normal Julia code where \neval\n should be only be considered as a last resort, \n{eval}\n should be treated in the same way.", 
            "title": "Syntax"
        }, 
        {
            "location": "/man/syntax/#syntax", 
            "text": "This section of the manual describes the syntax used by Documenter to build documentation.   Syntax  {docs}  {autodocs}  {ref}  {meta}  {index}  {contents}  {example}  {repl}  {eval}", 
            "title": "Syntax"
        }, 
        {
            "location": "/man/syntax/#docs", 
            "text": "Splice one or more docstrings into a document in place of the code block, i.e.      {docs}\n    Documenter\n    makedocs\n    deploydocs  This block type is evaluated within the  CurrentModule  module if defined, otherwise within  current_module() , and so each object listed in the block should be visible from that module. Undefined objects will raise warnings during documentation generation and cause the code block to be rendered in the final document unchanged.  Objects may not be listed more than once within the document. When duplicate objects are detected an error will be raised and the build process will be terminated.  To ensure that all docstrings from a module are included in the final document the  modules  keyword for  makedocs  can be set to the desired module or modules, i.e.  makedocs ( \n     modules   =   [ Documenter ],  )   which will cause any unlisted docstrings to raise warnings when  makedocs  is called. If  modules  is not defined then no warnings are printed, even if a document has missing docstrings.", 
            "title": "{docs}"
        }, 
        {
            "location": "/man/syntax/#autodocs", 
            "text": "Automatically splices all docstrings from the provided modules in place of the code block. This is equivalent to manually adding all the docstrings in a  {docs}  block.  ```  { autodocs }  Modules   =   [ Foo ,   Bar ]  Order     =   [ : function ,   : type ]  ```   The above  {autodocs}  block adds all the docstrings found in modules  Foo  and  Bar  that refer to functions or types to the document.  Each module is added in order and so all docs from  Foo  will appear before those of  Bar . Possible values for the  Order  vector are   :module  :constant  :type  :function  :macro   If no  Order  is provided then the order listed above is used.  When a potential docstring is found in one of the listed modules, but does not match any value from  Order  then it will be omitted from the document. Hence  Order  acts as a basic filter as well as sorter.  Note  When more complex sorting and filtering is needed then use  {docs}  to define it explicitly.", 
            "title": "{autodocs}"
        }, 
        {
            "location": "/man/syntax/#ref", 
            "text": "Used in markdown links as the URL to tell Documenter to generate a cross-reference automatically. The text part of the link can be either a docstring or header name.  # Syntax\n\n... [`makedocs`]({ref}) ...\n\n# Functions\n\n    {docs}\n    makedocs\n\n... [Syntax]({ref}) ...  Plain text in the \"text\" part of a link will cross-reference a header, while text in backticks will cross-reference a docstring from a  {docs}  block. The text should match the name of the header exactly.  {ref} s may refer to docstrings or headers on different pages as well as the current page using the same syntax.  Note that depending on what the  CurrentModule  is set to, a docstring  {ref}  may need to be prefixed by the module which defines it.  Duplicate Headers  In some cases a document may contain multiple headers with the same name, but on different pages or of different levels. To allow  {ref}  to cross-reference a duplicate header it must be given a name as in the following example  # [Header]({ref#my-custom-header-name})  ...  ## Header  ...   [ Custom   Header ]({ ref # my - custom - header - name })   ...   The link that wraps the named header is removed in the final document. The text for a named  {ref#...}  does not need to match the header that it references. Named  {ref#...} s may refer to headers on different pages in the same way as unnamed ones do.  Duplicate docstring references do not occur since splicing the same docstring into a document more than once is disallowed.", 
            "title": "{ref}"
        }, 
        {
            "location": "/man/syntax/#meta", 
            "text": "This block type is used to define metadata key/value pairs that can be used elsewhere in the page. Currently  CurrentModule  and  DocTestSetup  are the only recognised keys.      {meta}\n    CurrentModule = FooBar\n    DocTestSetup  = quote\n        using MyPackage\n    end  Note that  {meta}  blocks are always evaluated with the  current_module() , which is typically  Main .  See  Setup Code  section of the Doctests page for an explanation of  DocTestSetup .", 
            "title": "{meta}"
        }, 
        {
            "location": "/man/syntax/#index", 
            "text": "Generates a list of links to docstrings that have been spliced into a document. The only valid setting is currently  Pages = ... .      {index}\n    Pages = [ foo.md ]  When  Pages  is not provided all pages in the document are included.  Note that the  Pages  value can be any valid Julia code and so can be something more complex that an array literal if a large number of pages must be included, i.e.      {index}\n    Pages = map(file -  joinpath( man , file), readdir( man ))  It should be noted though that in this case  Pages  may not be sorted in the order that is expected by the user. Try to stick to array literals for  Pages  as much as possible.", 
            "title": "{index}"
        }, 
        {
            "location": "/man/syntax/#contents", 
            "text": "Generates a nested list of links to document sections. Valid settings are  Pages  and  Depth .      {contents}\n    Pages = [ foo.md ]\n    Depth = 5  As with  {index}  if  Pages  is not provided then all pages are included. The default  Depth  value is  2 .", 
            "title": "{contents}"
        }, 
        {
            "location": "/man/syntax/#example", 
            "text": "Evaluates the code block and inserts the result into the final document along with the original source code.      {example}\n    a = 1\n    b = 2\n    a + b  The above  {example}  block will splice the following into the final document  ```julia\na = 1\nb = 2\na + b\n```\n\n```\n3\n```  Leading and trailing newlines are removed from the rendered code blocks. Trailing whitespace on each line is also removed.  Hiding Source Code  Code blocks may have some content that does not need to be displayed in the final document.  # hide  comments can be appended to lines that should not be rendered, i.e.  ```julia\n{example}\nsrand(1) # hide\nA = rand(3, 3)\nb = [1, 2, 3]\nA \\ b\n```  Note that appending  # hide  to every line in an  {example}  block will result in the block being hidden in the rendered document. The results block will still be rendered though.  STDOUT  and  STDERR  The Julia output streams are redirected to the results block when evaluating  {example}  blocks in the same way as when running doctest code blocks.  nothing  Results  When the  {example}  block evaluates to  nothing  then the second block is not displayed. Only the source code block will be shown in the rendered document. Note that if any output from either  STDOUT  or  STDERR  is captured then the results block will be displayed even if  nothing  is returned.  Named  {example}  Blocks  By default  {example}  blocks are run in their own anonymous  Module s to avoid side-effects between blocks. To share the same module between different blocks on a page the  {example}  can be named with the following syntax  ```julia\n{example 1}\na = 1\n```\n\n```julia\n{example 1}\nprintln(a)\n```  The name can be any text, not just integers as in the example above, i.e.  {example foo} .  Named  {example}  blocks can be useful when generating documentation that requires intermediate explanation or multimedia such as plots as illustrated in the following example  First we define some functions\n\n```julia\n{example 1}\nusing PyPlot # hide\nf(x) = sin(2x) + 1\ng(x) = cos(x) - x\n```\n\nand then we plot `f` over the interval from ``-\u03c0`` to ``\u03c0``\n\n```julia\n{example 1}\nx = linspace(-\u03c0, \u03c0)\nplot(x, f(x), color =  red )\nsavefig( f-plot.svg ); nothing # hide\n```\n\n![](f-plot.svg)\n\nand then we do the same with `g`\n\n```julia\n{example 1}\nplot(x, g(x), color =  blue )\nsavefig( g-plot.svg ); nothing # hide\n```\n\n![](g-plot.svg)  Note that  {example}  blocks are evaluated within the directory of  build  where the file will be rendered . This means than in the above example  savefig  will output the  .svg  files into that directory. This allows the images to be easily referenced without needing to worry about relative paths.  {example}  blocks automatically define  ans  which, as in the Julia REPL, is bound to the value of the last evaluated expression. This can be useful in situations such as the following one where where binding the object returned by  plot  to a named variable would look out of place in the final rendered documentation:  ```julia\n{example}\nusing Gadfly # hide\nplot([sin, x -  2sin(x) + x], -2\u03c0, 2\u03c0)\ndraw(SVG( plot.svg , 6inch, 4inch), ans); nothing # hide\n```\n\n![](plot.svg)", 
            "title": "{example}"
        }, 
        {
            "location": "/man/syntax/#repl", 
            "text": "These are similar to  {example}  blocks, but adds a  julia  prompt before each toplevel expression.  ;  and  # hide  syntax may be used in  {repl}  blocks in the same way as in the Julia REPL and  {example}  blocks.  ```julia\n{repl}\na = 1\nb = 2\na + b\n```  will generate  ```julia\njulia  a = 1\n1\n\njulia  b = 2\n2\n\njulia  a + b\n3\n```  Named  {repl  name }  blocks behave in the same way as named  {example  name }  blocks.", 
            "title": "{repl}"
        }, 
        {
            "location": "/man/syntax/#eval", 
            "text": "Evaluates the contents of the block and inserts the resulting value into the final document.  In the following example we use the PyPlot package to generate a plot and display it in the final document.      {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color =  red )\n    savefig( plot.svg )\n\n    nothing\n\n![](plot.svg)  Note that each  {eval}  block evaluates its contents within a separate module. When evaluating each block the present working directory,  pwd , is set to the directory in  build  where the file will be written to.  Also, instead of returning  nothing  in the example above we could have returned a new  Markdown.Image  object directly. This can be more appropriate when the filename is not known until evaluation of the block itself.  Note  In most cases  {example}  is preferred over  {eval} . Just like in normal Julia code where  eval  should be only be considered as a last resort,  {eval}  should be treated in the same way.", 
            "title": "{eval}"
        }, 
        {
            "location": "/man/doctests/", 
            "text": "Doctests\n\n\nDocumenter will, by default, try to run Julia code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Documenter's doctest.\n\n\nThis section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.\n\n\n\n\n\"Script\" Examples\n\n\nThe first, of two, types of doctests is the \"script\" code block. To make Documenter detect this kind of code block the following format must be used:\n\n\n```julia\na = 1\nb = 2\na + b\n\n# output\n\n3\n```\n\n\n\n\n\nThe code block's \"language\" must be \njulia\n and must include a line containing the text \n# output\n. The text before this line is the contents of the script which is run. The text that appears after \n# output\n is the textual representation that would be shown in the Julia REPL if the script had been \ninclude\nd.\n\n\nThe actual output produced by running the \"script\" is compared to the expected result and any difference will result in \nmakedocs\n throwing an error and terminating.\n\n\nNote that the amount of whitespace appearing above and below the \n# output\n line is not significant and can be increased or decreased if desired.\n\n\n\n\nREPL Examples\n\n\nThe other kind of doctest is a simulated Julia REPL session. The following format is detected by Documenter as a REPL doctest:\n\n\n```julia\njulia\n a = 1\n1\n\njulia\n b = 2;\n\njulia\n c = 3;  # comment\n\njulia\n a + b + c\n6\n\n```\n\n\n\n\n\nAs with script doctests, the code block must have it's language set to \njulia\n. When a code block contains one or more \njulia\n at the start of a line then it is assumed to be a REPL doctest. Semi-colons, \n;\n, at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.\n\n\nNote that not all features of the REPL are supported such as shell and help modes.\n\n\n\n\nSkipping Doctests\n\n\nDoctesting can be disabled by setting the \nmakedocs\n keyword \ndoctest = false\n. This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.\n\n\n\n\nSetup Code\n\n\nDoctests may require some setup code that must be evaluated prior to that of the actual example, but that should not be displayed in the final documentation. It could also be that several separate doctests require the same definitions. For both of these cases a \n{meta}\n block containing a \nDocTestSetup = ...\n value can be used as follows:\n\n\n```\njulia\n\n\njulia\n \nusing\n \nDataFrames\n\n\n\njulia\n \ndf\n \n=\n \nDataFrame\n(\nA\n \n=\n \n1\n:10\n,\n \nB\n \n=\n \n2\n:2:20\n);\n\n\n\n```\n\n\n\nSome\n \ntext\n \ndiscussing\n \n`\ndf\n`\n...\n\n\n    \n{\nmeta\n}\n\n    \nDocTestSetup\n \n=\n \nquote\n\n        \nusing\n \nDataFrames\n\n        \ndf\n \n=\n \nDataFrame\n(\nA\n \n=\n \n1\n:10\n,\n \nB\n \n=\n \n2\n:2:20\n)\n\n    \nend\n\n\n\n```\njulia\n\n\njulia\n \ndf\n[\n1\n,\n \n1\n]\n\n\n1\n\n\n```\n\n\n\nSome\n \nmore\n \ntext\n...\n\n\n\n```\njulia\n\n\njulia\n \ndf\n[\n1\n,\n \n:\n]\n\n\n1x2\n \nDataFrames\n.DataFrame\n\n\n|\n \nRow\n \n|\n \nA\n \n|\n \nB\n \n|\n\n\n|\n-----\n|\n---\n|\n---\n|\n\n\n|\n \n1\n   \n|\n \n1\n \n|\n \n2\n \n|\n\n\n```\n\n\n    \n{\nmeta\n}\n\n    \nDocTestSetup\n \n=\n \nnothing\n\n\n\n\n\n\nNote that the \nDocTestSetup\n value is \nre-evaluated\n at the start of \neach\n doctest block and no state is shared between any code blocks. The \nDocTestSetup = nothing\n is not strictly necessary, but good practice nonetheless to help avoid unintentional definitions later on a page.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/doctests/#doctests", 
            "text": "Documenter will, by default, try to run Julia code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Documenter's doctest.  This section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/doctests/#script-examples", 
            "text": "The first, of two, types of doctests is the \"script\" code block. To make Documenter detect this kind of code block the following format must be used:  ```julia\na = 1\nb = 2\na + b\n\n# output\n\n3\n```  The code block's \"language\" must be  julia  and must include a line containing the text  # output . The text before this line is the contents of the script which is run. The text that appears after  # output  is the textual representation that would be shown in the Julia REPL if the script had been  include d.  The actual output produced by running the \"script\" is compared to the expected result and any difference will result in  makedocs  throwing an error and terminating.  Note that the amount of whitespace appearing above and below the  # output  line is not significant and can be increased or decreased if desired.", 
            "title": "\"Script\" Examples"
        }, 
        {
            "location": "/man/doctests/#repl-examples", 
            "text": "The other kind of doctest is a simulated Julia REPL session. The following format is detected by Documenter as a REPL doctest:  ```julia\njulia  a = 1\n1\n\njulia  b = 2;\n\njulia  c = 3;  # comment\n\njulia  a + b + c\n6\n\n```  As with script doctests, the code block must have it's language set to  julia . When a code block contains one or more  julia  at the start of a line then it is assumed to be a REPL doctest. Semi-colons,  ; , at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.  Note that not all features of the REPL are supported such as shell and help modes.", 
            "title": "REPL Examples"
        }, 
        {
            "location": "/man/doctests/#skipping-doctests", 
            "text": "Doctesting can be disabled by setting the  makedocs  keyword  doctest = false . This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.", 
            "title": "Skipping Doctests"
        }, 
        {
            "location": "/man/doctests/#setup-code", 
            "text": "Doctests may require some setup code that must be evaluated prior to that of the actual example, but that should not be displayed in the final documentation. It could also be that several separate doctests require the same definitions. For both of these cases a  {meta}  block containing a  DocTestSetup = ...  value can be used as follows:  ``` julia  julia   using   DataFrames  julia   df   =   DataFrame ( A   =   1 :10 ,   B   =   2 :2:20 );  ```  Some   text   discussing   ` df ` ... \n\n     { meta } \n     DocTestSetup   =   quote \n         using   DataFrames \n         df   =   DataFrame ( A   =   1 :10 ,   B   =   2 :2:20 ) \n     end  ``` julia  julia   df [ 1 ,   1 ]  1  ```  Some   more   text ...  ``` julia  julia   df [ 1 ,   : ]  1x2   DataFrames .DataFrame  |   Row   |   A   |   B   |  | ----- | --- | --- |  |   1     |   1   |   2   |  ``` \n\n     { meta } \n     DocTestSetup   =   nothing   Note that the  DocTestSetup  value is  re-evaluated  at the start of  each  doctest block and no state is shared between any code blocks. The  DocTestSetup = nothing  is not strictly necessary, but good practice nonetheless to help avoid unintentional definitions later on a page.", 
            "title": "Setup Code"
        }, 
        {
            "location": "/man/hosting/", 
            "text": "Hosting Documentation\n\n\nAfter going through the \nPackage Guide\n and \nDoctests\n page you will need to host the generated documentation somewhere for potential users to read. This guide will describe how to setup automatic updates for your package docs using the Travis build service and GitHub Pages. This is the same approach used by this package to host it's own docs \u2013 the docs you're currently reading.\n\n\n\n\nNotes\n\n\nFollowing this guide should be the \nfinal\n step you take after you are comfortable with the syntax and build process used by \nDocumenter.jl\n. Only proceed with the steps outlined on this page once you have successfully used \nmkdocs\n locally to build your documentation. \nmkdocs\n can typically be installed using \npip install mkdocs\n in your terminal.\n\n\nThis guide assumes that you already have GitHub and Travis accounts setup. If not then go set those up first and then return here.\n\n\n\n\n\n\nOverview\n\n\nOnce setup correctly the following will happen each time you push new updates to your package repository:\n\n\n\n\ntravis buildbots startup and run your tests;\n\n\neach buildbot will build the package docs using your \ndocs/make.jl\n script;\n\n\na single buildbot will then try to push the generated docs back the github.\n\n\n\n\nThe following sections outline how to enable this for your own package.\n\n\n\n\nGitHub Security Key\n\n\nFirstly, generate a new \npersonal access token\n.\n\n\nEnter a description for this new token. We'll be calling ours \"Travis\", but any other name will do. For the \"Select scopes\" option choose \"public_repo\" \nonly\n. Then generate the token and save it somewhere safe. We'll be needing it during the next section.\n\n\n\n\nTravis Environment Settings\n\n\nNext we'll add the generated token to our repository's Travis page. Go to the settings page for the repository and under the \"Environment Variables\" section add a new variable called \nGITHUB_API_KEY\n. Copy the generated key from the \nGitHub Security Key\n section as the value and \nmake sure\n that \"Display value in build log\" is \noff\n. Be careful to remove any leading white-space from the key. Then add the key.\n\n\n\n\n.travis.yml\n Configuration\n\n\nIn the \nafter_success\n section of the \n.travis.yml\n file, where code coverage is processed, run your \ndocs/make.jl\n file:\n\n\nafter_success\n:\n\n  \n-\n \njulia -e \nPkg.clone(\nhttps://github.com/MichaelHatherly/Documenter.jl\n)\n\n  \n-\n \njulia -e \ncd(Pkg.dir(\nPACKAGE_NAME\n)); include(joinpath(\ndocs\n, \nmake.jl\n))\n\n\n\n\n\n\nNote that once the package is registered in \nMETADATA.jl\n the \nPkg.clone\n call can be replaced with \nPkg.add(\"Documenter\")\n.\n\n\n\n\nThe \ndeploydocs\n Function\n\n\nAt the moment your \ndocs/make.jl\n file probably only contains\n\n\nusing\n \nDocumenter\n,\n \nPACKAGE_NAME\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nWe'll need to add an additional call to this file after \nmakedocs\n. Add the following at the end of the file:\n\n\ndeploydocs\n(\n\n    \nrepo\n \n=\n \ngithub.com/USER_NAME/PACKAGE_NAME.jl.git\n\n\n)\n\n\n\n\n\n\nwhere \nUSER_NAME\n and \nPACKAGE_NAME\n must be set to the appropriate names.\n\n\nBy default \ndeploydocs\n will deploy the documentation from the \nnightly\n Julia build for Linux. This can be changed using the \njulia\n and \nosname\n keywords as follows:\n\n\ndeploydocs\n(\n\n    \ndeps\n   \n=\n \nDeps\n.\npip\n(\nmkdocs\n,\n \npython-markdown-math\n),\n\n    \nrepo\n   \n=\n \ngithub.com/USER_NAME/PACKAGE_NAME.jl.git\n,\n\n    \njulia\n  \n=\n \n0.4\n,\n\n    \nosname\n \n=\n \nosx\n\n\n)\n\n\n\n\n\n\nThis will deploy the docs from the OSX Julia 0.4 Travis build bot.\n\n\nThe keyword \ndeps\n serves to provide the required dependencies to deploy the documentation. In the example above we include the dependencies \nmkdocs\n and \npython-markdown-math\n. The former makes sure that MkDocs is installed to deploy the documentation, and the latter provides the \nmdx_math\n markdown extension to exploit MathJax rendering of latex equations in markdown. Other dependencies should be included here.\n\n\nSee the \ndeploydocs\n function documentation for more details.\n\n\n\n\nThe MkDocs \nmkdocs.yml\n File\n\n\nWe'll be using \nMkDocs\n to convert the markdown files generated by Documenter to HTML. (This, of course, is not the only option you have for this step. Any markdown to HTML converter should work fine with some amount of setting up.)\n\n\nAdd an \nmkdocs.yml\n file to your \ndocs/\n directory with the following content:\n\n\nsite_name\n:\n        \nPACKAGE_NAME.jl\n\n\nrepo_url\n:\n         \nhttps://github.com/USER_NAME/PACKAGE_NAME.jl\n\n\nsite_description\n:\n \nDescription...\n\n\nsite_author\n:\n      \nUSER_NAME\n\n\n\ntheme\n:\n \nreadthedocs\n\n\n\nextra_css\n:\n\n  \n-\n \nassets/Documenter.css\n\n\n\nextra_javascript\n:\n\n  \n-\n \nhttps://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\n\n  \n-\n \nassets/mathjaxhelper.js\n\n\n\nmarkdown_extensions\n:\n\n  \n-\n \nextra\n\n  \n-\n \ntables\n\n  \n-\n \nfenced_code\n\n  \n-\n \nmdx_math\n\n\n\ndocs_dir\n:\n \nbuild\n\n\n\npages\n:\n\n  \n-\n \nHome\n:\n \nindex.md\n\n\n\n\n\n\nThis is only a basic skeleton. Read through the MkDocs documentation if you would like to know more about the available settings.\n\n\n\n\n.gitignore\n\n\nAdd the following to your package's \n.gitignore\n file\n\n\ndocs/build/\ndocs/site/\n\n\n\n\n\nThese are needed to avoid committing generated content to your repository.\n\n\n\n\ngh-pages\n Branch\n\n\nCreate a new branch called \ngh-pages\n and push it to GitHub. If this branch already exists then you can skip this step, but do note that the generated content is automatically pushed to this branch from Travis.\n\n\n\n\nDocumentation Versions\n\n\nWhen documentation is generated it is stored in one of the following folders:\n\n\n\n\n\n\nlatest\n stores the most recent documentation that is committed to the \nmaster\n branch.\n\n\n\n\n\n\nstable\n stores the most recent documentation from a tagged commit. Older tagged versions   are stored in directories named after their tags. These tagged directories are persistent   and must be manually removed from the \ngh-pages\n branch if necessary.\n\n\n\n\n\n\nOnce your documentation has been pushed to the \ngh-pages\n branch you should add links to your \nREADME.md\n pointing to the \nstable\n and \nlatest\n documentation URLs. It is common practice to make use of \"badges\" similar to those used for Travis and AppVeyor build statuses or code coverage. Adding the following to your package \nREADME.md\n should be all that is necessary:\n\n\n[![](https://img.shields.io/badge/docs-stable-blue.svg)](https://USER_NAME.github.io/PACKAGE_NAME.jl/stable)\n[![](https://img.shields.io/badge/docs-latest-blue.svg)](https://USER_NAME.github.io/PACKAGE_NAME.jl/latest)\n\n\n\n\n\nPACKAGE_NAME\n and \nUSER_NAME\n should be replaced with their appropriate values. The colour and text of the image can be changed by altering \ndocs-stable-blue\n as described on \nshields.io\n, though it is recommended that package authors follow this standard to make it easier for potential users to find documentation links across multiple package README files.\n\n\n\n\nFinal Remarks\n\n\nThat should be all that is needed to enable automatic documentation building. Pushing new commits to your \nmaster\n branch should trigger doc builds. Note that other branches do not trigger these builds and neither do pull requests by potential contributors.\n\n\nIf you would like to see a more complete example of how this process is setup then take a look at this package's repository for some inspiration.", 
            "title": "Hosting Documentation"
        }, 
        {
            "location": "/man/hosting/#hosting-documentation", 
            "text": "After going through the  Package Guide  and  Doctests  page you will need to host the generated documentation somewhere for potential users to read. This guide will describe how to setup automatic updates for your package docs using the Travis build service and GitHub Pages. This is the same approach used by this package to host it's own docs \u2013 the docs you're currently reading.   Notes  Following this guide should be the  final  step you take after you are comfortable with the syntax and build process used by  Documenter.jl . Only proceed with the steps outlined on this page once you have successfully used  mkdocs  locally to build your documentation.  mkdocs  can typically be installed using  pip install mkdocs  in your terminal.  This guide assumes that you already have GitHub and Travis accounts setup. If not then go set those up first and then return here.", 
            "title": "Hosting Documentation"
        }, 
        {
            "location": "/man/hosting/#overview", 
            "text": "Once setup correctly the following will happen each time you push new updates to your package repository:   travis buildbots startup and run your tests;  each buildbot will build the package docs using your  docs/make.jl  script;  a single buildbot will then try to push the generated docs back the github.   The following sections outline how to enable this for your own package.", 
            "title": "Overview"
        }, 
        {
            "location": "/man/hosting/#github-security-key", 
            "text": "Firstly, generate a new  personal access token .  Enter a description for this new token. We'll be calling ours \"Travis\", but any other name will do. For the \"Select scopes\" option choose \"public_repo\"  only . Then generate the token and save it somewhere safe. We'll be needing it during the next section.", 
            "title": "GitHub Security Key"
        }, 
        {
            "location": "/man/hosting/#travis-environment-settings", 
            "text": "Next we'll add the generated token to our repository's Travis page. Go to the settings page for the repository and under the \"Environment Variables\" section add a new variable called  GITHUB_API_KEY . Copy the generated key from the  GitHub Security Key  section as the value and  make sure  that \"Display value in build log\" is  off . Be careful to remove any leading white-space from the key. Then add the key.", 
            "title": "Travis Environment Settings"
        }, 
        {
            "location": "/man/hosting/#travisyml-configuration", 
            "text": "In the  after_success  section of the  .travis.yml  file, where code coverage is processed, run your  docs/make.jl  file:  after_success : \n   -   julia -e  Pkg.clone( https://github.com/MichaelHatherly/Documenter.jl ) \n   -   julia -e  cd(Pkg.dir( PACKAGE_NAME )); include(joinpath( docs ,  make.jl ))   Note that once the package is registered in  METADATA.jl  the  Pkg.clone  call can be replaced with  Pkg.add(\"Documenter\") .", 
            "title": ".travis.yml Configuration"
        }, 
        {
            "location": "/man/hosting/#the-deploydocs-function", 
            "text": "At the moment your  docs/make.jl  file probably only contains  using   Documenter ,   PACKAGE_NAME  makedocs ()   We'll need to add an additional call to this file after  makedocs . Add the following at the end of the file:  deploydocs ( \n     repo   =   github.com/USER_NAME/PACKAGE_NAME.jl.git  )   where  USER_NAME  and  PACKAGE_NAME  must be set to the appropriate names.  By default  deploydocs  will deploy the documentation from the  nightly  Julia build for Linux. This can be changed using the  julia  and  osname  keywords as follows:  deploydocs ( \n     deps     =   Deps . pip ( mkdocs ,   python-markdown-math ), \n     repo     =   github.com/USER_NAME/PACKAGE_NAME.jl.git , \n     julia    =   0.4 , \n     osname   =   osx  )   This will deploy the docs from the OSX Julia 0.4 Travis build bot.  The keyword  deps  serves to provide the required dependencies to deploy the documentation. In the example above we include the dependencies  mkdocs  and  python-markdown-math . The former makes sure that MkDocs is installed to deploy the documentation, and the latter provides the  mdx_math  markdown extension to exploit MathJax rendering of latex equations in markdown. Other dependencies should be included here.  See the  deploydocs  function documentation for more details.", 
            "title": "The deploydocs Function"
        }, 
        {
            "location": "/man/hosting/#the-mkdocs-mkdocsyml-file", 
            "text": "We'll be using  MkDocs  to convert the markdown files generated by Documenter to HTML. (This, of course, is not the only option you have for this step. Any markdown to HTML converter should work fine with some amount of setting up.)  Add an  mkdocs.yml  file to your  docs/  directory with the following content:  site_name :          PACKAGE_NAME.jl  repo_url :           https://github.com/USER_NAME/PACKAGE_NAME.jl  site_description :   Description...  site_author :        USER_NAME  theme :   readthedocs  extra_css : \n   -   assets/Documenter.css  extra_javascript : \n   -   https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML \n   -   assets/mathjaxhelper.js  markdown_extensions : \n   -   extra \n   -   tables \n   -   fenced_code \n   -   mdx_math  docs_dir :   build  pages : \n   -   Home :   index.md   This is only a basic skeleton. Read through the MkDocs documentation if you would like to know more about the available settings.", 
            "title": "The MkDocs mkdocs.yml File"
        }, 
        {
            "location": "/man/hosting/#gitignore", 
            "text": "Add the following to your package's  .gitignore  file  docs/build/\ndocs/site/  These are needed to avoid committing generated content to your repository.", 
            "title": ".gitignore"
        }, 
        {
            "location": "/man/hosting/#gh-pages-branch", 
            "text": "Create a new branch called  gh-pages  and push it to GitHub. If this branch already exists then you can skip this step, but do note that the generated content is automatically pushed to this branch from Travis.", 
            "title": "gh-pages Branch"
        }, 
        {
            "location": "/man/hosting/#documentation-versions", 
            "text": "When documentation is generated it is stored in one of the following folders:    latest  stores the most recent documentation that is committed to the  master  branch.    stable  stores the most recent documentation from a tagged commit. Older tagged versions   are stored in directories named after their tags. These tagged directories are persistent   and must be manually removed from the  gh-pages  branch if necessary.    Once your documentation has been pushed to the  gh-pages  branch you should add links to your  README.md  pointing to the  stable  and  latest  documentation URLs. It is common practice to make use of \"badges\" similar to those used for Travis and AppVeyor build statuses or code coverage. Adding the following to your package  README.md  should be all that is necessary:  [![](https://img.shields.io/badge/docs-stable-blue.svg)](https://USER_NAME.github.io/PACKAGE_NAME.jl/stable)\n[![](https://img.shields.io/badge/docs-latest-blue.svg)](https://USER_NAME.github.io/PACKAGE_NAME.jl/latest)  PACKAGE_NAME  and  USER_NAME  should be replaced with their appropriate values. The colour and text of the image can be changed by altering  docs-stable-blue  as described on  shields.io , though it is recommended that package authors follow this standard to make it easier for potential users to find documentation links across multiple package README files.   Final Remarks  That should be all that is needed to enable automatic documentation building. Pushing new commits to your  master  branch should trigger doc builds. Note that other branches do not trigger these builds and neither do pull requests by potential contributors.  If you would like to see a more complete example of how this process is setup then take a look at this package's repository for some inspiration.", 
            "title": "Documentation Versions"
        }, 
        {
            "location": "/man/internals/", 
            "text": "Package Internals", 
            "title": "Internals"
        }, 
        {
            "location": "/man/internals/#package-internals", 
            "text": "", 
            "title": "Package Internals"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\nDocumentation for \nDocumenter.jl\n's public interface.\n\n\nSee \nInternal Documentation\n for internal package docs covering all submodules.\n\n\n\n\nContents\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nDocumenter\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDocumenter\n\n\nDocumenter.Deps\n\n\nDocumenter.Deps.pip\n\n\nDocumenter.deploydocs\n\n\nDocumenter.makedocs\n\n\n\n\n\n\nDocumenter\n\n\n#\n\n\nDocumenter\n \n \nModule\n.\n\n\nMain module for \nDocumenter.jl\n \u2013 a documentation generation package for Julia.\n\n\nTwo functions are exported from this module for public use:\n\n\n\n\nmakedocs\n. Generates documentation from docstrings and templated markdown files.\n\n\ndeploydocs\n. Deploys generated documentation from \nTravis-CI\n to \nGitHub Pages\n.\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.makedocs\n \n \nFunction\n.\n\n\nmakedocs(\n    root    = \ncurrent-directory\n,\n    source  = \nsrc\n,\n    build   = \nbuild\n,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n)\n\n\n\n\n\nCombines markdown files and inline docstrings into an interlinked document. In most cases \nmakedocs\n should be run from a \nmake.jl\n file:\n\n\nusing\n \nDocumenter\n\n\nmakedocs\n(\n\n    \n# keywords...\n\n\n)\n\n\n\n\n\n\nwhich is then run from the command line with:\n\n\n$ julia make.jl\n\n\n\n\n\nThe folder structure that \nmakedocs\n expects looks like:\n\n\ndocs/\n    build/\n    src/\n    make.jl\n\n\n\n\n\nKeywords\n\n\nroot\n is the directory from which \nmakedocs\n should run. When run from a \nmake.jl\n file this keyword does not need to be set. It is, for the most part, needed when repeatedly running \nmakedocs\n from the Julia REPL like so:\n\n\njulia\n makedocs(root = Pkg.dir(\nMyPackage\n, \ndocs\n))\n\n\n\n\n\nsource\n is the directory, relative to \nroot\n, where the markdown source files are read from. By convention this folder is called \nsrc\n. Note that any non-markdown files stored in \nsource\n are copied over to the build directory when \nmakedocs\n is run.\n\n\nbuild\n is the directory, relative to \nroot\n, into which generated files and folders are written when \nmakedocs\n is run. The name of the build directory is, by convention, called \nbuild\n, though, like with \nsource\n, users are free to change this to anything else to better suit their project needs.\n\n\nclean\n tells \nmakedocs\n whether to remove all the content from the \nbuild\n folder prior to generating new content from \nsource\n. By default this is set to \ntrue\n.\n\n\ndoctest\n instructs \nmakedocs\n on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to \ntrue\n. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the \nDoctests\n manual section for details about running doctests.\n\n\nmodules\n specifies a vector of modules that should be documented in \nsource\n. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of \nmakedocs\n. By default no modules are passed to \nmodules\n and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation. For example Documenter's \nmake.jl\n file contains:\n\n\nusing\n \nDocumenter\n\n\n\nmakedocs\n(\n\n    \nmodules\n \n=\n \nDocumenter\n,\n\n    \nclean\n   \n=\n \nfalse\n,\n\n\n)\n\n\n\ndeploydocs\n(\n\n    \ndeps\n \n=\n \nDeps\n.\npip\n(\npygments\n,\n \nmkdocs\n,\n \nmkdocs-material\n),\n\n    \nrepo\n \n=\n \ngithub.com/MichaelHatherly/Documenter.jl.git\n,\n\n\n)\n\n\n\n\n\n\nand so any docstring from the module \nDocumenter\n that is not spliced into the generated documentation in \nbuild\n will raise a warning.\n\n\nSee Also\n\n\nA guide detailing how to document a package using Documenter's \nmakedocs\n is provided in the \nUsage\n section of the manual.\n\n\nsource\n\n\n#\n\n\nDocumenter.deploydocs\n \n \nFunction\n.\n\n\ndeploydocs(\n    root   = \ncurrent-directory\n,\n    target = \nsite\n,\n    repo   = \nrequired\n,\n    branch = \ngh-pages\n,\n    latest = \nmaster\n,\n    osname = \nlinux\n,\n    julia  = \nnightly\n,\n    deps   = \nFunction\n,\n    make   = \nFunction\n,\n)\n\n\n\n\n\nConverts markdown files generated by \nmakedocs\n to HTML and pushes them to \nrepo\n. This function should be called from within a package's \ndocs/make.jl\n file after the call to \nmakedocs\n, like so\n\n\nusing\n \nDocumenter\n,\n \nPACKAGE_NAME\n\n\nmakedocs\n(\n\n    \n# options...\n\n\n)\n\n\ndeploydocs\n(\n\n    \nrepo\n \n=\n \ngithub.com/...\n\n\n)\n\n\n\n\n\n\nKeywords\n\n\nroot\n has the same purpose as the \nroot\n keyword for \nmakedocs\n.\n\n\ntarget\n is the directory, relative to \nroot\n, where generated HTML content should be written to. This directory \nmust\n be added to the repository's \n.gitignore\n file. The default value is \n\"site\"\n.\n\n\nrepo\n is the remote repository where generated HTML content should be pushed to. This keyword \nmust\n be set and will throw an error when left undefined. For example this package uses the following \nrepo\n value:\n\n\nrepo = \ngithub.com/MichaelHatherly/Documenter.jl.git\n\n\n\n\n\n\nbranch\n is the branch where the generated documentation is pushed. By default this value is set to \n\"gh-pages\"\n.\n\n\nlatest\n is the branch that \"tracks\" the latest generated documentation. By default this value is set to \n\"master\"\n.\n\n\nosname\n is the operating system which will be used to deploy generated documentation. This defaults to \n\"linux\"\n. This value must be one of those specified in the \nos:\n section of the \n.travis.yml\n configuration file.\n\n\njulia\n is the version of Julia that will be used to deploy generated documentation. This defaults to \n\"nightly\"\n. This value must be one of those specified in the \njulia:\n section of the \n.travis.yml\n configuration file.\n\n\ndeps\n is the function used to install any dependancies needed to build the documentation. By default this function installs \npygments\n and \nmkdocs\n using the \nDeps.pip\n function:\n\n\ndeps = Deps.pip(\npygments\n, \nmkdocs\n)\n\n\n\n\n\nmake\n is the function used to convert the markdown files to HTML. By default this just runs \nmkdocs build\n which populates the \ntarget\n directory.\n\n\nSee Also\n\n\nThe \nHosting Documentation\n section of the manual provides a step-by-step guide to using the \ndeploydocs\n function to automatically generate docs and push then to GitHub.\n\n\nsource\n\n\n#\n\n\nDocumenter.Deps\n \n \nModule\n.\n\n\nExported module that provides build and deploy dependancies and related functions.\n\n\nCurrently only \npip\n is implemented.\n\n\nsource\n\n\n#\n\n\nDocumenter.Deps.pip\n \n \nFunction\n.\n\n\npip(deps...)\n\n\n\n\n\nInstalls (as non-root user) all python packages listed in \ndeps\n.\n\n\nExamples\n\n\nusing\n \nDocumenter\n\n\n\nmakedocs\n(\n\n    \n# ...\n\n\n)\n\n\n\ndeploydocs\n(\n\n    \ndeps\n \n=\n \nDeps\n.\npip\n(\npygments\n,\n \nmkdocs\n,\n \nmkdocs-material\n),\n\n    \n# ...\n\n\n)\n\n\n\n\n\n\nsource", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "Documentation for  Documenter.jl 's public interface.  See  Internal Documentation  for internal package docs covering all submodules.", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/public/#contents", 
            "text": "Public Documentation  Contents  Index  Documenter", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/public/#index", 
            "text": "Documenter  Documenter.Deps  Documenter.Deps.pip  Documenter.deploydocs  Documenter.makedocs", 
            "title": "Index"
        }, 
        {
            "location": "/lib/public/#documenter", 
            "text": "#  Documenter     Module .  Main module for  Documenter.jl  \u2013 a documentation generation package for Julia.  Two functions are exported from this module for public use:   makedocs . Generates documentation from docstrings and templated markdown files.  deploydocs . Deploys generated documentation from  Travis-CI  to  GitHub Pages .   source  #  Documenter.makedocs     Function .  makedocs(\n    root    =  current-directory ,\n    source  =  src ,\n    build   =  build ,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n)  Combines markdown files and inline docstrings into an interlinked document. In most cases  makedocs  should be run from a  make.jl  file:  using   Documenter  makedocs ( \n     # keywords...  )   which is then run from the command line with:  $ julia make.jl  The folder structure that  makedocs  expects looks like:  docs/\n    build/\n    src/\n    make.jl  Keywords  root  is the directory from which  makedocs  should run. When run from a  make.jl  file this keyword does not need to be set. It is, for the most part, needed when repeatedly running  makedocs  from the Julia REPL like so:  julia  makedocs(root = Pkg.dir( MyPackage ,  docs ))  source  is the directory, relative to  root , where the markdown source files are read from. By convention this folder is called  src . Note that any non-markdown files stored in  source  are copied over to the build directory when  makedocs  is run.  build  is the directory, relative to  root , into which generated files and folders are written when  makedocs  is run. The name of the build directory is, by convention, called  build , though, like with  source , users are free to change this to anything else to better suit their project needs.  clean  tells  makedocs  whether to remove all the content from the  build  folder prior to generating new content from  source . By default this is set to  true .  doctest  instructs  makedocs  on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to  true . Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the  Doctests  manual section for details about running doctests.  modules  specifies a vector of modules that should be documented in  source . If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of  makedocs . By default no modules are passed to  modules  and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation. For example Documenter's  make.jl  file contains:  using   Documenter  makedocs ( \n     modules   =   Documenter , \n     clean     =   false ,  )  deploydocs ( \n     deps   =   Deps . pip ( pygments ,   mkdocs ,   mkdocs-material ), \n     repo   =   github.com/MichaelHatherly/Documenter.jl.git ,  )   and so any docstring from the module  Documenter  that is not spliced into the generated documentation in  build  will raise a warning.  See Also  A guide detailing how to document a package using Documenter's  makedocs  is provided in the  Usage  section of the manual.  source  #  Documenter.deploydocs     Function .  deploydocs(\n    root   =  current-directory ,\n    target =  site ,\n    repo   =  required ,\n    branch =  gh-pages ,\n    latest =  master ,\n    osname =  linux ,\n    julia  =  nightly ,\n    deps   =  Function ,\n    make   =  Function ,\n)  Converts markdown files generated by  makedocs  to HTML and pushes them to  repo . This function should be called from within a package's  docs/make.jl  file after the call to  makedocs , like so  using   Documenter ,   PACKAGE_NAME  makedocs ( \n     # options...  )  deploydocs ( \n     repo   =   github.com/...  )   Keywords  root  has the same purpose as the  root  keyword for  makedocs .  target  is the directory, relative to  root , where generated HTML content should be written to. This directory  must  be added to the repository's  .gitignore  file. The default value is  \"site\" .  repo  is the remote repository where generated HTML content should be pushed to. This keyword  must  be set and will throw an error when left undefined. For example this package uses the following  repo  value:  repo =  github.com/MichaelHatherly/Documenter.jl.git   branch  is the branch where the generated documentation is pushed. By default this value is set to  \"gh-pages\" .  latest  is the branch that \"tracks\" the latest generated documentation. By default this value is set to  \"master\" .  osname  is the operating system which will be used to deploy generated documentation. This defaults to  \"linux\" . This value must be one of those specified in the  os:  section of the  .travis.yml  configuration file.  julia  is the version of Julia that will be used to deploy generated documentation. This defaults to  \"nightly\" . This value must be one of those specified in the  julia:  section of the  .travis.yml  configuration file.  deps  is the function used to install any dependancies needed to build the documentation. By default this function installs  pygments  and  mkdocs  using the  Deps.pip  function:  deps = Deps.pip( pygments ,  mkdocs )  make  is the function used to convert the markdown files to HTML. By default this just runs  mkdocs build  which populates the  target  directory.  See Also  The  Hosting Documentation  section of the manual provides a step-by-step guide to using the  deploydocs  function to automatically generate docs and push then to GitHub.  source  #  Documenter.Deps     Module .  Exported module that provides build and deploy dependancies and related functions.  Currently only  pip  is implemented.  source  #  Documenter.Deps.pip     Function .  pip(deps...)  Installs (as non-root user) all python packages listed in  deps .  Examples  using   Documenter  makedocs ( \n     # ...  )  deploydocs ( \n     deps   =   Deps . pip ( pygments ,   mkdocs ,   mkdocs-material ), \n     # ...  )   source", 
            "title": "Documenter"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internal Documentation\n\n\n\n\nContents\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\nAnchors\n\n\nBuilder\n\n\nCrossReferences\n\n\nDocChecks\n\n\nDocuments\n\n\nExpanders\n\n\nFormats\n\n\nWalkers\n\n\nWriters\n\n\nUtilities\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nDocumenter.Anchors\n\n\nDocumenter.Anchors.Anchor\n\n\nDocumenter.Anchors.AnchorMap\n\n\nDocumenter.Anchors.add!\n\n\nDocumenter.Anchors.anchor\n\n\nDocumenter.Anchors.exists\n\n\nDocumenter.Anchors.isunique\n\n\nDocumenter.Builder\n\n\nDocumenter.Builder.CheckDocument\n\n\nDocumenter.Builder.ContentsBlocks\n\n\nDocumenter.Builder.CopyAssetsDirectory\n\n\nDocumenter.Builder.CrossReferences\n\n\nDocumenter.Builder.DocsBlocks\n\n\nDocumenter.Builder.EvalBlocks\n\n\nDocumenter.Builder.ExpandTemplates\n\n\nDocumenter.Builder.IndexBlocks\n\n\nDocumenter.Builder.MetaBlocks\n\n\nDocumenter.Builder.RenderDocument\n\n\nDocumenter.Builder.SetupBuildDirectory\n\n\nDocumenter.Builder.TrackHeaders\n\n\nDocumenter.CrossReferences\n\n\nDocumenter.CrossReferences.crossref\n\n\nDocumenter.DocChecks\n\n\nDocumenter.DocChecks.doctest\n\n\nDocumenter.DocChecks.missingdocs\n\n\nDocumenter.Documents\n\n\nDocumenter.Documents.Document\n\n\nDocumenter.Documents.Globals\n\n\nDocumenter.Documents.Internal\n\n\nDocumenter.Documents.Page\n\n\nDocumenter.Documents.User\n\n\nDocumenter.Expanders\n\n\nDocumenter.Expanders.expand\n\n\nDocumenter.Formats\n\n\nDocumenter.Formats.Format\n\n\nDocumenter.Formats.mimetype\n\n\nDocumenter.Utilities\n\n\nDocumenter.Utilities.Object\n\n\nDocumenter.Utilities.assetsdir\n\n\nDocumenter.Utilities.check_kwargs\n\n\nDocumenter.Utilities.currentdir\n\n\nDocumenter.Utilities.doccat\n\n\nDocumenter.Utilities.docs\n\n\nDocumenter.Utilities.filterdocs\n\n\nDocumenter.Utilities.log\n\n\nDocumenter.Utilities.logging\n\n\nDocumenter.Utilities.nodocs\n\n\nDocumenter.Utilities.object\n\n\nDocumenter.Utilities.parseblock\n\n\nDocumenter.Utilities.slugify\n\n\nDocumenter.Utilities.submodules\n\n\nDocumenter.Utilities.warn\n\n\nDocumenter.Walkers\n\n\nDocumenter.Walkers.walk\n\n\nDocumenter.Writers\n\n\nDocumenter.Writers.render\n\n\n\n\n\n\nAnchors\n\n\n#\n\n\nDocumenter.Anchors\n \n \nModule\n.\n\n\nDefines the \nAnchor\n and \nAnchorMap\n types.\n\n\nAnchor\ns and \nAnchorMap\ns are used to represent links between objects within a document.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.Anchor\n \n \nType\n.\n\n\nStores an arbitrary object called \n.object\n and it's location within a document.\n\n\nFields\n\n\n\n\nobject\n \u2013 the stored object.\n\n\norder\n  \u2013 ordering of \nobject\n within the entire document.\n\n\nfile\n   \u2013 the destination file, in \nbuild\n, where the object will be written to.\n\n\nid\n     \u2013 the generated \"slug\" identifying the object.\n\n\nnth\n    \u2013 integer that unique-ifies anchors with the same \nid\n.\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.AnchorMap\n \n \nType\n.\n\n\nTree structure representating anchors in a document and their relationships with eachother.\n\n\nObject Hierarchy\n\n\nid -\n file -\n anchors\n\n\n\n\n\nEach \nid\n maps to a \nfile\n which in turn maps to a vector of \nAnchor\n objects.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.add!\n \n \nFunction\n.\n\n\nAdds a new \nAnchor\n to the \nAnchorMap\n for a given \nid\n and \nfile\n.\n\n\nEither an actual \nAnchor\n object may be provided or any other object which is automatically wrapped in an \nAnchor\n before being added to the \nAnchorMap\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.anchor\n \n \nFunction\n.\n\n\nanchor(m, id)\nanchor(m, id, file)\nanchor(m, id, file, n)\n\n\n\n\n\nReturns the \nAnchor\n object matching \nid\n. \nfile\n and \nn\n may also be provided. A \nNullable{Anchor}\n is returned which must be unwrapped with \nisnull\n and \nget\n before use.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.exists\n \n \nFunction\n.\n\n\nexists(m, id)\nexists(m, id, file)\nexists(m, id, file, n)\n\n\n\n\n\nDoes the given \nid\n exist within the \nAnchorMap\n? A \nfile\n and integer \nn\n may also be provided to narrow the search for existance.\n\n\nsource\n\n\n#\n\n\nDocumenter.Anchors.isunique\n \n \nFunction\n.\n\n\nisunique(m, id)\nisunique(m, id, file)\n\n\n\n\n\nIs the \nid\n unique within the given \nAnchorMap\n? May also specify the \nfile\n.\n\n\nsource\n\n\n\n\nBuilder\n\n\n#\n\n\nDocumenter.Builder\n \n \nModule\n.\n\n\nDefines the Documenter build \"pipeline\".\n\n\nThe default pipeline consists of the following:\n\n\n\n\nSetupBuildDirectory\n\n\nCopyAssetsDirectory\n\n\nExpandTemplates\n\n\nCrossReferences\n\n\nCheckDocument\n\n\nRenderDocument\n\n\n\n\nEach stage of the pipeline performs an action on a \nDocuments.Document\n. These actions may involve creating directory structures, expanding templates, running doctests, etc.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.SetupBuildDirectory\n \n \nType\n.\n\n\nCreates the correct directory layout within the \nbuild\n folder and parses markdown files.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.CopyAssetsDirectory\n \n \nType\n.\n\n\nCopies the contents of the \nassets\n directory into the \nbuild\n folder.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.ExpandTemplates\n \n \nType\n.\n\n\nExecutes a sequence of actions on each node of the parsed markdown files in turn. These actions may be any of:\n\n\n\n\nTrackHeaders\n\n\nMetaBlocks\n\n\nDocsBlocks\n\n\nEvalBlocks\n\n\nIndexBlocks\n\n\nContentsBlocks\n\n\n\n\nSee the docs for each of the listed \"expanders\" for their description.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.TrackHeaders\n \n \nType\n.\n\n\nTracks all \nMarkdown.Header\n nodes found in the parsed markdown files and stores an \nAnchors.Anchor\n object for each one.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.MetaBlocks\n \n \nType\n.\n\n\nParses each code block where the first line is \n{meta}\n and evaluates the key/value pairs found within the block, i.e.\n\n\n    {meta}\n    CurrentModule = Documenter\n    DocTestSetup  = quote\n        using Documenter\n    end\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.DocsBlocks\n \n \nType\n.\n\n\nParses each code block where the first line is \n{docs}\n and evaluates the expressions found within the block. Replaces the block with the docstrings associated with each expression.\n\n\n    {docs}\n    Documenter\n    makedocs\n    deploydocs\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.EvalBlocks\n \n \nType\n.\n\n\nParses each code block where the first line is \n{eval}\n and evaluates it's content. Replaces the block with the value resulting from the evaluation. This can be useful for inserting generated content into a document such as plots.\n\n\n    {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color = \nred\n)\n    savefig(\nplot.svg\n)\n\n    Markdown.Image(\nPlot\n, \nplot.svg\n)\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.IndexBlocks\n \n \nType\n.\n\n\nParses each code block where the first line is \n{index}\n and replaces it with an index of all docstrings spliced into the document. The pages that are included can be set using a key/value pair \nPages = [...]\n such as\n\n\n    {index}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.ContentsBlocks\n \n \nType\n.\n\n\nParses each code block where the first line is \n{contents}\n and replaces it with a nested list of all \nHeader\n nodes in the generated document. The pages and depth of the list can be set using \nPages = [...]\n and \nDepth = N\n where \nN\n is and integer.\n\n\n    {contents}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n    Depth = 1\n\n\n\n\n\nThe default \nDepth\n value is \n2\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.CrossReferences\n \n \nType\n.\n\n\nFinds and sets URLs for each \n{ref}\n link in the document to the correct destinations.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.CheckDocument\n \n \nType\n.\n\n\nChecks that all documented objects are included in the document and runs doctests on all valid Julia code blocks.\n\n\nsource\n\n\n#\n\n\nDocumenter.Builder.RenderDocument\n \n \nType\n.\n\n\nWrites the document tree to the \nbuild\n directory.\n\n\nsource\n\n\n\n\nCrossReferences\n\n\n#\n\n\nDocumenter.CrossReferences\n \n \nModule\n.\n\n\nProvides the \ncrossref\n function used to automatically calculate link URLs.\n\n\nsource\n\n\n#\n\n\nDocumenter.CrossReferences.crossref\n \n \nFunction\n.\n\n\nTraverses a \nDocuments.Document\n and replaces links containg \n{ref}\n URLs with their real URLs.\n\n\nsource\n\n\n\n\nDocChecks\n\n\n#\n\n\nDocumenter.DocChecks\n \n \nModule\n.\n\n\nProvides two functions, \nmissingdocs\n and \ndoctest\n, for checking docs.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocChecks.missingdocs\n \n \nFunction\n.\n\n\nChecks that a \nDocuments.Document\n contains all available docstrings that are defined in the \nmodules\n keyword passed to \nDocumenter.makedocs\n.\n\n\nPrints out the name of each object that has not had its docs spliced into the document.\n\n\nsource\n\n\n#\n\n\nDocumenter.DocChecks.doctest\n \n \nFunction\n.\n\n\nTraverses the document tree and tries to run each Julia code block encountered. Will abort the document generation when an error is thrown. Use \ndoctest = false\n keyword in \nDocumenter.makedocs\n to disable doctesting.\n\n\nsource\n\n\n\n\nDocuments\n\n\n#\n\n\nDocumenter.Documents\n \n \nModule\n.\n\n\nDefines \nDocument\n and its supporting types\n\n\n\n\nPage\n\n\nUser\n\n\nInternal\n\n\nGlobals\n\n\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Document\n \n \nType\n.\n\n\nRepresents an entire document.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Page\n \n \nType\n.\n\n\nRepresents a single markdown file.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.User\n \n \nType\n.\n\n\nUser-specified values used to control the generation process.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Internal\n \n \nType\n.\n\n\nPrivate state used to control the generation process.\n\n\nsource\n\n\n#\n\n\nDocumenter.Documents.Globals\n \n \nType\n.\n\n\nPage\n-local values such as current module that are shared between nodes in a page.\n\n\nsource\n\n\n\n\nExpanders\n\n\n#\n\n\nDocumenter.Expanders\n \n \nModule\n.\n\n\nDefines node \"expanders\" that transform nodes from the parsed markdown files.\n\n\nsource\n\n\n#\n\n\nDocumenter.Expanders.expand\n \n \nFunction\n.\n\n\nexpand(ex, doc)\n\n\n\n\n\nExpands each node of a \nDocuments.Document\n using the expanders provided by \nex\n.\n\n\nsource\n\n\n\n\nFormats\n\n\n#\n\n\nDocumenter.Formats\n \n \nModule\n.\n\n\nFiletypes used to decide which rendering methods in \nDocumenter.Writers\n are called.\n\n\nThe only supported format is currently \nMarkdown\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Formats.Format\n \n \nType\n.\n\n\nRepresents the output format. Possible values are \nMarkdown\n, \nLaTeX\n, and \nHTML\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Formats.mimetype\n \n \nFunction\n.\n\n\nConverts a \nFormat\n value to a \nMIME\n type.\n\n\nsource\n\n\n\n\nWalkers\n\n\n#\n\n\nDocumenter.Walkers\n \n \nModule\n.\n\n\nProvides the \nwalk\n function.\n\n\nsource\n\n\n#\n\n\nDocumenter.Walkers.walk\n \n \nFunction\n.\n\n\nwalk(f, meta, element)\n\n\n\n\n\nCalls \nf\n on \nelement\n and any of its child elements. \nmeta\n is a \nDict\n containing metadata such as current module.\n\n\nsource\n\n\n\n\nWriters\n\n\n#\n\n\nDocumenter.Writers\n \n \nModule\n.\n\n\nProvides a rendering function, \nrender\n, for writing each supported \nFormats.Format\n to file.\n\n\nNote that currently \nFormats.Markdown\n is the \nonly\n supported format.\n\n\nsource\n\n\n#\n\n\nDocumenter.Writers.render\n \n \nFunction\n.\n\n\nWrites a \nDocuments.Document\n object to \nbuild\n directory in specified file format.\n\n\nsource\n\n\n\n\nUtilities\n\n\n#\n\n\nDocumenter.Utilities\n \n \nModule\n.\n\n\nProvides a collection of utility functions and types that are used in other submodules.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.currentdir\n \n \nFunction\n.\n\n\nReturns the current directory.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.assetsdir\n \n \nFunction\n.\n\n\nReturns the path to the Documenter \nassets\n directory.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.check_kwargs\n \n \nFunction\n.\n\n\nPrints a formatted warning to the user listing unrecognised keyword arguments.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.slugify\n \n \nFunction\n.\n\n\nSlugify a string into a suitable URL.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.parseblock\n \n \nFunction\n.\n\n\nReturns a vector of parsed expressions and their corresponding raw strings.\n\n\nThe keyword argument \nskip = N\n drops the leading \nN\n lines from the input string.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.log\n \n \nFunction\n.\n\n\nFormat and print a message to the user.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.warn\n \n \nFunction\n.\n\n\nwarn(file, msg)\nwarn(msg)\n\n\n\n\n\nFormat and print a warning message to the user. Passing a \nfile\n will include the filename where the warning was raised.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.logging\n \n \nFunction\n.\n\n\nlogging(flag::Bool)\n\n\n\n\n\nEnable or disable logging output for \nlog\n and \nwarn\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.submodules\n \n \nFunction\n.\n\n\nReturns the set of submodules of a given root module/s.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.filterdocs\n \n \nFunction\n.\n\n\nfilterdocs(doc, modules)\n\n\n\n\n\nRemove docstrings from the markdown object, \ndoc\n, that are not from one of \nmodules\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.Object\n \n \nType\n.\n\n\nRepresents an object stored in the docsystem by its binding and signature.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.object\n \n \nFunction\n.\n\n\nobject(ex, str)\n\n\n\n\n\nReturns a expression that, when evaluated, returns an \nObject\n representing \nex\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.docs\n \n \nFunction\n.\n\n\ndocs(ex, str)\n\n\n\n\n\nReturns an expression that, when evaluated, returns the docstrings associated with \nex\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.doccat\n \n \nFunction\n.\n\n\nReturns the category name of the provided \nObject\n.\n\n\nsource\n\n\n#\n\n\nDocumenter.Utilities.nodocs\n \n \nFunction\n.\n\n\nDoes the given docstring represent actual documentation or a no docs error message?\n\n\nsource", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#internal-documentation", 
            "text": "", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/lib/internals/#contents", 
            "text": "Internal Documentation  Contents  Index  Anchors  Builder  CrossReferences  DocChecks  Documents  Expanders  Formats  Walkers  Writers  Utilities", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/internals/#index", 
            "text": "Documenter.Anchors  Documenter.Anchors.Anchor  Documenter.Anchors.AnchorMap  Documenter.Anchors.add!  Documenter.Anchors.anchor  Documenter.Anchors.exists  Documenter.Anchors.isunique  Documenter.Builder  Documenter.Builder.CheckDocument  Documenter.Builder.ContentsBlocks  Documenter.Builder.CopyAssetsDirectory  Documenter.Builder.CrossReferences  Documenter.Builder.DocsBlocks  Documenter.Builder.EvalBlocks  Documenter.Builder.ExpandTemplates  Documenter.Builder.IndexBlocks  Documenter.Builder.MetaBlocks  Documenter.Builder.RenderDocument  Documenter.Builder.SetupBuildDirectory  Documenter.Builder.TrackHeaders  Documenter.CrossReferences  Documenter.CrossReferences.crossref  Documenter.DocChecks  Documenter.DocChecks.doctest  Documenter.DocChecks.missingdocs  Documenter.Documents  Documenter.Documents.Document  Documenter.Documents.Globals  Documenter.Documents.Internal  Documenter.Documents.Page  Documenter.Documents.User  Documenter.Expanders  Documenter.Expanders.expand  Documenter.Formats  Documenter.Formats.Format  Documenter.Formats.mimetype  Documenter.Utilities  Documenter.Utilities.Object  Documenter.Utilities.assetsdir  Documenter.Utilities.check_kwargs  Documenter.Utilities.currentdir  Documenter.Utilities.doccat  Documenter.Utilities.docs  Documenter.Utilities.filterdocs  Documenter.Utilities.log  Documenter.Utilities.logging  Documenter.Utilities.nodocs  Documenter.Utilities.object  Documenter.Utilities.parseblock  Documenter.Utilities.slugify  Documenter.Utilities.submodules  Documenter.Utilities.warn  Documenter.Walkers  Documenter.Walkers.walk  Documenter.Writers  Documenter.Writers.render", 
            "title": "Index"
        }, 
        {
            "location": "/lib/internals/#anchors", 
            "text": "#  Documenter.Anchors     Module .  Defines the  Anchor  and  AnchorMap  types.  Anchor s and  AnchorMap s are used to represent links between objects within a document.  source  #  Documenter.Anchors.Anchor     Type .  Stores an arbitrary object called  .object  and it's location within a document.  Fields   object  \u2013 the stored object.  order   \u2013 ordering of  object  within the entire document.  file    \u2013 the destination file, in  build , where the object will be written to.  id      \u2013 the generated \"slug\" identifying the object.  nth     \u2013 integer that unique-ifies anchors with the same  id .   source  #  Documenter.Anchors.AnchorMap     Type .  Tree structure representating anchors in a document and their relationships with eachother.  Object Hierarchy  id -  file -  anchors  Each  id  maps to a  file  which in turn maps to a vector of  Anchor  objects.  source  #  Documenter.Anchors.add!     Function .  Adds a new  Anchor  to the  AnchorMap  for a given  id  and  file .  Either an actual  Anchor  object may be provided or any other object which is automatically wrapped in an  Anchor  before being added to the  AnchorMap .  source  #  Documenter.Anchors.anchor     Function .  anchor(m, id)\nanchor(m, id, file)\nanchor(m, id, file, n)  Returns the  Anchor  object matching  id .  file  and  n  may also be provided. A  Nullable{Anchor}  is returned which must be unwrapped with  isnull  and  get  before use.  source  #  Documenter.Anchors.exists     Function .  exists(m, id)\nexists(m, id, file)\nexists(m, id, file, n)  Does the given  id  exist within the  AnchorMap ? A  file  and integer  n  may also be provided to narrow the search for existance.  source  #  Documenter.Anchors.isunique     Function .  isunique(m, id)\nisunique(m, id, file)  Is the  id  unique within the given  AnchorMap ? May also specify the  file .  source", 
            "title": "Anchors"
        }, 
        {
            "location": "/lib/internals/#builder", 
            "text": "#  Documenter.Builder     Module .  Defines the Documenter build \"pipeline\".  The default pipeline consists of the following:   SetupBuildDirectory  CopyAssetsDirectory  ExpandTemplates  CrossReferences  CheckDocument  RenderDocument   Each stage of the pipeline performs an action on a  Documents.Document . These actions may involve creating directory structures, expanding templates, running doctests, etc.  source  #  Documenter.Builder.SetupBuildDirectory     Type .  Creates the correct directory layout within the  build  folder and parses markdown files.  source  #  Documenter.Builder.CopyAssetsDirectory     Type .  Copies the contents of the  assets  directory into the  build  folder.  source  #  Documenter.Builder.ExpandTemplates     Type .  Executes a sequence of actions on each node of the parsed markdown files in turn. These actions may be any of:   TrackHeaders  MetaBlocks  DocsBlocks  EvalBlocks  IndexBlocks  ContentsBlocks   See the docs for each of the listed \"expanders\" for their description.  source  #  Documenter.Builder.TrackHeaders     Type .  Tracks all  Markdown.Header  nodes found in the parsed markdown files and stores an  Anchors.Anchor  object for each one.  source  #  Documenter.Builder.MetaBlocks     Type .  Parses each code block where the first line is  {meta}  and evaluates the key/value pairs found within the block, i.e.      {meta}\n    CurrentModule = Documenter\n    DocTestSetup  = quote\n        using Documenter\n    end  source  #  Documenter.Builder.DocsBlocks     Type .  Parses each code block where the first line is  {docs}  and evaluates the expressions found within the block. Replaces the block with the docstrings associated with each expression.      {docs}\n    Documenter\n    makedocs\n    deploydocs  source  #  Documenter.Builder.EvalBlocks     Type .  Parses each code block where the first line is  {eval}  and evaluates it's content. Replaces the block with the value resulting from the evaluation. This can be useful for inserting generated content into a document such as plots.      {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color =  red )\n    savefig( plot.svg )\n\n    Markdown.Image( Plot ,  plot.svg )  source  #  Documenter.Builder.IndexBlocks     Type .  Parses each code block where the first line is  {index}  and replaces it with an index of all docstrings spliced into the document. The pages that are included can be set using a key/value pair  Pages = [...]  such as      {index}\n    Pages = [ foo.md ,  bar.md ]  source  #  Documenter.Builder.ContentsBlocks     Type .  Parses each code block where the first line is  {contents}  and replaces it with a nested list of all  Header  nodes in the generated document. The pages and depth of the list can be set using  Pages = [...]  and  Depth = N  where  N  is and integer.      {contents}\n    Pages = [ foo.md ,  bar.md ]\n    Depth = 1  The default  Depth  value is  2 .  source  #  Documenter.Builder.CrossReferences     Type .  Finds and sets URLs for each  {ref}  link in the document to the correct destinations.  source  #  Documenter.Builder.CheckDocument     Type .  Checks that all documented objects are included in the document and runs doctests on all valid Julia code blocks.  source  #  Documenter.Builder.RenderDocument     Type .  Writes the document tree to the  build  directory.  source", 
            "title": "Builder"
        }, 
        {
            "location": "/lib/internals/#crossreferences", 
            "text": "#  Documenter.CrossReferences     Module .  Provides the  crossref  function used to automatically calculate link URLs.  source  #  Documenter.CrossReferences.crossref     Function .  Traverses a  Documents.Document  and replaces links containg  {ref}  URLs with their real URLs.  source", 
            "title": "CrossReferences"
        }, 
        {
            "location": "/lib/internals/#docchecks", 
            "text": "#  Documenter.DocChecks     Module .  Provides two functions,  missingdocs  and  doctest , for checking docs.  source  #  Documenter.DocChecks.missingdocs     Function .  Checks that a  Documents.Document  contains all available docstrings that are defined in the  modules  keyword passed to  Documenter.makedocs .  Prints out the name of each object that has not had its docs spliced into the document.  source  #  Documenter.DocChecks.doctest     Function .  Traverses the document tree and tries to run each Julia code block encountered. Will abort the document generation when an error is thrown. Use  doctest = false  keyword in  Documenter.makedocs  to disable doctesting.  source", 
            "title": "DocChecks"
        }, 
        {
            "location": "/lib/internals/#documents", 
            "text": "#  Documenter.Documents     Module .  Defines  Document  and its supporting types   Page  User  Internal  Globals   source  #  Documenter.Documents.Document     Type .  Represents an entire document.  source  #  Documenter.Documents.Page     Type .  Represents a single markdown file.  source  #  Documenter.Documents.User     Type .  User-specified values used to control the generation process.  source  #  Documenter.Documents.Internal     Type .  Private state used to control the generation process.  source  #  Documenter.Documents.Globals     Type .  Page -local values such as current module that are shared between nodes in a page.  source", 
            "title": "Documents"
        }, 
        {
            "location": "/lib/internals/#expanders", 
            "text": "#  Documenter.Expanders     Module .  Defines node \"expanders\" that transform nodes from the parsed markdown files.  source  #  Documenter.Expanders.expand     Function .  expand(ex, doc)  Expands each node of a  Documents.Document  using the expanders provided by  ex .  source", 
            "title": "Expanders"
        }, 
        {
            "location": "/lib/internals/#formats", 
            "text": "#  Documenter.Formats     Module .  Filetypes used to decide which rendering methods in  Documenter.Writers  are called.  The only supported format is currently  Markdown .  source  #  Documenter.Formats.Format     Type .  Represents the output format. Possible values are  Markdown ,  LaTeX , and  HTML .  source  #  Documenter.Formats.mimetype     Function .  Converts a  Format  value to a  MIME  type.  source", 
            "title": "Formats"
        }, 
        {
            "location": "/lib/internals/#walkers", 
            "text": "#  Documenter.Walkers     Module .  Provides the  walk  function.  source  #  Documenter.Walkers.walk     Function .  walk(f, meta, element)  Calls  f  on  element  and any of its child elements.  meta  is a  Dict  containing metadata such as current module.  source", 
            "title": "Walkers"
        }, 
        {
            "location": "/lib/internals/#writers", 
            "text": "#  Documenter.Writers     Module .  Provides a rendering function,  render , for writing each supported  Formats.Format  to file.  Note that currently  Formats.Markdown  is the  only  supported format.  source  #  Documenter.Writers.render     Function .  Writes a  Documents.Document  object to  build  directory in specified file format.  source", 
            "title": "Writers"
        }, 
        {
            "location": "/lib/internals/#utilities", 
            "text": "#  Documenter.Utilities     Module .  Provides a collection of utility functions and types that are used in other submodules.  source  #  Documenter.Utilities.currentdir     Function .  Returns the current directory.  source  #  Documenter.Utilities.assetsdir     Function .  Returns the path to the Documenter  assets  directory.  source  #  Documenter.Utilities.check_kwargs     Function .  Prints a formatted warning to the user listing unrecognised keyword arguments.  source  #  Documenter.Utilities.slugify     Function .  Slugify a string into a suitable URL.  source  #  Documenter.Utilities.parseblock     Function .  Returns a vector of parsed expressions and their corresponding raw strings.  The keyword argument  skip = N  drops the leading  N  lines from the input string.  source  #  Documenter.Utilities.log     Function .  Format and print a message to the user.  source  #  Documenter.Utilities.warn     Function .  warn(file, msg)\nwarn(msg)  Format and print a warning message to the user. Passing a  file  will include the filename where the warning was raised.  source  #  Documenter.Utilities.logging     Function .  logging(flag::Bool)  Enable or disable logging output for  log  and  warn .  source  #  Documenter.Utilities.submodules     Function .  Returns the set of submodules of a given root module/s.  source  #  Documenter.Utilities.filterdocs     Function .  filterdocs(doc, modules)  Remove docstrings from the markdown object,  doc , that are not from one of  modules .  source  #  Documenter.Utilities.Object     Type .  Represents an object stored in the docsystem by its binding and signature.  source  #  Documenter.Utilities.object     Function .  object(ex, str)  Returns a expression that, when evaluated, returns an  Object  representing  ex .  source  #  Documenter.Utilities.docs     Function .  docs(ex, str)  Returns an expression that, when evaluated, returns the docstrings associated with  ex .  source  #  Documenter.Utilities.doccat     Function .  Returns the category name of the provided  Object .  source  #  Documenter.Utilities.nodocs     Function .  Does the given docstring represent actual documentation or a no docs error message?  source", 
            "title": "Utilities"
        }
    ]
}