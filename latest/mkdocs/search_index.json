{
    "docs": [
        {
            "location": "/", 
            "text": "Lapidary Documentation Outline\n\n\n\n\nPackage Manual\n\n\n\n\nPackage Guide\n\n\nInstallation\n\n\nUsage\n\n\n\n\n\n\nSyntax\n\n\n{ref}\n\n\n{docs}\n\n\n{meta}\n\n\n{index}\n\n\n{contents}\n\n\n{eval}\n\n\n\n\n\n\nDoctests\n\n\n\"Script\" Examples\n\n\nREPL Examples\n\n\nSkipping Doctests\n\n\nSetup Code\n\n\n\n\n\n\nHosting Documentation\n\n\nOverview\n\n\nGitHub Security Key\n\n\nTravis Environment Settings\n\n\n.travis.yml\n Configuration\n\n\nThe \ndeploydocs\n Function\n\n\nThe MkDocs \nmkdocs.yml\n File\n\n\n.gitignore\n\n\ngh-pages\n Branch\n\n\nDocumentation Versions\n\n\n\n\n\n\n\n\n\n\nPackage Reference\n\n\n\n\nPublic Documentation\n\n\nInternal Documentation\n\n\nTypes\n\n\nStages\n\n\nExpanders\n\n\nUtilities\n\n\n\n\n\n\n\n\n\n\nDocumentation Index\n\n\n\n\ndeploydocs\n\n\nmakedocs\n\n\nCheckDocs\n\n\nContentsBlock\n\n\nContentsNode\n\n\nCopyAssetsDirectory\n\n\nCrossReferenceLinks\n\n\nDefaultExpander\n\n\nDocsBlock\n\n\nDocsNode\n\n\nEnv\n\n\nEvalBlock\n\n\nExpandTemplates\n\n\nFindHeaders\n\n\nHeaderPath\n\n\nIndexBlock\n\n\nIndexNode\n\n\nMetaBlock\n\n\nMetaNode\n\n\nParseTemplates\n\n\nParsedPath\n\n\nPath\n\n\nRenderDocument\n\n\nRunDocTests\n\n\nSetupBuildDirectory\n\n\nState\n\n\nassetsdir\n\n\ncar\n\n\ncdr\n\n\ncurrentdir\n\n\ndoctest\n\n\nexpand\n\n\nlog\n\n\nnodocs\n\n\nparseblock\n\n\nprocess\n\n\nslugify\n\n\nwalk", 
            "title": "Home"
        }, 
        {
            "location": "/#lapidary-documentation-outline", 
            "text": "", 
            "title": "Lapidary Documentation Outline"
        }, 
        {
            "location": "/#package-manual", 
            "text": "Package Guide  Installation  Usage    Syntax  {ref}  {docs}  {meta}  {index}  {contents}  {eval}    Doctests  \"Script\" Examples  REPL Examples  Skipping Doctests  Setup Code    Hosting Documentation  Overview  GitHub Security Key  Travis Environment Settings  .travis.yml  Configuration  The  deploydocs  Function  The MkDocs  mkdocs.yml  File  .gitignore  gh-pages  Branch  Documentation Versions", 
            "title": "Package Manual"
        }, 
        {
            "location": "/#package-reference", 
            "text": "Public Documentation  Internal Documentation  Types  Stages  Expanders  Utilities", 
            "title": "Package Reference"
        }, 
        {
            "location": "/#documentation-index", 
            "text": "deploydocs  makedocs  CheckDocs  ContentsBlock  ContentsNode  CopyAssetsDirectory  CrossReferenceLinks  DefaultExpander  DocsBlock  DocsNode  Env  EvalBlock  ExpandTemplates  FindHeaders  HeaderPath  IndexBlock  IndexNode  MetaBlock  MetaNode  ParseTemplates  ParsedPath  Path  RenderDocument  RunDocTests  SetupBuildDirectory  State  assetsdir  car  cdr  currentdir  doctest  expand  log  nodocs  parseblock  process  slugify  walk", 
            "title": "Documentation Index"
        }, 
        {
            "location": "/man/guide/", 
            "text": "Package Guide\n\n\n\n\nInstallation\n\n\nLapidary is currently not registered and so must be installed via \nPkg.clone\n.\n\n\nPkg\n.\nclone\n(\nhttps://github.com/MichaelHatherly/Lapidary.jl\n)\n\n\n\n\n\n\nThis package supports Julia \n0.4\n and \n0.5\n.\n\n\n\n\nUsage\n\n\nLapidary is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.\n\n\n\n\nSetting up the folder structure\n\n\nFirstly, we need a Julia module to document. This could be a package generated via \nPkgDev.generate\n or a single \n.jl\n script. For this guide we'll be using a package called \nExample.jl\n that has the following directory layout:\n\n\nExample/\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nNote that the \n...\n just represent unimportant files and folders.\n\n\nWe must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named \ndocs/\n in the toplevel of the package, like so\n\n\nExample/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nInside the \ndocs/\n folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended\n\n\ndocs/\n    src/\n    make.jl\n\n\n\n\n\n\n\nBuilding an empty document\n\n\nWith our \ndocs/\n directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.\n\n\nAdd the following to your \nmake.jl\n file\n\n\nusing\n \nLapidary\n,\n \nExample\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nThis assumes you've installed Lapidary as discussed in \nInstallation\n and that your Examples package can be found by Julia.\n\n\nNow add an \nindex.md\n file to the \nsrc/\n directory. The name has no particular significance though and you may name it whatever you like. We'll stick to \nindex.md\n for this guide.\n\n\nLeave the newly added file empty and the run the following command from the \ndocs/\n directory\n\n\n$ julia make.jl\n\n\n\n\n\nNote that \n$\n just represents the prompt character. You don't need to type that.\n\n\nIf you'd like to see the output from this command in color use\n\n\n$ julia --color\n=\nyes make.jl\n\n\n\n\n\nWe you run that you should see the following output\n\n\nLAPIDARY\n:\n \nsetting\n \nup\n \nbuild\n \ndirectory\n.\n\n\nLAPIDARY\n:\n \ncopying\n \nassets\n \nto\n \nbuild\n \ndirectory\n.\n\n\nLAPIDARY\n:\n \nparsing\n \nmarkdown\n \ntemplates\n.\n\n\nLAPIDARY\n:\n \nexpanding\n \nparsed\n \ntemplate\n \nfiles\n.\n\n\nLAPIDARY\n:\n \ngenerating\n \ncross\n-\nreference\n \nlinks\n.\n\n\nLAPIDARY\n:\n \nrunning\n \ndoctests\n.\n\n\nLAPIDARY\n:\n \nchecking\n \ndocument\n \nconsistency\n.\n\n\nLAPIDARY\n:\n \nwriting\n \ndocument\n \nto\n \nfile\n.\n\n\n\n\n\n\nThe \ndocs/\n folder should contain a new directory \u2013 called \nbuild/\n. It's structure should look like the following\n\n\nbuild/\n    assets/\n        Lapidary.css\n        mathjaxhelper.js\n    index.md\n\n\n\n\n\nAt the moment \nbuild/index.md\n should be empty since \nsrc/index.md\n is empty.\n\n\nAt this point you can add some text to \nsrc/index.md\n and rerun the \nmake.jl\n file to see the changes if you'd like to.\n\n\n\n\nAdding some docstrings\n\n\nNext we'll splice a docstring defined in the \nExample\n module into the \nindex.md\n file. To do this first document a function in that module:\n\n\nmodule\n \nExample\n\n\n\nexport\n \nfunc\n\n\n\n\n\n    func(x)\n\n\n\nReturns double the number `x` plus `1`.\n\n\n\n\nfunc\n(\nx\n)\n \n=\n \n2\nx\n \n+\n \n1\n\n\n\nend\n\n\n\n\n\n\nThen in the \nsrc/index.md\n file add the following\n\n\n# Example.jl Documentation\n\n    {docs}\n    func(x)\n\n\n\n\n\nWhen we next run \nmake.jl\n the docstring for \nExample.func(x)\n should appear in place of the \n{docs}\n block in \nbuild/index.md\n. Note that \nmore than one\n object can be referenced inside a \n{docs}\n block \u2013 just place each one on a separate line.\n\n\nNote that the module in which a \n{docs}\n block is evaluated is determined by \ncurrent_module()\n and so will more than likely be \nMain\n. This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a \n{meta}\n block as in the following\n\n\n# Example.jl Documentation\n\n    {meta}\n    CurrentModule = Lapidary\n\n...\n\n    {docs}\n    func(x)\n\n\n\n\n\nNote that the \n...\n in the example above is just there to stop the code blocks from merging into a single block. You could use fenced code blocks instead to avoid needing to have to break up the blocks using extra text.\n\n\n\n\nCross Referencing\n\n\nIt may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Lapidary's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of \nsrc/index.md\n with the following\n\n\n# Example.jl Documentation\n\n    {docs}\n    func(x)\n\n- link to [Example.jl Documentation]({ref})\n- link to [`func(x)`]({ref})\n\n\n\n\n\nSo we just have to replace each link's url with \n{ref}\n and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.\n\n\nThis also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.\n\n\n\n\nNavigation\n\n\nLapidary can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our \nindex.md\n file from the previous sections. Add the following to that file\n\n\n# Example.jl Documentation\n\n    {contents}\n\n## Functions\n\n    {docs}\n    func(x)\n\n## Index\n\n    {index}\n\n\n\n\n\nThe \n{contents}\n block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using \nPages\n and \nDepth\n settings as in the following\n\n\n    {contents}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n    Depth = 3\n\n\n\n\n\nThe \n{index}\n block will generate a flat list of links to all the docs that that have been spliced into the document using \n{docs}\n blocks. As with the \n{contents}\n block the pages to be included can be set with a \nPages = [...]\n line. Since the list is not nested \nDepth\n is not supported for \n{index}\n.", 
            "title": "Guide"
        }, 
        {
            "location": "/man/guide/#package-guide", 
            "text": "", 
            "title": "Package Guide"
        }, 
        {
            "location": "/man/guide/#installation", 
            "text": "Lapidary is currently not registered and so must be installed via  Pkg.clone .  Pkg . clone ( https://github.com/MichaelHatherly/Lapidary.jl )   This package supports Julia  0.4  and  0.5 .", 
            "title": "Installation"
        }, 
        {
            "location": "/man/guide/#usage", 
            "text": "Lapidary is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.", 
            "title": "Usage"
        }, 
        {
            "location": "/man/guide/#setting-up-the-folder-structure", 
            "text": "Firstly, we need a Julia module to document. This could be a package generated via  PkgDev.generate  or a single  .jl  script. For this guide we'll be using a package called  Example.jl  that has the following directory layout:  Example/\n    src/\n        Example.jl\n    ...  Note that the  ...  just represent unimportant files and folders.  We must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named  docs/  in the toplevel of the package, like so  Example/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...  Inside the  docs/  folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended  docs/\n    src/\n    make.jl", 
            "title": "Setting up the folder structure"
        }, 
        {
            "location": "/man/guide/#building-an-empty-document", 
            "text": "With our  docs/  directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.  Add the following to your  make.jl  file  using   Lapidary ,   Example  makedocs ()   This assumes you've installed Lapidary as discussed in  Installation  and that your Examples package can be found by Julia.  Now add an  index.md  file to the  src/  directory. The name has no particular significance though and you may name it whatever you like. We'll stick to  index.md  for this guide.  Leave the newly added file empty and the run the following command from the  docs/  directory  $ julia make.jl  Note that  $  just represents the prompt character. You don't need to type that.  If you'd like to see the output from this command in color use  $ julia --color = yes make.jl  We you run that you should see the following output  LAPIDARY :   setting   up   build   directory .  LAPIDARY :   copying   assets   to   build   directory .  LAPIDARY :   parsing   markdown   templates .  LAPIDARY :   expanding   parsed   template   files .  LAPIDARY :   generating   cross - reference   links .  LAPIDARY :   running   doctests .  LAPIDARY :   checking   document   consistency .  LAPIDARY :   writing   document   to   file .   The  docs/  folder should contain a new directory \u2013 called  build/ . It's structure should look like the following  build/\n    assets/\n        Lapidary.css\n        mathjaxhelper.js\n    index.md  At the moment  build/index.md  should be empty since  src/index.md  is empty.  At this point you can add some text to  src/index.md  and rerun the  make.jl  file to see the changes if you'd like to.", 
            "title": "Building an empty document"
        }, 
        {
            "location": "/man/guide/#adding-some-docstrings", 
            "text": "Next we'll splice a docstring defined in the  Example  module into the  index.md  file. To do this first document a function in that module:  module   Example  export   func       func(x)  Returns double the number `x` plus `1`.   func ( x )   =   2 x   +   1  end   Then in the  src/index.md  file add the following  # Example.jl Documentation\n\n    {docs}\n    func(x)  When we next run  make.jl  the docstring for  Example.func(x)  should appear in place of the  {docs}  block in  build/index.md . Note that  more than one  object can be referenced inside a  {docs}  block \u2013 just place each one on a separate line.  Note that the module in which a  {docs}  block is evaluated is determined by  current_module()  and so will more than likely be  Main . This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a  {meta}  block as in the following  # Example.jl Documentation\n\n    {meta}\n    CurrentModule = Lapidary\n\n...\n\n    {docs}\n    func(x)  Note that the  ...  in the example above is just there to stop the code blocks from merging into a single block. You could use fenced code blocks instead to avoid needing to have to break up the blocks using extra text.", 
            "title": "Adding some docstrings"
        }, 
        {
            "location": "/man/guide/#cross-referencing", 
            "text": "It may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Lapidary's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of  src/index.md  with the following  # Example.jl Documentation\n\n    {docs}\n    func(x)\n\n- link to [Example.jl Documentation]({ref})\n- link to [`func(x)`]({ref})  So we just have to replace each link's url with  {ref}  and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.  This also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.", 
            "title": "Cross Referencing"
        }, 
        {
            "location": "/man/guide/#navigation", 
            "text": "Lapidary can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our  index.md  file from the previous sections. Add the following to that file  # Example.jl Documentation\n\n    {contents}\n\n## Functions\n\n    {docs}\n    func(x)\n\n## Index\n\n    {index}  The  {contents}  block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using  Pages  and  Depth  settings as in the following      {contents}\n    Pages = [ foo.md ,  bar.md ]\n    Depth = 3  The  {index}  block will generate a flat list of links to all the docs that that have been spliced into the document using  {docs}  blocks. As with the  {contents}  block the pages to be included can be set with a  Pages = [...]  line. Since the list is not nested  Depth  is not supported for  {index} .", 
            "title": "Navigation"
        }, 
        {
            "location": "/man/syntax/", 
            "text": "Syntax\n\n\nThis section of the manual summarises the special syntax used by Lapidary.\n\n\n\n\n{ref}\n\n\nUsed in markdown links as the url to tell Lapidary to generate a cross-reference automatically. The text part of the link can be either a docstring or header name.\n\n\n[Foo]({ref})   # Link to the section called \nFoo\n.\n[`bar`]({ref}) # Link to the docstring called `bar`.\n\n\n\n\n\n\n\n{docs}\n\n\nSplice a collection of docstrings into a document.\n\n\n    {docs}\n    Foo\n    bar(x)\n    @baz(x, y)\n\n\n\n\n\n\n\n{meta}\n\n\nUsed to define any number of metadata key/value pairs that can then be used elsewhere in the page. Currently \nCurrentModule = ...\n is the only recognised pair.\n\n\n    {meta}\n    CurrentModule = FooBar\n\n\n\n\n\n\n\n{index}\n\n\nGenerates a list of links to docstrings that have been spliced into a document. The only valid setting is currently \nPages = ...\n.\n\n\n    {index}\n    Pages = [\nfoo.md\n]\n\n\n\n\n\nWhen \nPages\n is not provided all pages in the document are included.\n\n\n\n\n{contents}\n\n\nGenerates a nested list of links to document sections. Valid settings are \nPages\n and \nDepth\n.\n\n\n    {contents}\n    Pages = [\nfoo.md\n]\n    Depth = 5\n\n\n\n\n\nAs with \n{index}\n if \nPages\n is not provided then all pages are included. The default \nDepth\n value is \n2\n.\n\n\n\n\n{eval}\n\n\nEvaluates the contents of the block and inserts the resulting value into the final document.\n\n\nIn the following example we use the PyPlot package to generate a plot and display it in the final document.\n\n\n    {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color = \nred\n)\n    savefig(\nplot.svg\n)\n\n    nothing\n\n![](plot.svg)\n\n\n\n\n\nNote that each \n{eval}\n block evaluates its contents within a separate module. When evaluating each block the present working directory, \npwd\n, is set to the directory in \nbuild\n where the file will be written to.\n\n\nAlso, instead of returning \nnothing\n in the example above we could have returned a new \nMarkdown.Image\n object directly. This can be more appropriate when the filename is not known until evaluation of the block itself.", 
            "title": "Syntax"
        }, 
        {
            "location": "/man/syntax/#syntax", 
            "text": "This section of the manual summarises the special syntax used by Lapidary.", 
            "title": "Syntax"
        }, 
        {
            "location": "/man/syntax/#ref", 
            "text": "Used in markdown links as the url to tell Lapidary to generate a cross-reference automatically. The text part of the link can be either a docstring or header name.  [Foo]({ref})   # Link to the section called  Foo .\n[`bar`]({ref}) # Link to the docstring called `bar`.", 
            "title": "{ref}"
        }, 
        {
            "location": "/man/syntax/#docs", 
            "text": "Splice a collection of docstrings into a document.      {docs}\n    Foo\n    bar(x)\n    @baz(x, y)", 
            "title": "{docs}"
        }, 
        {
            "location": "/man/syntax/#meta", 
            "text": "Used to define any number of metadata key/value pairs that can then be used elsewhere in the page. Currently  CurrentModule = ...  is the only recognised pair.      {meta}\n    CurrentModule = FooBar", 
            "title": "{meta}"
        }, 
        {
            "location": "/man/syntax/#index", 
            "text": "Generates a list of links to docstrings that have been spliced into a document. The only valid setting is currently  Pages = ... .      {index}\n    Pages = [ foo.md ]  When  Pages  is not provided all pages in the document are included.", 
            "title": "{index}"
        }, 
        {
            "location": "/man/syntax/#contents", 
            "text": "Generates a nested list of links to document sections. Valid settings are  Pages  and  Depth .      {contents}\n    Pages = [ foo.md ]\n    Depth = 5  As with  {index}  if  Pages  is not provided then all pages are included. The default  Depth  value is  2 .", 
            "title": "{contents}"
        }, 
        {
            "location": "/man/syntax/#eval", 
            "text": "Evaluates the contents of the block and inserts the resulting value into the final document.  In the following example we use the PyPlot package to generate a plot and display it in the final document.      {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color =  red )\n    savefig( plot.svg )\n\n    nothing\n\n![](plot.svg)  Note that each  {eval}  block evaluates its contents within a separate module. When evaluating each block the present working directory,  pwd , is set to the directory in  build  where the file will be written to.  Also, instead of returning  nothing  in the example above we could have returned a new  Markdown.Image  object directly. This can be more appropriate when the filename is not known until evaluation of the block itself.", 
            "title": "{eval}"
        }, 
        {
            "location": "/man/doctests/", 
            "text": "Doctests\n\n\nLapidary will, by default, try to run Julia code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Lapidary's doctest.\n\n\nThis section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.\n\n\n\n\n\"Script\" Examples\n\n\nThe first, of two, types of doctests is the \"script\" code block. To make Lapidary detect this kind of code block the following format must be used:\n\n\n```julia\na = 1\nb = 2\na + b\n\n# output\n\n3\n```\n\n\n\n\n\nThe code block's \"language\" must be \njulia\n and must include a line containing the text \n# output\n. The text before this line is the contents of the script which is run. The text that appears after \n# output\n is the textual representation that would be shown in the Julia REPL if the script had been \ninclude\nd.\n\n\nThe actual output produced by running the \"script\" is compared to the expected result and any difference will result in \nmakedocs\n throwing an error and terminating.\n\n\nNote that the amount of whitespace appearing above and below the \n# output\n line is not significant and can be increased or decreased if desired.\n\n\n\n\nREPL Examples\n\n\nThe other kind of doctest is a simulated Julia REPL session. The following format is detected by Lapidary as a REPL doctest:\n\n\n```julia\njulia\n a = 1;\n\njulia\n b = 2\n2\n\njulia\n a + b\n3\n\n```\n\n\n\n\n\nAs with script doctests, the code block must have it's language set to \njulia\n. When a code block contains one or more \njulia\n at the start of a line then it is assumed to be a REPL doctest. Semi-colons, \n;\n, at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.\n\n\nNote that not all features of the REPL are supported such as shell and help modes.\n\n\n\n\nSkipping Doctests\n\n\nDoctesting can be disabled by setting the \nmakedocs\n keyword \ndoctest = false\n. This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.\n\n\n\n\nSetup Code\n\n\nDoctests may require some setup code that must be evaluated prior to that of the actual example, but that should not be displayed in the final documentation. It could also be that several separate doctests require the same definitions. For both of these cases a \n{meta}\n block containing a \nDocTestSetup = ...\n value can be used as follows:\n\n\n```\njulia\n\n\njulia\n \nusing\n \nDataFrames\n\n\n\njulia\n \ndf\n \n=\n \nDataFrame\n(\nA\n \n=\n \n1\n:10\n,\n \nB\n \n=\n \n2\n:2:20\n);\n\n\n\n```\n\n\n\nSome\n \ntext\n \ndiscussing\n \n`\ndf\n`\n...\n\n\n    \n{\nmeta\n}\n\n    \nDocTestSetup\n \n=\n \nquote\n\n        \nusing\n \nDataFrames\n\n        \ndf\n \n=\n \nDataFrame\n(\nA\n \n=\n \n1\n:10\n,\n \nB\n \n=\n \n2\n:2:20\n)\n\n    \nend\n\n\n\n```\njulia\n\n\njulia\n \ndf\n[\n1\n,\n \n1\n]\n\n\n1\n\n\n```\n\n\n\nSome\n \nmore\n \ntext\n...\n\n\n\n```\njulia\n\n\njulia\n \ndf\n[\n1\n,\n \n:\n]\n\n\n1x2\n \nDataFrames\n.DataFrame\n\n\n|\n \nRow\n \n|\n \nA\n \n|\n \nB\n \n|\n\n\n|\n-----\n|\n---\n|\n---\n|\n\n\n|\n \n1\n   \n|\n \n1\n \n|\n \n2\n \n|\n\n\n```\n\n\n    \n{\nmeta\n}\n\n    \nDocTestSetup\n \n=\n \nnothing\n\n\n\n\n\n\nNote that the \nDocTestSetup\n value is \nre-evaluated\n at the start of \neach\n doctest block and no state is shared between any code blocks. The \nDocTestSetup = nothing\n is not strictly necessary, but good practice nonetheless to help avoid unintentional definitions later on a page.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/doctests/#doctests", 
            "text": "Lapidary will, by default, try to run Julia code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Lapidary's doctest.  This section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/doctests/#script-examples", 
            "text": "The first, of two, types of doctests is the \"script\" code block. To make Lapidary detect this kind of code block the following format must be used:  ```julia\na = 1\nb = 2\na + b\n\n# output\n\n3\n```  The code block's \"language\" must be  julia  and must include a line containing the text  # output . The text before this line is the contents of the script which is run. The text that appears after  # output  is the textual representation that would be shown in the Julia REPL if the script had been  include d.  The actual output produced by running the \"script\" is compared to the expected result and any difference will result in  makedocs  throwing an error and terminating.  Note that the amount of whitespace appearing above and below the  # output  line is not significant and can be increased or decreased if desired.", 
            "title": "\"Script\" Examples"
        }, 
        {
            "location": "/man/doctests/#repl-examples", 
            "text": "The other kind of doctest is a simulated Julia REPL session. The following format is detected by Lapidary as a REPL doctest:  ```julia\njulia  a = 1;\n\njulia  b = 2\n2\n\njulia  a + b\n3\n\n```  As with script doctests, the code block must have it's language set to  julia . When a code block contains one or more  julia  at the start of a line then it is assumed to be a REPL doctest. Semi-colons,  ; , at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.  Note that not all features of the REPL are supported such as shell and help modes.", 
            "title": "REPL Examples"
        }, 
        {
            "location": "/man/doctests/#skipping-doctests", 
            "text": "Doctesting can be disabled by setting the  makedocs  keyword  doctest = false . This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.", 
            "title": "Skipping Doctests"
        }, 
        {
            "location": "/man/doctests/#setup-code", 
            "text": "Doctests may require some setup code that must be evaluated prior to that of the actual example, but that should not be displayed in the final documentation. It could also be that several separate doctests require the same definitions. For both of these cases a  {meta}  block containing a  DocTestSetup = ...  value can be used as follows:  ``` julia  julia   using   DataFrames  julia   df   =   DataFrame ( A   =   1 :10 ,   B   =   2 :2:20 );  ```  Some   text   discussing   ` df ` ... \n\n     { meta } \n     DocTestSetup   =   quote \n         using   DataFrames \n         df   =   DataFrame ( A   =   1 :10 ,   B   =   2 :2:20 ) \n     end  ``` julia  julia   df [ 1 ,   1 ]  1  ```  Some   more   text ...  ``` julia  julia   df [ 1 ,   : ]  1x2   DataFrames .DataFrame  |   Row   |   A   |   B   |  | ----- | --- | --- |  |   1     |   1   |   2   |  ``` \n\n     { meta } \n     DocTestSetup   =   nothing   Note that the  DocTestSetup  value is  re-evaluated  at the start of  each  doctest block and no state is shared between any code blocks. The  DocTestSetup = nothing  is not strictly necessary, but good practice nonetheless to help avoid unintentional definitions later on a page.", 
            "title": "Setup Code"
        }, 
        {
            "location": "/man/hosting/", 
            "text": "Hosting Documentation\n\n\nAfter going through the \nPackage Guide\n and \nDoctests\n page you will need to host the generated documentation somewhere for potential users to read. This guide will describe how to setup automatic updates for your package docs using the Travis build service and GitHub Pages. This is the same approach used by this package to host it's own docs \u2013 the docs you're currently reading.\n\n\nNote\n\n\nThis guide assumes that you already have GitHub and Travis accounts setup. If not then go set those up first and then return here.\n\n\n\n\nOverview\n\n\nOnce setup correctly the following will happen each time you push new updates to your package repository:\n\n\n\n\ntravis buildbots startup and run your tests;\n\n\neach buildbot will build the package docs using your \ndocs/make.jl\n script;\n\n\na single buildbot will then try to push the generated docs back the github.\n\n\n\n\nThe following sections outline how to enable this for your own package.\n\n\n\n\nGitHub Security Key\n\n\nFirstly, generate a new \npersonal access token\n.\n\n\nEnter a description for this new token. We'll be calling ours \"Travis\", but any other name will do. For the \"Select scopes\" option choose \"public_repo\" \nonly\n. Then generate the token and save it somewhere safe. We'll be needing it during the next section.\n\n\n\n\nTravis Environment Settings\n\n\nNext we'll add the generated token to our repository's Travis page. Go to the settings page for the repository and under the \"Environment Variables\" section add a new variable called \nGITHUB_API_KEY\n. Copy the generated key from the \nGitHub Security Key\n section as the value and \nmake sure\n that \"Display value in build log\" is \noff\n. Then add the key.\n\n\n\n\n.travis.yml\n Configuration\n\n\nTo allow Travis to install the extra dependencies needed to build our docs add the following to your \n.travis.yml\n file in your package:\n\n\nbefore_script\n:\n\n  \n-\n \nexport PATH=$HOME/.local/bin:$PATH\n\n\n\n\n\n\nIn the \nafter_success\n section of the \n.travis.yml\n file, where code coverage is processed, run your \ndocs/make.jl\n file:\n\n\nafter_success\n:\n\n  \n-\n \njulia -e \nPkg.clone(\nhttps://github.com/MichaelHatherly/Lapidary.jl\n)\n\n  \n-\n \njulia -e \ncd(Pkg.dir(\nPACKAGE_NAME\n)); include(joinpath(\ndocs\n, \nmake.jl\n))\n\n\n\n\n\n\nNote that once the package is registered in \nMETADATA.jl\n the \nPkg.clone\n call can be replaced with \nPkg.add(\"Lapidary\")\n.\n\n\n\n\nThe \ndeploydocs\n Function\n\n\nAt the moment your \ndocs/make.jl\n file probably only contains\n\n\nusing\n \nLapidary\n,\n \nPACKAGE_NAME\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nWe'll need to add an additional call to this file after \nmakedocs\n. Add the following at the end of the file:\n\n\ndeploydocs\n(\n\n    \nrepo\n \n=\n \ngithub.com/USER_NAME/PACKAGE_NAME.jl.git\n\n\n)\n\n\n\n\n\n\nwhere \nUSER_NAME\n and \nPACKAGE_NAME\n must be set to the appropriate names.\n\n\nBy default \ndeploydocs\n will deploy the documentation from the \nnightly\n Julia build for Linux. This can be changed using the \njulia\n and \nosname\n keywords as follows:\n\n\ndeploydocs\n(\n\n    \nrepo\n   \n=\n \ngithub.com/USER_NAME/PACKAGE_NAME.jl.git\n,\n\n    \njulia\n  \n=\n \n0.4\n,\n\n    \nosname\n \n=\n \nosx\n\n\n)\n\n\n\n\n\n\nThis will deploy the docs from the OSX Julia 0.4 Travis build bot.\n\n\nSee the \ndeploydocs\n function documentation for more details.\n\n\n\n\nThe MkDocs \nmkdocs.yml\n File\n\n\nWe'll be using \nMkDocs\n to convert the markdown files generated by Lapidary to HTML. (This, of course, is not the only option you have for this step. Any markdown to HTML converter should work fine with some amount of setting up.)\n\n\nAdd an \nmkdocs.yml\n file to your \ndocs/\n directory with the following content:\n\n\nsite_name\n:\n        \nPACKAGE_NAME.jl\n\n\nrepo_url\n:\n         \nhttps://github.com/USER_NAME/PACKAGE_NAME.jl\n\n\nsite_description\n:\n \nDescription...\n\n\nsite_author\n:\n      \nUSER_NAME\n\n\n\ntheme\n:\n \nreadthedocs\n\n\n\nextra_css\n:\n\n  \n-\n \nassets/Lapidary.css\n\n\n\nextra_javascript\n:\n\n  \n-\n \nhttps://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML\n\n  \n-\n \nassets/mathjaxhelper.js\n\n\n\nmarkdown_extensions\n:\n\n  \n-\n \nextra\n\n  \n-\n \ntables\n\n  \n-\n \nfenced_code\n\n\n\ndocs_dir\n:\n \nbuild\n\n\n\npages\n:\n\n  \n-\n \nHome\n:\n \nindex.md\n\n\n\n\n\n\nThis is only a basic skeleton. Read through the MkDocs documentation if you would like to know more about the available settings.\n\n\n\n\n.gitignore\n\n\nAdd the following to your package's \n.gitignore\n file\n\n\ndocs/build/\ndocs/site/\n\n\n\n\n\nThese are needed to avoid committing generated content to your repository.\n\n\n\n\ngh-pages\n Branch\n\n\nCreate a new branch called \ngh-pages\n and push it to GitHub. If this branch already exists then you can skip this step, but do note that the generated content is automatically pushed to this branch from Travis.\n\n\n\n\nDocumentation Versions\n\n\nWhen documentation is generated it is stored in one of the following folders:\n\n\n\n\n\n\nlatest\n stores the most recent documentation that is committed to the \nmaster\n branch.\n\n\n\n\n\n\nstable\n stores the most recent documentation from a tagged commit. Older tagged versions   are stored in directories named after their tags. These tagged directories are persistent   and must be manually removed from the \ngh-pages\n branch if necessary.\n\n\n\n\n\n\n\n\nFinal Remarks\n\n\nThat should be all that is needed to enable automatic documentation building. Pushing new commits to your \nmaster\n branch should trigger doc builds. Note that other branches do not trigger these builds and neither do pull requests by potential contributors.\n\n\nIf you would like to see a more complete example of how this process is setup then take a look at this package's repository for some inspiration.", 
            "title": "Hosting Documentation"
        }, 
        {
            "location": "/man/hosting/#hosting-documentation", 
            "text": "After going through the  Package Guide  and  Doctests  page you will need to host the generated documentation somewhere for potential users to read. This guide will describe how to setup automatic updates for your package docs using the Travis build service and GitHub Pages. This is the same approach used by this package to host it's own docs \u2013 the docs you're currently reading.  Note  This guide assumes that you already have GitHub and Travis accounts setup. If not then go set those up first and then return here.", 
            "title": "Hosting Documentation"
        }, 
        {
            "location": "/man/hosting/#overview", 
            "text": "Once setup correctly the following will happen each time you push new updates to your package repository:   travis buildbots startup and run your tests;  each buildbot will build the package docs using your  docs/make.jl  script;  a single buildbot will then try to push the generated docs back the github.   The following sections outline how to enable this for your own package.", 
            "title": "Overview"
        }, 
        {
            "location": "/man/hosting/#github-security-key", 
            "text": "Firstly, generate a new  personal access token .  Enter a description for this new token. We'll be calling ours \"Travis\", but any other name will do. For the \"Select scopes\" option choose \"public_repo\"  only . Then generate the token and save it somewhere safe. We'll be needing it during the next section.", 
            "title": "GitHub Security Key"
        }, 
        {
            "location": "/man/hosting/#travis-environment-settings", 
            "text": "Next we'll add the generated token to our repository's Travis page. Go to the settings page for the repository and under the \"Environment Variables\" section add a new variable called  GITHUB_API_KEY . Copy the generated key from the  GitHub Security Key  section as the value and  make sure  that \"Display value in build log\" is  off . Then add the key.", 
            "title": "Travis Environment Settings"
        }, 
        {
            "location": "/man/hosting/#travisyml-configuration", 
            "text": "To allow Travis to install the extra dependencies needed to build our docs add the following to your  .travis.yml  file in your package:  before_script : \n   -   export PATH=$HOME/.local/bin:$PATH   In the  after_success  section of the  .travis.yml  file, where code coverage is processed, run your  docs/make.jl  file:  after_success : \n   -   julia -e  Pkg.clone( https://github.com/MichaelHatherly/Lapidary.jl ) \n   -   julia -e  cd(Pkg.dir( PACKAGE_NAME )); include(joinpath( docs ,  make.jl ))   Note that once the package is registered in  METADATA.jl  the  Pkg.clone  call can be replaced with  Pkg.add(\"Lapidary\") .", 
            "title": ".travis.yml Configuration"
        }, 
        {
            "location": "/man/hosting/#the-deploydocs-function", 
            "text": "At the moment your  docs/make.jl  file probably only contains  using   Lapidary ,   PACKAGE_NAME  makedocs ()   We'll need to add an additional call to this file after  makedocs . Add the following at the end of the file:  deploydocs ( \n     repo   =   github.com/USER_NAME/PACKAGE_NAME.jl.git  )   where  USER_NAME  and  PACKAGE_NAME  must be set to the appropriate names.  By default  deploydocs  will deploy the documentation from the  nightly  Julia build for Linux. This can be changed using the  julia  and  osname  keywords as follows:  deploydocs ( \n     repo     =   github.com/USER_NAME/PACKAGE_NAME.jl.git , \n     julia    =   0.4 , \n     osname   =   osx  )   This will deploy the docs from the OSX Julia 0.4 Travis build bot.  See the  deploydocs  function documentation for more details.", 
            "title": "The deploydocs Function"
        }, 
        {
            "location": "/man/hosting/#the-mkdocs-mkdocsyml-file", 
            "text": "We'll be using  MkDocs  to convert the markdown files generated by Lapidary to HTML. (This, of course, is not the only option you have for this step. Any markdown to HTML converter should work fine with some amount of setting up.)  Add an  mkdocs.yml  file to your  docs/  directory with the following content:  site_name :          PACKAGE_NAME.jl  repo_url :           https://github.com/USER_NAME/PACKAGE_NAME.jl  site_description :   Description...  site_author :        USER_NAME  theme :   readthedocs  extra_css : \n   -   assets/Lapidary.css  extra_javascript : \n   -   https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML \n   -   assets/mathjaxhelper.js  markdown_extensions : \n   -   extra \n   -   tables \n   -   fenced_code  docs_dir :   build  pages : \n   -   Home :   index.md   This is only a basic skeleton. Read through the MkDocs documentation if you would like to know more about the available settings.", 
            "title": "The MkDocs mkdocs.yml File"
        }, 
        {
            "location": "/man/hosting/#gitignore", 
            "text": "Add the following to your package's  .gitignore  file  docs/build/\ndocs/site/  These are needed to avoid committing generated content to your repository.", 
            "title": ".gitignore"
        }, 
        {
            "location": "/man/hosting/#gh-pages-branch", 
            "text": "Create a new branch called  gh-pages  and push it to GitHub. If this branch already exists then you can skip this step, but do note that the generated content is automatically pushed to this branch from Travis.", 
            "title": "gh-pages Branch"
        }, 
        {
            "location": "/man/hosting/#documentation-versions", 
            "text": "When documentation is generated it is stored in one of the following folders:    latest  stores the most recent documentation that is committed to the  master  branch.    stable  stores the most recent documentation from a tagged commit. Older tagged versions   are stored in directories named after their tags. These tagged directories are persistent   and must be manually removed from the  gh-pages  branch if necessary.     Final Remarks  That should be all that is needed to enable automatic documentation building. Pushing new commits to your  master  branch should trigger doc builds. Note that other branches do not trigger these builds and neither do pull requests by potential contributors.  If you would like to see a more complete example of how this process is setup then take a look at this package's repository for some inspiration.", 
            "title": "Documentation Versions"
        }, 
        {
            "location": "/man/internals/", 
            "text": "Package Internals", 
            "title": "Internals"
        }, 
        {
            "location": "/man/internals/#package-internals", 
            "text": "", 
            "title": "Package Internals"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\n#\nLapidary.makedocs\n \n \nFunction\n.\n\n\n\n\nmakedocs(\n    root    = \ncurrent-directory\n,\n    source  = \nsrc\n,\n    build   = \nbuild\n,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n)\n\n\n\n\n\nCombines markdown files and inline docstrings into an interlinked document.\n\n\nIn most cases \nmakedocs\n should be run from a \nmake.jl\n file:\n\n\nusing\n \nLapidary\n\n\n\nmakedocs\n(\n\n    \n# keywords...\n\n\n)\n\n\n\n\n\n\nwhich is then run from the command line with:\n\n\n$ julia make.jl\n\n\n\n\n\nThe folder structure that \nmakedocs\n expects looks like:\n\n\ndocs/\n    build/\n    src/\n    make.jl\n\n\n\n\n\nKeywords\n\n\nroot\n is the directory from which \nmakedocs\n should run. When run from a \nmake.jl\n file this keyword does not need to be set. It is, for the most part, needed when repeatedly running \nmakedocs\n from the Julia REPL like so:\n\n\njulia\n makedocs(root = Pkg.dir(\nMyPackage\n, \ndocs\n))\n\n\n\n\n\nsource\n is the directory, relative to \nroot\n, where the markdown source files are read from. By convention this folder is called \nsrc\n. Note that any non-markdown files stored in \nsource\n are copied over to the build directory when \nmakedocs\n is run.\n\n\nbuild\n is the directory, relative to \nroot\n, into which generated files and folders are written when \nmakedocs\n is run. The name of the build directory is, by convention, called \nbuild\n, though, like with \nsource\n, users are free to change this to anything else to better suit their project needs.\n\n\nclean\n tells \nmakedocs\n whether to remove all the content from the \nbuild\n folder prior to generating new content from \nsource\n. By default this is set to \ntrue\n.\n\n\ndoctest\n instructs \nmakedocs\n on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to \ntrue\n. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the \nDoctests\n manual section for details about running doctests.\n\n\nmodules\n specifies a vector of modules that should be documented in \nsource\n. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of \nmakedocs\n. By default no modules are passed to \nmodules\n and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation.\n\n\nFor example Lapidary's \nmake.jl\n file contains:\n\n\nusing\n \nLapidary\n\n\n\n# Build documentation.\n\n\n# ====================\n\n\n\nmakedocs\n(\n\n    \n# options\n\n    \nmodules\n \n=\n \n[\nLapidary\n],\n\n    \nclean\n   \n=\n \nfalse\n\n\n)\n\n\n\n# Deploy built documentation from Travis.\n\n\n# =======================================\n\n\n\n# Needs to install an additional dep, mkdocs-material, so provide a custom `deps`.\n\n\ncustom_deps\n()\n \n=\n \nrun\n(\n`pip install --user pygments mkdocs mkdocs-material`\n)\n\n\n\ndeploydocs\n(\n\n    \n# options\n\n    \ndeps\n \n=\n \ncustom_deps\n,\n\n    \nrepo\n \n=\n \ngithub.com/MichaelHatherly/Lapidary.jl.git\n\n\n)\n\n\n\n\n\n\nand so any docstring from the module \nLapidary\n that is not spliced into the generated documentation in \nbuild\n will raise a warning.\n\n\nSee Also\n\n\nA guide detailing how to document a package using Lapidary's \nmakedocs\n is provided in the \nUsage\n section of the manual.\n\n\n#\nLapidary.deploydocs\n \n \nFunction\n.\n\n\n\n\ndeploydocs(\n    root   = \ncurrent-directory\n,\n    target = \nsite\n,\n    repo   = \nrequired\n,\n    branch = \ngh-pages\n,\n    latest = \nmaster\n,\n    osname = \nlinux\n,\n    julia  = \nnightly\n,\n    deps   = \nFunction\n,\n    make   = \nFunction\n,\n)\n\n\n\n\n\nConverts markdown files generated by \nmakedocs\n to HTML and pushes them to \nrepo\n.\n\n\nThis function should be called from within a package's \ndocs/make.jl\n file after the call to \nmakedocs\n, like so\n\n\nusing\n \nLapidary\n,\n \nPACKAGE_NAME\n\n\n\nmakedocs\n(\n\n    \n# options...\n\n\n)\n\n\n\ndeploydocs\n(\n\n    \nrepo\n \n=\n \ngithub.com/...\n\n\n)\n\n\n\n\n\n\nKeywords\n\n\nroot\n has the same purpose as the \nroot\n keyword for \nmakedocs\n.\n\n\ntarget\n is the directory, relative to \nroot\n, where generated HTML content should be written to. This directory \nmust\n be added to the repository's \n.gitignore\n file. The default value is \n\"site\"\n.\n\n\nrepo\n is the remote repository where generated HTML content should be pushed to. This keyword \nmust\n be set and will throw an error when left undefined. For example this package uses the following \nrepo\n value:\n\n\nrepo = \ngithub.com/MichaelHatherly/Lapidary.jl.git\n\n\n\n\n\n\nbranch\n is the branch where the generated documentation is pushed. By default this value is set to \n\"gh-pages\"\n.\n\n\nlatest\n is the branch that \"tracks\" the latest generated documentation. By default this value is set to \n\"master\"\n.\n\n\nosname\n is the operating system which will be used to deploy generated documentation. This defaults to \n\"linux\"\n. This value must be one of those specified in the \nos:\n section of the \n.travis.yml\n configuration file.\n\n\njulia\n is the version of Julia that will be used to deploy generated documentation. This defaults to \n\"nightly\"\n. This value must be one of those specified in the \njulia:\n section of the \n.travis.yml\n configuration file.\n\n\ndeps\n is the function used to install any dependancies needed to build the documentation. By default this function installs \npygments\n and \nmkdocs\n:\n\n\ndeps = () -\n run(`pip install --user pygments mkdocs`)\n\n\n\n\n\nmake\n is the function used to convert the markdown files to HTML. By default this just runs \nmkdocs build\n which populates the \ntarget\n directory.\n\n\nSee Also\n\n\nThe \nHosting Documentation\n section of the manual provides a step-by-step guide to using the \ndeploydocs\n function to automatically generate docs and push then to GitHub.", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "# Lapidary.makedocs     Function .   makedocs(\n    root    =  current-directory ,\n    source  =  src ,\n    build   =  build ,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n)  Combines markdown files and inline docstrings into an interlinked document.  In most cases  makedocs  should be run from a  make.jl  file:  using   Lapidary  makedocs ( \n     # keywords...  )   which is then run from the command line with:  $ julia make.jl  The folder structure that  makedocs  expects looks like:  docs/\n    build/\n    src/\n    make.jl  Keywords  root  is the directory from which  makedocs  should run. When run from a  make.jl  file this keyword does not need to be set. It is, for the most part, needed when repeatedly running  makedocs  from the Julia REPL like so:  julia  makedocs(root = Pkg.dir( MyPackage ,  docs ))  source  is the directory, relative to  root , where the markdown source files are read from. By convention this folder is called  src . Note that any non-markdown files stored in  source  are copied over to the build directory when  makedocs  is run.  build  is the directory, relative to  root , into which generated files and folders are written when  makedocs  is run. The name of the build directory is, by convention, called  build , though, like with  source , users are free to change this to anything else to better suit their project needs.  clean  tells  makedocs  whether to remove all the content from the  build  folder prior to generating new content from  source . By default this is set to  true .  doctest  instructs  makedocs  on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to  true . Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the  Doctests  manual section for details about running doctests.  modules  specifies a vector of modules that should be documented in  source . If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of  makedocs . By default no modules are passed to  modules  and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation.  For example Lapidary's  make.jl  file contains:  using   Lapidary  # Build documentation.  # ====================  makedocs ( \n     # options \n     modules   =   [ Lapidary ], \n     clean     =   false  )  # Deploy built documentation from Travis.  # =======================================  # Needs to install an additional dep, mkdocs-material, so provide a custom `deps`.  custom_deps ()   =   run ( `pip install --user pygments mkdocs mkdocs-material` )  deploydocs ( \n     # options \n     deps   =   custom_deps , \n     repo   =   github.com/MichaelHatherly/Lapidary.jl.git  )   and so any docstring from the module  Lapidary  that is not spliced into the generated documentation in  build  will raise a warning.  See Also  A guide detailing how to document a package using Lapidary's  makedocs  is provided in the  Usage  section of the manual.  # Lapidary.deploydocs     Function .   deploydocs(\n    root   =  current-directory ,\n    target =  site ,\n    repo   =  required ,\n    branch =  gh-pages ,\n    latest =  master ,\n    osname =  linux ,\n    julia  =  nightly ,\n    deps   =  Function ,\n    make   =  Function ,\n)  Converts markdown files generated by  makedocs  to HTML and pushes them to  repo .  This function should be called from within a package's  docs/make.jl  file after the call to  makedocs , like so  using   Lapidary ,   PACKAGE_NAME  makedocs ( \n     # options...  )  deploydocs ( \n     repo   =   github.com/...  )   Keywords  root  has the same purpose as the  root  keyword for  makedocs .  target  is the directory, relative to  root , where generated HTML content should be written to. This directory  must  be added to the repository's  .gitignore  file. The default value is  \"site\" .  repo  is the remote repository where generated HTML content should be pushed to. This keyword  must  be set and will throw an error when left undefined. For example this package uses the following  repo  value:  repo =  github.com/MichaelHatherly/Lapidary.jl.git   branch  is the branch where the generated documentation is pushed. By default this value is set to  \"gh-pages\" .  latest  is the branch that \"tracks\" the latest generated documentation. By default this value is set to  \"master\" .  osname  is the operating system which will be used to deploy generated documentation. This defaults to  \"linux\" . This value must be one of those specified in the  os:  section of the  .travis.yml  configuration file.  julia  is the version of Julia that will be used to deploy generated documentation. This defaults to  \"nightly\" . This value must be one of those specified in the  julia:  section of the  .travis.yml  configuration file.  deps  is the function used to install any dependancies needed to build the documentation. By default this function installs  pygments  and  mkdocs :  deps = () -  run(`pip install --user pygments mkdocs`)  make  is the function used to convert the markdown files to HTML. By default this just runs  mkdocs build  which populates the  target  directory.  See Also  The  Hosting Documentation  section of the manual provides a step-by-step guide to using the  deploydocs  function to automatically generate docs and push then to GitHub.", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internal Documentation\n\n\n\n\nTypes\n\n\n#\nLapidary.State\n \n \nType\n.\n\n\n\n\nUsed to store the current state of the markdown template expansion. This simplifies the \nexpand\n methods by avoiding having to thread all the state between each call manually.\n\n\n#\nLapidary.Path\n \n \nType\n.\n\n\n\n\nRepresents a file mapping from source file \n.src\n to destination file \n.dst\n.\n\n\n#\nLapidary.ParsedPath\n \n \nType\n.\n\n\n\n\nSame as \nPath\n, but also includes the parsed content of the markdown file.\n\n\n#\nLapidary.HeaderPath\n \n \nType\n.\n\n\n\n\nRepresents a file mapping from \n.src\n to \n.dst\n of a markdown header element. The \n.nth\n field tracks the ordering of the headers within the file.\n\n\n#\nLapidary.Env\n \n \nType\n.\n\n\n\n\nStores all the state associated with a document. An instance of this type is threaded through the sequence of transformations used to build the document.\n\n\nEnv(kwargs...)\n\n\n\n\n\nHelper method used to simplidy the construction of \nEnv\n objects. Takes any number of keyword arguments. Note that unknown keyword arguments are discarded by this method.\n\n\n\n\nStages\n\n\n#\nLapidary.SetupBuildDirectory\n \n \nType\n.\n\n\n\n\nCleans out previous \nbuild\n directory and rebuilds the folder structure to match that of the \nsrc\n directory. Copies all non-markdown files from \nsrc\n to \nbuild\n.\n\n\n#\nLapidary.CopyAssetsDirectory\n \n \nType\n.\n\n\n\n\nCopies the contents of the Lapidary \nassets\n folder to \nbuild/assets\n.\n\n\nWill throw an error if the directory already exists.\n\n\n#\nLapidary.ParseTemplates\n \n \nType\n.\n\n\n\n\nReads the contents of each markdown file found in \nsrc\n and them into \nMarkdown.MD\n objects using \nMarkdown.parse\n.\n\n\n#\nLapidary.ExpandTemplates\n \n \nType\n.\n\n\n\n\nRuns all the expanders stored in \n.expanders\n on each element of the parsed markdown files.\n\n\n#\nLapidary.RunDocTests\n \n \nType\n.\n\n\n\n\nFinds all code blocks in an expanded document where the language is set to \njulia\n and tries to run them. Any failure will currently just terminate the entire document generation.\n\n\nNotes\n\n\nThis stage can be disabled in \nmakedocs\n by setting the keyword \ndoctest = false\n.\n\n\n#\nLapidary.CheckDocs\n \n \nType\n.\n\n\n\n\nConsistency checks for the generated documentation. Have all the available docs from the specified modules been added to the external docs?\n\n\n#\nLapidary.CrossReferenceLinks\n \n \nType\n.\n\n\n\n\nFinds all \nMarkdown.Link\n elements in an expanded document and tries to find where the link should point to. Will terminate the entire document generation process when a link cannot successfully be found.\n\n\n#\nLapidary.RenderDocument\n \n \nType\n.\n\n\n\n\nWrite the contents of the expanded document tree to file. Currently only supports markdown output.\n\n\n\n\nExpanders\n\n\n#\nLapidary.expand\n \n \nFunction\n.\n\n\n\n\nExpand a single element, \nblock\n, of a markdown file.\n\n\n#\nLapidary.DefaultExpander\n \n \nType\n.\n\n\n\n\nBy default block expansion just pushes the block onto the end of the vector of expanded blocks.\n\n\n#\nLapidary.FindHeaders\n \n \nType\n.\n\n\n\n\nAn expander that tracks all header elements in a document. The data gathered by this expander is used in later stages to build cross-reference links and tables of contents.\n\n\n#\nLapidary.MetaBlock\n \n \nType\n.\n\n\n\n\nExpands markdown code blocks where the first line contains \n{meta}\n. The expander parses the contents of the block expecting key/value pairs such as\n\n\n{meta}\nCurrentModule = Lapidary\n\n\n\n\n\nNote that all syntax used in the block must be valid Julia syntax.\n\n\n#\nLapidary.MetaNode\n \n \nType\n.\n\n\n\n\nStores the parsed and evaluated key/value pairs found in a \n{meta}\n block.\n\n\n#\nLapidary.DocsBlock\n \n \nType\n.\n\n\n\n\nExpands code blocks where the first line contains \n{docs}\n. Subsequent lines should be names of objects whose documentation should be retrieved from the Julia docsystem.\n\n\n{docs}\nfoo\nbar(x, y)\nBaz.@baz\n\n\n\n\n\nEach object is evaluated in the \ncurrent_module()\n or \nCurrentModule\n if that has been set in a \n{meta}\n block of the current page prior to the \n{docs}\n block.\n\n\n#\nLapidary.DocsNode\n \n \nType\n.\n\n\n\n\nStores the object and related docstring for a single object found in a \n{docs}\n block. When a \n{docs}\n block contains multiple entries then each one is expanded into a separate \nDocsNode\n.\n\n\n#\nLapidary.EvalBlock\n \n \nType\n.\n\n\n\n\nExpands code blocks where the first line constains \n{eval}\n. Subsequent lines are evalutated and the final result is used in place of the code block.\n\n\nThis expander block should be used when custom content should be generated such as plots or other external data that must appear in the final documentation.\n\n\n#\nLapidary.IndexBlock\n \n \nType\n.\n\n\n\n\nExpands code blocks where the first line contains \n{index}\n. Subsequent lines can contain key/value pairs relevant to the index. Currently \nPages = [\"...\", ..., \"...\"]\n is supported for filtering the contents of the index based on source page.\n\n\nIndexes are used to display links to all the docstrings, generated with \n{docs}\n blocks, on any number of pages.\n\n\n#\nLapidary.IndexNode\n \n \nType\n.\n\n\n\n\n{index}\n code blocks are expanded into this object which is used to store the key/value pairs needed to build the actual index during the later rendering state.\n\n\n#\nLapidary.ContentsBlock\n \n \nType\n.\n\n\n\n\nExpands code blocks where the first line contains \n{contents}\n. Subsequent lines can, like the \n{index}\n block, contains key/value pairs. Supported pairs are\n\n\nPages = [\n...\n, ..., \n...\n]\nDepth = 2\n\n\n\n\n\nwhere \nPages\n acts the same as for \n{index}\n and \nDepth\n limits the header level displayed in the generated contents.\n\n\nContents blocks are used to a display nested list of the headers found in one or more pages.\n\n\n#\nLapidary.ContentsNode\n \n \nType\n.\n\n\n\n\n{contents}\n blocks are expanded into these objects, which, like with \nIndexNode\n, store the key/value pairs needed to render the contents during the later rendering stage.\n\n\n\n\nUtilities\n\n\n#\nLapidary.car\n \n \nFunction\n.\n\n\n\n\ncar(x::Tuple)\n\n\n\n\n\nHead element of the \nTuple\n \nx\n. See also \ncdr\n.\n\n\n#\nLapidary.cdr\n \n \nFunction\n.\n\n\n\n\ncdr(x::Tuple)\n\n\n\n\n\nTail elements of the \nTuple\n \nx\n. See also \ncar\n.\n\n\n#\nLapidary.assetsdir\n \n \nFunction\n.\n\n\n\n\nassetsdir()\n\n\n\n\n\nDirectory containing Lapidary asset files.\n\n\n#\nLapidary.currentdir\n \n \nFunction\n.\n\n\n\n\ncurrentdir()\n\n\n\n\n\nReturns the current source directory. When \nisinteractive() \u2261 true\n then the present working directory, \npwd()\n is returned instead.\n\n\n#\nLapidary.walk\n \n \nFunction\n.\n\n\n\n\nwalk(f::Function, meta::Dict, element)\n\n\n\n\n\nScan a document tree and run function \nf\n on each \nelement\n that is encountered.\n\n\n#\nLapidary.log\n \n \nFunction\n.\n\n\n\n\nlog(io::IO, msg::AbstractString)\nlog(msg::AbstractString)\n\n\n\n\n\nPrint a formatted message to \nSTDOUT\n. Each document \"stage\" type must provide an implementation of this function.\n\n\n#\nLapidary.process\n \n \nFunction\n.\n\n\n\n\nprocess(env, stages...)\n\n\n\n\n\nFor each stage in \nstages\n execute stage with the given \nenv\n as it's argument.\n\n\n#\nLapidary.parseblock\n \n \nFunction\n.\n\n\n\n\nparseblock\n(\ncode\n:\n:AbstractString\n;\n \nskip\n \n=\n \n0\n)\n\n\n\n\n\n\nReturns an array of (expression, string) tuples for each complete toplevel expression from \ncode\n. The \nskip\n keyword argument will drop the provided number of leading lines.\n\n\n#\nLapidary.nodocs\n \n \nFunction\n.\n\n\n\n\nDoes the document returned from the docsystem contain any useful documentation.\n\n\n#\nLapidary.doctest\n \n \nFunction\n.\n\n\n\n\ndoctest(source::Markdown.Code)\n\n\n\n\n\nTry to run the Julia source code found in \nsource\n.\n\n\n#\nLapidary.slugify\n \n \nFunction\n.\n\n\n\n\nSlugify a string \ns\n by removing special characters. Used in the url generation process.", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#internal-documentation", 
            "text": "", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/lib/internals/#types", 
            "text": "# Lapidary.State     Type .   Used to store the current state of the markdown template expansion. This simplifies the  expand  methods by avoiding having to thread all the state between each call manually.  # Lapidary.Path     Type .   Represents a file mapping from source file  .src  to destination file  .dst .  # Lapidary.ParsedPath     Type .   Same as  Path , but also includes the parsed content of the markdown file.  # Lapidary.HeaderPath     Type .   Represents a file mapping from  .src  to  .dst  of a markdown header element. The  .nth  field tracks the ordering of the headers within the file.  # Lapidary.Env     Type .   Stores all the state associated with a document. An instance of this type is threaded through the sequence of transformations used to build the document.  Env(kwargs...)  Helper method used to simplidy the construction of  Env  objects. Takes any number of keyword arguments. Note that unknown keyword arguments are discarded by this method.", 
            "title": "Types"
        }, 
        {
            "location": "/lib/internals/#stages", 
            "text": "# Lapidary.SetupBuildDirectory     Type .   Cleans out previous  build  directory and rebuilds the folder structure to match that of the  src  directory. Copies all non-markdown files from  src  to  build .  # Lapidary.CopyAssetsDirectory     Type .   Copies the contents of the Lapidary  assets  folder to  build/assets .  Will throw an error if the directory already exists.  # Lapidary.ParseTemplates     Type .   Reads the contents of each markdown file found in  src  and them into  Markdown.MD  objects using  Markdown.parse .  # Lapidary.ExpandTemplates     Type .   Runs all the expanders stored in  .expanders  on each element of the parsed markdown files.  # Lapidary.RunDocTests     Type .   Finds all code blocks in an expanded document where the language is set to  julia  and tries to run them. Any failure will currently just terminate the entire document generation.  Notes  This stage can be disabled in  makedocs  by setting the keyword  doctest = false .  # Lapidary.CheckDocs     Type .   Consistency checks for the generated documentation. Have all the available docs from the specified modules been added to the external docs?  # Lapidary.CrossReferenceLinks     Type .   Finds all  Markdown.Link  elements in an expanded document and tries to find where the link should point to. Will terminate the entire document generation process when a link cannot successfully be found.  # Lapidary.RenderDocument     Type .   Write the contents of the expanded document tree to file. Currently only supports markdown output.", 
            "title": "Stages"
        }, 
        {
            "location": "/lib/internals/#expanders", 
            "text": "# Lapidary.expand     Function .   Expand a single element,  block , of a markdown file.  # Lapidary.DefaultExpander     Type .   By default block expansion just pushes the block onto the end of the vector of expanded blocks.  # Lapidary.FindHeaders     Type .   An expander that tracks all header elements in a document. The data gathered by this expander is used in later stages to build cross-reference links and tables of contents.  # Lapidary.MetaBlock     Type .   Expands markdown code blocks where the first line contains  {meta} . The expander parses the contents of the block expecting key/value pairs such as  {meta}\nCurrentModule = Lapidary  Note that all syntax used in the block must be valid Julia syntax.  # Lapidary.MetaNode     Type .   Stores the parsed and evaluated key/value pairs found in a  {meta}  block.  # Lapidary.DocsBlock     Type .   Expands code blocks where the first line contains  {docs} . Subsequent lines should be names of objects whose documentation should be retrieved from the Julia docsystem.  {docs}\nfoo\nbar(x, y)\nBaz.@baz  Each object is evaluated in the  current_module()  or  CurrentModule  if that has been set in a  {meta}  block of the current page prior to the  {docs}  block.  # Lapidary.DocsNode     Type .   Stores the object and related docstring for a single object found in a  {docs}  block. When a  {docs}  block contains multiple entries then each one is expanded into a separate  DocsNode .  # Lapidary.EvalBlock     Type .   Expands code blocks where the first line constains  {eval} . Subsequent lines are evalutated and the final result is used in place of the code block.  This expander block should be used when custom content should be generated such as plots or other external data that must appear in the final documentation.  # Lapidary.IndexBlock     Type .   Expands code blocks where the first line contains  {index} . Subsequent lines can contain key/value pairs relevant to the index. Currently  Pages = [\"...\", ..., \"...\"]  is supported for filtering the contents of the index based on source page.  Indexes are used to display links to all the docstrings, generated with  {docs}  blocks, on any number of pages.  # Lapidary.IndexNode     Type .   {index}  code blocks are expanded into this object which is used to store the key/value pairs needed to build the actual index during the later rendering state.  # Lapidary.ContentsBlock     Type .   Expands code blocks where the first line contains  {contents} . Subsequent lines can, like the  {index}  block, contains key/value pairs. Supported pairs are  Pages = [ ... , ...,  ... ]\nDepth = 2  where  Pages  acts the same as for  {index}  and  Depth  limits the header level displayed in the generated contents.  Contents blocks are used to a display nested list of the headers found in one or more pages.  # Lapidary.ContentsNode     Type .   {contents}  blocks are expanded into these objects, which, like with  IndexNode , store the key/value pairs needed to render the contents during the later rendering stage.", 
            "title": "Expanders"
        }, 
        {
            "location": "/lib/internals/#utilities", 
            "text": "# Lapidary.car     Function .   car(x::Tuple)  Head element of the  Tuple   x . See also  cdr .  # Lapidary.cdr     Function .   cdr(x::Tuple)  Tail elements of the  Tuple   x . See also  car .  # Lapidary.assetsdir     Function .   assetsdir()  Directory containing Lapidary asset files.  # Lapidary.currentdir     Function .   currentdir()  Returns the current source directory. When  isinteractive() \u2261 true  then the present working directory,  pwd()  is returned instead.  # Lapidary.walk     Function .   walk(f::Function, meta::Dict, element)  Scan a document tree and run function  f  on each  element  that is encountered.  # Lapidary.log     Function .   log(io::IO, msg::AbstractString)\nlog(msg::AbstractString)  Print a formatted message to  STDOUT . Each document \"stage\" type must provide an implementation of this function.  # Lapidary.process     Function .   process(env, stages...)  For each stage in  stages  execute stage with the given  env  as it's argument.  # Lapidary.parseblock     Function .   parseblock ( code : :AbstractString ;   skip   =   0 )   Returns an array of (expression, string) tuples for each complete toplevel expression from  code . The  skip  keyword argument will drop the provided number of leading lines.  # Lapidary.nodocs     Function .   Does the document returned from the docsystem contain any useful documentation.  # Lapidary.doctest     Function .   doctest(source::Markdown.Code)  Try to run the Julia source code found in  source .  # Lapidary.slugify     Function .   Slugify a string  s  by removing special characters. Used in the url generation process.", 
            "title": "Utilities"
        }
    ]
}