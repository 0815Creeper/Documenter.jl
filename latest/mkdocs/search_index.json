{
    "docs": [
        {
            "location": "/", 
            "text": "Lapidary.jl\n\n\nA documentation generator for Julia.\n\n\nA package for building documentation from docstrings and markdown files.\n\n\n\n\nPackage Features\n\n\n\n\nMinimal configuration.\n\n\nSupports Julia \n0.4\n and \n0.5-dev\n.\n\n\nDoctests Julia code blocks.\n\n\nCross references for docs and section headers.\n\n\nChecks for missing docstrings and incorrect cross references.\n\n\nGenerates tables of contents and docstring indexes.\n\n\nUse \ngit push\n to automatically build and deploy docs from Travis to GitHub Pages.\n\n\n\n\nThe \nPackage Guide\n provides a tutorial explaining how to get started using Lapidary.\n\n\nSee the \nIndex\n for the complete list of documented functions and types.\n\n\n\n\nManual Outline\n\n\n\n\nPackage Guide\n\n\nInstallation\n\n\nUsage\n\n\n\n\n\n\nSyntax\n\n\n{ref}\n\n\n{docs}\n\n\n{meta}\n\n\n{index}\n\n\n{contents}\n\n\n{eval}\n\n\n\n\n\n\nDoctests\n\n\n\"Script\" Examples\n\n\nREPL Examples\n\n\nSkipping Doctests\n\n\nSetup Code\n\n\n\n\n\n\nHosting Documentation\n\n\nOverview\n\n\nGitHub Security Key\n\n\nTravis Environment Settings\n\n\n.travis.yml\n Configuration\n\n\nThe \ndeploydocs\n Function\n\n\nThe MkDocs \nmkdocs.yml\n File\n\n\n.gitignore\n\n\ngh-pages\n Branch\n\n\nDocumentation Versions\n\n\n\n\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nLapidary\n\n\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\nAnchors\n\n\nBuilder\n\n\nCrossReferences\n\n\nDocChecks\n\n\nDocuments\n\n\nExpanders\n\n\nFormats\n\n\nWalkers\n\n\nWriters\n\n\nUtilities\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nLapidary\n\n\nLapidary.deploydocs\n\n\nLapidary.makedocs\n\n\nLapidary.Anchors\n\n\nLapidary.Anchors.Anchor\n\n\nLapidary.Anchors.AnchorMap\n\n\nLapidary.Anchors.add!\n\n\nLapidary.Anchors.anchor\n\n\nLapidary.Anchors.exists\n\n\nLapidary.Anchors.isunique\n\n\nLapidary.Builder\n\n\nLapidary.Builder.CheckDocument\n\n\nLapidary.Builder.ContentsBlocks\n\n\nLapidary.Builder.CopyAssetsDirectory\n\n\nLapidary.Builder.CrossReferences\n\n\nLapidary.Builder.DocsBlocks\n\n\nLapidary.Builder.EvalBlocks\n\n\nLapidary.Builder.ExpandTemplates\n\n\nLapidary.Builder.IndexBlocks\n\n\nLapidary.Builder.MetaBlocks\n\n\nLapidary.Builder.RenderDocument\n\n\nLapidary.Builder.SetupBuildDirectory\n\n\nLapidary.Builder.TrackHeaders\n\n\nLapidary.CrossReferences\n\n\nLapidary.CrossReferences.crossref\n\n\nLapidary.DocChecks\n\n\nLapidary.DocChecks.doctest\n\n\nLapidary.DocChecks.missingdocs\n\n\nLapidary.Documents\n\n\nLapidary.Documents.Document\n\n\nLapidary.Documents.Globals\n\n\nLapidary.Documents.Internal\n\n\nLapidary.Documents.Page\n\n\nLapidary.Documents.User\n\n\nLapidary.Expanders\n\n\nLapidary.Expanders.expand\n\n\nLapidary.Formats\n\n\nLapidary.Formats.Format\n\n\nLapidary.Formats.mimetype\n\n\nLapidary.Utilities\n\n\nLapidary.Utilities.Object\n\n\nLapidary.Utilities.assetsdir\n\n\nLapidary.Utilities.check_kwargs\n\n\nLapidary.Utilities.currentdir\n\n\nLapidary.Utilities.doccat\n\n\nLapidary.Utilities.docs\n\n\nLapidary.Utilities.filterdocs\n\n\nLapidary.Utilities.log\n\n\nLapidary.Utilities.logging\n\n\nLapidary.Utilities.nodocs\n\n\nLapidary.Utilities.object\n\n\nLapidary.Utilities.parseblock\n\n\nLapidary.Utilities.slugify\n\n\nLapidary.Utilities.submodules\n\n\nLapidary.Utilities.warn\n\n\nLapidary.Walkers\n\n\nLapidary.Walkers.walk\n\n\nLapidary.Writers\n\n\nLapidary.Writers.render", 
            "title": "Home"
        }, 
        {
            "location": "/#lapidaryjl", 
            "text": "A documentation generator for Julia.  A package for building documentation from docstrings and markdown files.", 
            "title": "Lapidary.jl"
        }, 
        {
            "location": "/#package-features", 
            "text": "Minimal configuration.  Supports Julia  0.4  and  0.5-dev .  Doctests Julia code blocks.  Cross references for docs and section headers.  Checks for missing docstrings and incorrect cross references.  Generates tables of contents and docstring indexes.  Use  git push  to automatically build and deploy docs from Travis to GitHub Pages.   The  Package Guide  provides a tutorial explaining how to get started using Lapidary.  See the  Index  for the complete list of documented functions and types.", 
            "title": "Package Features"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "Package Guide  Installation  Usage    Syntax  {ref}  {docs}  {meta}  {index}  {contents}  {eval}    Doctests  \"Script\" Examples  REPL Examples  Skipping Doctests  Setup Code    Hosting Documentation  Overview  GitHub Security Key  Travis Environment Settings  .travis.yml  Configuration  The  deploydocs  Function  The MkDocs  mkdocs.yml  File  .gitignore  gh-pages  Branch  Documentation Versions", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/#library-outline", 
            "text": "Public Documentation  Contents  Index  Lapidary    Internal Documentation  Contents  Index  Anchors  Builder  CrossReferences  DocChecks  Documents  Expanders  Formats  Walkers  Writers  Utilities", 
            "title": "Library Outline"
        }, 
        {
            "location": "/#index", 
            "text": "Lapidary  Lapidary.deploydocs  Lapidary.makedocs  Lapidary.Anchors  Lapidary.Anchors.Anchor  Lapidary.Anchors.AnchorMap  Lapidary.Anchors.add!  Lapidary.Anchors.anchor  Lapidary.Anchors.exists  Lapidary.Anchors.isunique  Lapidary.Builder  Lapidary.Builder.CheckDocument  Lapidary.Builder.ContentsBlocks  Lapidary.Builder.CopyAssetsDirectory  Lapidary.Builder.CrossReferences  Lapidary.Builder.DocsBlocks  Lapidary.Builder.EvalBlocks  Lapidary.Builder.ExpandTemplates  Lapidary.Builder.IndexBlocks  Lapidary.Builder.MetaBlocks  Lapidary.Builder.RenderDocument  Lapidary.Builder.SetupBuildDirectory  Lapidary.Builder.TrackHeaders  Lapidary.CrossReferences  Lapidary.CrossReferences.crossref  Lapidary.DocChecks  Lapidary.DocChecks.doctest  Lapidary.DocChecks.missingdocs  Lapidary.Documents  Lapidary.Documents.Document  Lapidary.Documents.Globals  Lapidary.Documents.Internal  Lapidary.Documents.Page  Lapidary.Documents.User  Lapidary.Expanders  Lapidary.Expanders.expand  Lapidary.Formats  Lapidary.Formats.Format  Lapidary.Formats.mimetype  Lapidary.Utilities  Lapidary.Utilities.Object  Lapidary.Utilities.assetsdir  Lapidary.Utilities.check_kwargs  Lapidary.Utilities.currentdir  Lapidary.Utilities.doccat  Lapidary.Utilities.docs  Lapidary.Utilities.filterdocs  Lapidary.Utilities.log  Lapidary.Utilities.logging  Lapidary.Utilities.nodocs  Lapidary.Utilities.object  Lapidary.Utilities.parseblock  Lapidary.Utilities.slugify  Lapidary.Utilities.submodules  Lapidary.Utilities.warn  Lapidary.Walkers  Lapidary.Walkers.walk  Lapidary.Writers  Lapidary.Writers.render", 
            "title": "Index"
        }, 
        {
            "location": "/man/guide/", 
            "text": "Package Guide\n\n\n\n\nInstallation\n\n\nLapidary is currently not registered and so must be installed via \nPkg.clone\n.\n\n\nPkg\n.\nclone\n(\nhttps://github.com/MichaelHatherly/Lapidary.jl\n)\n\n\n\n\n\n\nThis package supports Julia \n0.4\n and \n0.5\n.\n\n\n\n\nUsage\n\n\nLapidary is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.\n\n\n\n\nSetting up the folder structure\n\n\nFirstly, we need a Julia module to document. This could be a package generated via \nPkgDev.generate\n or a single \n.jl\n script. For this guide we'll be using a package called \nExample.jl\n that has the following directory layout:\n\n\nExample/\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nNote that the \n...\n just represent unimportant files and folders.\n\n\nWe must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named \ndocs/\n in the toplevel of the package, like so\n\n\nExample/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...\n\n\n\n\n\nInside the \ndocs/\n folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended\n\n\ndocs/\n    src/\n    make.jl\n\n\n\n\n\n\n\nBuilding an empty document\n\n\nWith our \ndocs/\n directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.\n\n\nAdd the following to your \nmake.jl\n file\n\n\nusing\n \nLapidary\n,\n \nExample\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nThis assumes you've installed Lapidary as discussed in \nInstallation\n and that your Examples package can be found by Julia.\n\n\nNow add an \nindex.md\n file to the \nsrc/\n directory. The name has no particular significance though and you may name it whatever you like. We'll stick to \nindex.md\n for this guide.\n\n\nLeave the newly added file empty and the run the following command from the \ndocs/\n directory\n\n\n$ julia make.jl\n\n\n\n\n\nNote that \n$\n just represents the prompt character. You don't need to type that.\n\n\nIf you'd like to see the output from this command in color use\n\n\n$ julia --color\n=\nyes make.jl\n\n\n\n\n\nWe you run that you should see the following output\n\n\nLAPIDARY\n:\n \nsetting\n \nup\n \nbuild\n \ndirectory\n.\n\n\nLAPIDARY\n:\n \ncopying\n \nassets\n \nto\n \nbuild\n \ndirectory\n.\n\n\nLAPIDARY\n:\n \nexpanding\n \nmarkdown\n \ntemplates\n.\n\n\nLAPIDARY\n:\n \nbuilding\n \ncross\n-\nreferences\n.\n\n\nLAPIDARY\n:\n \nrunning\n \ndocument\n \nchecks\n.\n\n\nLAPIDARY\n:\n \nrendering\n \ndocument\n.\n\n\n\n\n\n\nThe \ndocs/\n folder should contain a new directory \u2013 called \nbuild/\n. It's structure should look like the following\n\n\nbuild/\n    assets/\n        Lapidary.css\n        mathjaxhelper.js\n    index.md\n\n\n\n\n\nAt the moment \nbuild/index.md\n should be empty since \nsrc/index.md\n is empty.\n\n\nAt this point you can add some text to \nsrc/index.md\n and rerun the \nmake.jl\n file to see the changes if you'd like to.\n\n\n\n\nAdding some docstrings\n\n\nNext we'll splice a docstring defined in the \nExample\n module into the \nindex.md\n file. To do this first document a function in that module:\n\n\nmodule\n \nExample\n\n\n\nexport\n \nfunc\n\n\n\n\n\n    func(x)\n\n\n\nReturns double the number `x` plus `1`.\n\n\n\n\nfunc\n(\nx\n)\n \n=\n \n2\nx\n \n+\n \n1\n\n\n\nend\n\n\n\n\n\n\nThen in the \nsrc/index.md\n file add the following\n\n\n# Example.jl Documentation\n\n    {docs}\n    func(x)\n\n\n\n\n\nWhen we next run \nmake.jl\n the docstring for \nExample.func(x)\n should appear in place of the \n{docs}\n block in \nbuild/index.md\n. Note that \nmore than one\n object can be referenced inside a \n{docs}\n block \u2013 just place each one on a separate line.\n\n\nNote that the module in which a \n{docs}\n block is evaluated is determined by \ncurrent_module()\n and so will more than likely be \nMain\n. This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a \n{meta}\n block as in the following\n\n\n# Example.jl Documentation\n\n    {meta}\n    CurrentModule = Lapidary\n\n...\n\n    {docs}\n    func(x)\n\n\n\n\n\nNote that the \n...\n in the example above is just there to stop the code blocks from merging into a single block. You could use fenced code blocks instead to avoid needing to have to break up the blocks using extra text.\n\n\n\n\nFiltering Included Docstrings\n\n\nIn some cases you may want to include a docstring for a \nMethod\n that extends a \nFunction\n from a different module \u2013 such as \nBase\n. In the following example we extend \nBase.length\n with a new definition for type \nT\n and also add a docstring:\n\n\ntype\n T\n\n    \n# ...\n\n\nend\n\n\n\n\n\nCustom `length` docs for `T`.\n\n\n\n\nBase\n.\nlength\n(::\nT\n)\n \n=\n \n1\n\n\n\n\n\n\nWhen trying to include this docstring with\n\n\n    {docs}\n    length\n\n\n\n\n\nall the docs for \nlength\n will be included \u2013 even those from other modules. There are two ways to solve this problem. Either include the type in the signature with\n\n\n    {docs}\n    length(::T)\n\n\n\n\n\nor declare the specific modules that \nmakedocs\n should include with\n\n\nmakedocs\n(\n\n    \n# options\n\n    \nmodules\n \n=\n \n[\nMyModule\n]\n\n\n)\n\n\n\n\n\n\n\n\nCross Referencing\n\n\nIt may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Lapidary's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of \nsrc/index.md\n with the following\n\n\n# Example.jl Documentation\n\n    {docs}\n    func(x)\n\n- link to [Example.jl Documentation]({ref})\n- link to [`func(x)`]({ref})\n\n\n\n\n\nSo we just have to replace each link's url with \n{ref}\n and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.\n\n\nThis also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.\n\n\n\n\nNavigation\n\n\nLapidary can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our \nindex.md\n file from the previous sections. Add the following to that file\n\n\n# Example.jl Documentation\n\n    {contents}\n\n## Functions\n\n    {docs}\n    func(x)\n\n## Index\n\n    {index}\n\n\n\n\n\nThe \n{contents}\n block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using \nPages\n and \nDepth\n settings as in the following\n\n\n    {contents}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n    Depth = 3\n\n\n\n\n\nThe \n{index}\n block will generate a flat list of links to all the docs that that have been spliced into the document using \n{docs}\n blocks. As with the \n{contents}\n block the pages to be included can be set with a \nPages = [...]\n line. Since the list is not nested \nDepth\n is not supported for \n{index}\n.", 
            "title": "Guide"
        }, 
        {
            "location": "/man/guide/#package-guide", 
            "text": "", 
            "title": "Package Guide"
        }, 
        {
            "location": "/man/guide/#installation", 
            "text": "Lapidary is currently not registered and so must be installed via  Pkg.clone .  Pkg . clone ( https://github.com/MichaelHatherly/Lapidary.jl )   This package supports Julia  0.4  and  0.5 .", 
            "title": "Installation"
        }, 
        {
            "location": "/man/guide/#usage", 
            "text": "Lapidary is designed to do one thing \u2013 combine markdown files and inline docstrings from Julia's docsystem into a single inter-linked document. What follows is a step-by-step guide to creating a simple document.", 
            "title": "Usage"
        }, 
        {
            "location": "/man/guide/#setting-up-the-folder-structure", 
            "text": "Firstly, we need a Julia module to document. This could be a package generated via  PkgDev.generate  or a single  .jl  script. For this guide we'll be using a package called  Example.jl  that has the following directory layout:  Example/\n    src/\n        Example.jl\n    ...  Note that the  ...  just represent unimportant files and folders.  We must decide on a location where we'd like to store the documentation for this package. It's recommended to use a folder named  docs/  in the toplevel of the package, like so  Example/\n    docs/\n        ...\n    src/\n        Example.jl\n    ...  Inside the  docs/  folder we need to add two things. A source folder which will contain the markdown files that will be used to build the finished document and a Julia script that will be used to control the build process. The following names are recommended  docs/\n    src/\n    make.jl", 
            "title": "Setting up the folder structure"
        }, 
        {
            "location": "/man/guide/#building-an-empty-document", 
            "text": "With our  docs/  directory now setup we're going to build our first document. It'll just be a single empty file at the moment, but we'll be adding to it later on.  Add the following to your  make.jl  file  using   Lapidary ,   Example  makedocs ()   This assumes you've installed Lapidary as discussed in  Installation  and that your Examples package can be found by Julia.  Now add an  index.md  file to the  src/  directory. The name has no particular significance though and you may name it whatever you like. We'll stick to  index.md  for this guide.  Leave the newly added file empty and the run the following command from the  docs/  directory  $ julia make.jl  Note that  $  just represents the prompt character. You don't need to type that.  If you'd like to see the output from this command in color use  $ julia --color = yes make.jl  We you run that you should see the following output  LAPIDARY :   setting   up   build   directory .  LAPIDARY :   copying   assets   to   build   directory .  LAPIDARY :   expanding   markdown   templates .  LAPIDARY :   building   cross - references .  LAPIDARY :   running   document   checks .  LAPIDARY :   rendering   document .   The  docs/  folder should contain a new directory \u2013 called  build/ . It's structure should look like the following  build/\n    assets/\n        Lapidary.css\n        mathjaxhelper.js\n    index.md  At the moment  build/index.md  should be empty since  src/index.md  is empty.  At this point you can add some text to  src/index.md  and rerun the  make.jl  file to see the changes if you'd like to.", 
            "title": "Building an empty document"
        }, 
        {
            "location": "/man/guide/#adding-some-docstrings", 
            "text": "Next we'll splice a docstring defined in the  Example  module into the  index.md  file. To do this first document a function in that module:  module   Example  export   func       func(x)  Returns double the number `x` plus `1`.   func ( x )   =   2 x   +   1  end   Then in the  src/index.md  file add the following  # Example.jl Documentation\n\n    {docs}\n    func(x)  When we next run  make.jl  the docstring for  Example.func(x)  should appear in place of the  {docs}  block in  build/index.md . Note that  more than one  object can be referenced inside a  {docs}  block \u2013 just place each one on a separate line.  Note that the module in which a  {docs}  block is evaluated is determined by  current_module()  and so will more than likely be  Main . This means that each object listed in the block must be visible there. The module can be changed to something else on a per-page basis with a  {meta}  block as in the following  # Example.jl Documentation\n\n    {meta}\n    CurrentModule = Lapidary\n\n...\n\n    {docs}\n    func(x)  Note that the  ...  in the example above is just there to stop the code blocks from merging into a single block. You could use fenced code blocks instead to avoid needing to have to break up the blocks using extra text.", 
            "title": "Adding some docstrings"
        }, 
        {
            "location": "/man/guide/#filtering-included-docstrings", 
            "text": "In some cases you may want to include a docstring for a  Method  that extends a  Function  from a different module \u2013 such as  Base . In the following example we extend  Base.length  with a new definition for type  T  and also add a docstring:  type  T \n     # ...  end   Custom `length` docs for `T`.   Base . length (:: T )   =   1   When trying to include this docstring with      {docs}\n    length  all the docs for  length  will be included \u2013 even those from other modules. There are two ways to solve this problem. Either include the type in the signature with      {docs}\n    length(::T)  or declare the specific modules that  makedocs  should include with  makedocs ( \n     # options \n     modules   =   [ MyModule ]  )", 
            "title": "Filtering Included Docstrings"
        }, 
        {
            "location": "/man/guide/#cross-referencing", 
            "text": "It may be necessary to refer to a particular docstring or section of your document from elsewhere in the document. To do this we can make use of Lapidary's cross-referencing syntax which looks pretty similar to normal markdown link syntax. Replace the contents of  src/index.md  with the following  # Example.jl Documentation\n\n    {docs}\n    func(x)\n\n- link to [Example.jl Documentation]({ref})\n- link to [`func(x)`]({ref})  So we just have to replace each link's url with  {ref}  and write the name of the thing we'd link to cross-reference. For document headers it's just plain text that matches the name of the header and for docstrings enclose the object in backticks.  This also works across different pages in the same way. Note that these sections and docstrings must be unique within a document.", 
            "title": "Cross Referencing"
        }, 
        {
            "location": "/man/guide/#navigation", 
            "text": "Lapidary can auto-generate tables of contents and docstring indexes for your document with the following syntax. We'll illustrate these features using our  index.md  file from the previous sections. Add the following to that file  # Example.jl Documentation\n\n    {contents}\n\n## Functions\n\n    {docs}\n    func(x)\n\n## Index\n\n    {index}  The  {contents}  block will generate a nested list of links to all the section headers in the document. By default it will gather all the level 1 and 2 headers from every page in the document, but this can be adjusted using  Pages  and  Depth  settings as in the following      {contents}\n    Pages = [ foo.md ,  bar.md ]\n    Depth = 3  The  {index}  block will generate a flat list of links to all the docs that that have been spliced into the document using  {docs}  blocks. As with the  {contents}  block the pages to be included can be set with a  Pages = [...]  line. Since the list is not nested  Depth  is not supported for  {index} .", 
            "title": "Navigation"
        }, 
        {
            "location": "/man/syntax/", 
            "text": "Syntax\n\n\nThis section of the manual summarises the special syntax used by Lapidary.\n\n\n\n\n{ref}\n\n\nUsed in markdown links as the url to tell Lapidary to generate a cross-reference automatically. The text part of the link can be either a docstring or header name.\n\n\n[Foo]({ref})   # Link to the section called \nFoo\n.\n[`bar`]({ref}) # Link to the docstring called `bar`.\n\n\n\n\n\n\n\n{docs}\n\n\nSplice a collection of docstrings into a document.\n\n\n    {docs}\n    Foo\n    bar(x)\n    @baz(x, y)\n\n\n\n\n\n\n\n{meta}\n\n\nUsed to define any number of metadata key/value pairs that can then be used elsewhere in the page. Currently \nCurrentModule = ...\n is the only recognised pair.\n\n\n    {meta}\n    CurrentModule = FooBar\n\n\n\n\n\n\n\n{index}\n\n\nGenerates a list of links to docstrings that have been spliced into a document. The only valid setting is currently \nPages = ...\n.\n\n\n    {index}\n    Pages = [\nfoo.md\n]\n\n\n\n\n\nWhen \nPages\n is not provided all pages in the document are included.\n\n\n\n\n{contents}\n\n\nGenerates a nested list of links to document sections. Valid settings are \nPages\n and \nDepth\n.\n\n\n    {contents}\n    Pages = [\nfoo.md\n]\n    Depth = 5\n\n\n\n\n\nAs with \n{index}\n if \nPages\n is not provided then all pages are included. The default \nDepth\n value is \n2\n.\n\n\n\n\n{eval}\n\n\nEvaluates the contents of the block and inserts the resulting value into the final document.\n\n\nIn the following example we use the PyPlot package to generate a plot and display it in the final document.\n\n\n    {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color = \nred\n)\n    savefig(\nplot.svg\n)\n\n    nothing\n\n![](plot.svg)\n\n\n\n\n\nNote that each \n{eval}\n block evaluates its contents within a separate module. When evaluating each block the present working directory, \npwd\n, is set to the directory in \nbuild\n where the file will be written to.\n\n\nAlso, instead of returning \nnothing\n in the example above we could have returned a new \nMarkdown.Image\n object directly. This can be more appropriate when the filename is not known until evaluation of the block itself.", 
            "title": "Syntax"
        }, 
        {
            "location": "/man/syntax/#syntax", 
            "text": "This section of the manual summarises the special syntax used by Lapidary.", 
            "title": "Syntax"
        }, 
        {
            "location": "/man/syntax/#ref", 
            "text": "Used in markdown links as the url to tell Lapidary to generate a cross-reference automatically. The text part of the link can be either a docstring or header name.  [Foo]({ref})   # Link to the section called  Foo .\n[`bar`]({ref}) # Link to the docstring called `bar`.", 
            "title": "{ref}"
        }, 
        {
            "location": "/man/syntax/#docs", 
            "text": "Splice a collection of docstrings into a document.      {docs}\n    Foo\n    bar(x)\n    @baz(x, y)", 
            "title": "{docs}"
        }, 
        {
            "location": "/man/syntax/#meta", 
            "text": "Used to define any number of metadata key/value pairs that can then be used elsewhere in the page. Currently  CurrentModule = ...  is the only recognised pair.      {meta}\n    CurrentModule = FooBar", 
            "title": "{meta}"
        }, 
        {
            "location": "/man/syntax/#index", 
            "text": "Generates a list of links to docstrings that have been spliced into a document. The only valid setting is currently  Pages = ... .      {index}\n    Pages = [ foo.md ]  When  Pages  is not provided all pages in the document are included.", 
            "title": "{index}"
        }, 
        {
            "location": "/man/syntax/#contents", 
            "text": "Generates a nested list of links to document sections. Valid settings are  Pages  and  Depth .      {contents}\n    Pages = [ foo.md ]\n    Depth = 5  As with  {index}  if  Pages  is not provided then all pages are included. The default  Depth  value is  2 .", 
            "title": "{contents}"
        }, 
        {
            "location": "/man/syntax/#eval", 
            "text": "Evaluates the contents of the block and inserts the resulting value into the final document.  In the following example we use the PyPlot package to generate a plot and display it in the final document.      {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color =  red )\n    savefig( plot.svg )\n\n    nothing\n\n![](plot.svg)  Note that each  {eval}  block evaluates its contents within a separate module. When evaluating each block the present working directory,  pwd , is set to the directory in  build  where the file will be written to.  Also, instead of returning  nothing  in the example above we could have returned a new  Markdown.Image  object directly. This can be more appropriate when the filename is not known until evaluation of the block itself.", 
            "title": "{eval}"
        }, 
        {
            "location": "/man/doctests/", 
            "text": "Doctests\n\n\nLapidary will, by default, try to run Julia code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Lapidary's doctest.\n\n\nThis section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.\n\n\n\n\n\"Script\" Examples\n\n\nThe first, of two, types of doctests is the \"script\" code block. To make Lapidary detect this kind of code block the following format must be used:\n\n\n```julia\na = 1\nb = 2\na + b\n\n# output\n\n3\n```\n\n\n\n\n\nThe code block's \"language\" must be \njulia\n and must include a line containing the text \n# output\n. The text before this line is the contents of the script which is run. The text that appears after \n# output\n is the textual representation that would be shown in the Julia REPL if the script had been \ninclude\nd.\n\n\nThe actual output produced by running the \"script\" is compared to the expected result and any difference will result in \nmakedocs\n throwing an error and terminating.\n\n\nNote that the amount of whitespace appearing above and below the \n# output\n line is not significant and can be increased or decreased if desired.\n\n\n\n\nREPL Examples\n\n\nThe other kind of doctest is a simulated Julia REPL session. The following format is detected by Lapidary as a REPL doctest:\n\n\n```julia\njulia\n a = 1\n1\n\njulia\n b = 2;\n\njulia\n c = 3;  # comment\n\njulia\n a + b + c\n6\n\n```\n\n\n\n\n\nAs with script doctests, the code block must have it's language set to \njulia\n. When a code block contains one or more \njulia\n at the start of a line then it is assumed to be a REPL doctest. Semi-colons, \n;\n, at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.\n\n\nNote that not all features of the REPL are supported such as shell and help modes.\n\n\n\n\nSkipping Doctests\n\n\nDoctesting can be disabled by setting the \nmakedocs\n keyword \ndoctest = false\n. This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.\n\n\n\n\nSetup Code\n\n\nDoctests may require some setup code that must be evaluated prior to that of the actual example, but that should not be displayed in the final documentation. It could also be that several separate doctests require the same definitions. For both of these cases a \n{meta}\n block containing a \nDocTestSetup = ...\n value can be used as follows:\n\n\n```\njulia\n\n\njulia\n \nusing\n \nDataFrames\n\n\n\njulia\n \ndf\n \n=\n \nDataFrame\n(\nA\n \n=\n \n1\n:10\n,\n \nB\n \n=\n \n2\n:2:20\n);\n\n\n\n```\n\n\n\nSome\n \ntext\n \ndiscussing\n \n`\ndf\n`\n...\n\n\n    \n{\nmeta\n}\n\n    \nDocTestSetup\n \n=\n \nquote\n\n        \nusing\n \nDataFrames\n\n        \ndf\n \n=\n \nDataFrame\n(\nA\n \n=\n \n1\n:10\n,\n \nB\n \n=\n \n2\n:2:20\n)\n\n    \nend\n\n\n\n```\njulia\n\n\njulia\n \ndf\n[\n1\n,\n \n1\n]\n\n\n1\n\n\n```\n\n\n\nSome\n \nmore\n \ntext\n...\n\n\n\n```\njulia\n\n\njulia\n \ndf\n[\n1\n,\n \n:\n]\n\n\n1x2\n \nDataFrames\n.DataFrame\n\n\n|\n \nRow\n \n|\n \nA\n \n|\n \nB\n \n|\n\n\n|\n-----\n|\n---\n|\n---\n|\n\n\n|\n \n1\n   \n|\n \n1\n \n|\n \n2\n \n|\n\n\n```\n\n\n    \n{\nmeta\n}\n\n    \nDocTestSetup\n \n=\n \nnothing\n\n\n\n\n\n\nNote that the \nDocTestSetup\n value is \nre-evaluated\n at the start of \neach\n doctest block and no state is shared between any code blocks. The \nDocTestSetup = nothing\n is not strictly necessary, but good practice nonetheless to help avoid unintentional definitions later on a page.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/doctests/#doctests", 
            "text": "Lapidary will, by default, try to run Julia code blocks that it finds in the generated documentation. This can help to avoid documentation examples from becoming outdated, incorrect, or misleading. It's recommended that as many of a package's examples be runnable by Lapidary's doctest.  This section of the manual outlines how to go about enabling doctests for code blocks in your package's documentation.", 
            "title": "Doctests"
        }, 
        {
            "location": "/man/doctests/#script-examples", 
            "text": "The first, of two, types of doctests is the \"script\" code block. To make Lapidary detect this kind of code block the following format must be used:  ```julia\na = 1\nb = 2\na + b\n\n# output\n\n3\n```  The code block's \"language\" must be  julia  and must include a line containing the text  # output . The text before this line is the contents of the script which is run. The text that appears after  # output  is the textual representation that would be shown in the Julia REPL if the script had been  include d.  The actual output produced by running the \"script\" is compared to the expected result and any difference will result in  makedocs  throwing an error and terminating.  Note that the amount of whitespace appearing above and below the  # output  line is not significant and can be increased or decreased if desired.", 
            "title": "\"Script\" Examples"
        }, 
        {
            "location": "/man/doctests/#repl-examples", 
            "text": "The other kind of doctest is a simulated Julia REPL session. The following format is detected by Lapidary as a REPL doctest:  ```julia\njulia  a = 1\n1\n\njulia  b = 2;\n\njulia  c = 3;  # comment\n\njulia  a + b + c\n6\n\n```  As with script doctests, the code block must have it's language set to  julia . When a code block contains one or more  julia  at the start of a line then it is assumed to be a REPL doctest. Semi-colons,  ; , at the end of a line works in the same way as in the Julia REPL and will suppress the output, although the line is still evaluated.  Note that not all features of the REPL are supported such as shell and help modes.", 
            "title": "REPL Examples"
        }, 
        {
            "location": "/man/doctests/#skipping-doctests", 
            "text": "Doctesting can be disabled by setting the  makedocs  keyword  doctest = false . This should only be done when initially laying out the structure of a package's documentation, after which it's encouraged to always run doctests when building docs.", 
            "title": "Skipping Doctests"
        }, 
        {
            "location": "/man/doctests/#setup-code", 
            "text": "Doctests may require some setup code that must be evaluated prior to that of the actual example, but that should not be displayed in the final documentation. It could also be that several separate doctests require the same definitions. For both of these cases a  {meta}  block containing a  DocTestSetup = ...  value can be used as follows:  ``` julia  julia   using   DataFrames  julia   df   =   DataFrame ( A   =   1 :10 ,   B   =   2 :2:20 );  ```  Some   text   discussing   ` df ` ... \n\n     { meta } \n     DocTestSetup   =   quote \n         using   DataFrames \n         df   =   DataFrame ( A   =   1 :10 ,   B   =   2 :2:20 ) \n     end  ``` julia  julia   df [ 1 ,   1 ]  1  ```  Some   more   text ...  ``` julia  julia   df [ 1 ,   : ]  1x2   DataFrames .DataFrame  |   Row   |   A   |   B   |  | ----- | --- | --- |  |   1     |   1   |   2   |  ``` \n\n     { meta } \n     DocTestSetup   =   nothing   Note that the  DocTestSetup  value is  re-evaluated  at the start of  each  doctest block and no state is shared between any code blocks. The  DocTestSetup = nothing  is not strictly necessary, but good practice nonetheless to help avoid unintentional definitions later on a page.", 
            "title": "Setup Code"
        }, 
        {
            "location": "/man/hosting/", 
            "text": "Hosting Documentation\n\n\nAfter going through the \nPackage Guide\n and \nDoctests\n page you will need to host the generated documentation somewhere for potential users to read. This guide will describe how to setup automatic updates for your package docs using the Travis build service and GitHub Pages. This is the same approach used by this package to host it's own docs \u2013 the docs you're currently reading.\n\n\nNote\n\n\nThis guide assumes that you already have GitHub and Travis accounts setup. If not then go set those up first and then return here.\n\n\n\n\nOverview\n\n\nOnce setup correctly the following will happen each time you push new updates to your package repository:\n\n\n\n\ntravis buildbots startup and run your tests;\n\n\neach buildbot will build the package docs using your \ndocs/make.jl\n script;\n\n\na single buildbot will then try to push the generated docs back the github.\n\n\n\n\nThe following sections outline how to enable this for your own package.\n\n\n\n\nGitHub Security Key\n\n\nFirstly, generate a new \npersonal access token\n.\n\n\nEnter a description for this new token. We'll be calling ours \"Travis\", but any other name will do. For the \"Select scopes\" option choose \"public_repo\" \nonly\n. Then generate the token and save it somewhere safe. We'll be needing it during the next section.\n\n\n\n\nTravis Environment Settings\n\n\nNext we'll add the generated token to our repository's Travis page. Go to the settings page for the repository and under the \"Environment Variables\" section add a new variable called \nGITHUB_API_KEY\n. Copy the generated key from the \nGitHub Security Key\n section as the value and \nmake sure\n that \"Display value in build log\" is \noff\n. Then add the key.\n\n\n\n\n.travis.yml\n Configuration\n\n\nTo allow Travis to install the extra dependencies needed to build our docs add the following to your \n.travis.yml\n file in your package:\n\n\nbefore_script\n:\n\n  \n-\n \nexport PATH=$HOME/.local/bin:$PATH\n\n\n\n\n\n\nIn the \nafter_success\n section of the \n.travis.yml\n file, where code coverage is processed, run your \ndocs/make.jl\n file:\n\n\nafter_success\n:\n\n  \n-\n \njulia -e \nPkg.clone(\nhttps://github.com/MichaelHatherly/Lapidary.jl\n)\n\n  \n-\n \njulia -e \ncd(Pkg.dir(\nPACKAGE_NAME\n)); include(joinpath(\ndocs\n, \nmake.jl\n))\n\n\n\n\n\n\nNote that once the package is registered in \nMETADATA.jl\n the \nPkg.clone\n call can be replaced with \nPkg.add(\"Lapidary\")\n.\n\n\n\n\nThe \ndeploydocs\n Function\n\n\nAt the moment your \ndocs/make.jl\n file probably only contains\n\n\nusing\n \nLapidary\n,\n \nPACKAGE_NAME\n\n\n\nmakedocs\n()\n\n\n\n\n\n\nWe'll need to add an additional call to this file after \nmakedocs\n. Add the following at the end of the file:\n\n\ndeploydocs\n(\n\n    \nrepo\n \n=\n \ngithub.com/USER_NAME/PACKAGE_NAME.jl.git\n\n\n)\n\n\n\n\n\n\nwhere \nUSER_NAME\n and \nPACKAGE_NAME\n must be set to the appropriate names.\n\n\nBy default \ndeploydocs\n will deploy the documentation from the \nnightly\n Julia build for Linux. This can be changed using the \njulia\n and \nosname\n keywords as follows:\n\n\ndeploydocs\n(\n\n    \nrepo\n   \n=\n \ngithub.com/USER_NAME/PACKAGE_NAME.jl.git\n,\n\n    \njulia\n  \n=\n \n0.4\n,\n\n    \nosname\n \n=\n \nosx\n\n\n)\n\n\n\n\n\n\nThis will deploy the docs from the OSX Julia 0.4 Travis build bot.\n\n\nSee the \ndeploydocs\n function documentation for more details.\n\n\n\n\nThe MkDocs \nmkdocs.yml\n File\n\n\nWe'll be using \nMkDocs\n to convert the markdown files generated by Lapidary to HTML. (This, of course, is not the only option you have for this step. Any markdown to HTML converter should work fine with some amount of setting up.)\n\n\nAdd an \nmkdocs.yml\n file to your \ndocs/\n directory with the following content:\n\n\nsite_name\n:\n        \nPACKAGE_NAME.jl\n\n\nrepo_url\n:\n         \nhttps://github.com/USER_NAME/PACKAGE_NAME.jl\n\n\nsite_description\n:\n \nDescription...\n\n\nsite_author\n:\n      \nUSER_NAME\n\n\n\ntheme\n:\n \nreadthedocs\n\n\n\nextra_css\n:\n\n  \n-\n \nassets/Lapidary.css\n\n\n\nextra_javascript\n:\n\n  \n-\n \nhttps://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML\n\n  \n-\n \nassets/mathjaxhelper.js\n\n\n\nmarkdown_extensions\n:\n\n  \n-\n \nextra\n\n  \n-\n \ntables\n\n  \n-\n \nfenced_code\n\n\n\ndocs_dir\n:\n \nbuild\n\n\n\npages\n:\n\n  \n-\n \nHome\n:\n \nindex.md\n\n\n\n\n\n\nThis is only a basic skeleton. Read through the MkDocs documentation if you would like to know more about the available settings.\n\n\n\n\n.gitignore\n\n\nAdd the following to your package's \n.gitignore\n file\n\n\ndocs/build/\ndocs/site/\n\n\n\n\n\nThese are needed to avoid committing generated content to your repository.\n\n\n\n\ngh-pages\n Branch\n\n\nCreate a new branch called \ngh-pages\n and push it to GitHub. If this branch already exists then you can skip this step, but do note that the generated content is automatically pushed to this branch from Travis.\n\n\n\n\nDocumentation Versions\n\n\nWhen documentation is generated it is stored in one of the following folders:\n\n\n\n\n\n\nlatest\n stores the most recent documentation that is committed to the \nmaster\n branch.\n\n\n\n\n\n\nstable\n stores the most recent documentation from a tagged commit. Older tagged versions   are stored in directories named after their tags. These tagged directories are persistent   and must be manually removed from the \ngh-pages\n branch if necessary.\n\n\n\n\n\n\n\n\nFinal Remarks\n\n\nThat should be all that is needed to enable automatic documentation building. Pushing new commits to your \nmaster\n branch should trigger doc builds. Note that other branches do not trigger these builds and neither do pull requests by potential contributors.\n\n\nIf you would like to see a more complete example of how this process is setup then take a look at this package's repository for some inspiration.", 
            "title": "Hosting Documentation"
        }, 
        {
            "location": "/man/hosting/#hosting-documentation", 
            "text": "After going through the  Package Guide  and  Doctests  page you will need to host the generated documentation somewhere for potential users to read. This guide will describe how to setup automatic updates for your package docs using the Travis build service and GitHub Pages. This is the same approach used by this package to host it's own docs \u2013 the docs you're currently reading.  Note  This guide assumes that you already have GitHub and Travis accounts setup. If not then go set those up first and then return here.", 
            "title": "Hosting Documentation"
        }, 
        {
            "location": "/man/hosting/#overview", 
            "text": "Once setup correctly the following will happen each time you push new updates to your package repository:   travis buildbots startup and run your tests;  each buildbot will build the package docs using your  docs/make.jl  script;  a single buildbot will then try to push the generated docs back the github.   The following sections outline how to enable this for your own package.", 
            "title": "Overview"
        }, 
        {
            "location": "/man/hosting/#github-security-key", 
            "text": "Firstly, generate a new  personal access token .  Enter a description for this new token. We'll be calling ours \"Travis\", but any other name will do. For the \"Select scopes\" option choose \"public_repo\"  only . Then generate the token and save it somewhere safe. We'll be needing it during the next section.", 
            "title": "GitHub Security Key"
        }, 
        {
            "location": "/man/hosting/#travis-environment-settings", 
            "text": "Next we'll add the generated token to our repository's Travis page. Go to the settings page for the repository and under the \"Environment Variables\" section add a new variable called  GITHUB_API_KEY . Copy the generated key from the  GitHub Security Key  section as the value and  make sure  that \"Display value in build log\" is  off . Then add the key.", 
            "title": "Travis Environment Settings"
        }, 
        {
            "location": "/man/hosting/#travisyml-configuration", 
            "text": "To allow Travis to install the extra dependencies needed to build our docs add the following to your  .travis.yml  file in your package:  before_script : \n   -   export PATH=$HOME/.local/bin:$PATH   In the  after_success  section of the  .travis.yml  file, where code coverage is processed, run your  docs/make.jl  file:  after_success : \n   -   julia -e  Pkg.clone( https://github.com/MichaelHatherly/Lapidary.jl ) \n   -   julia -e  cd(Pkg.dir( PACKAGE_NAME )); include(joinpath( docs ,  make.jl ))   Note that once the package is registered in  METADATA.jl  the  Pkg.clone  call can be replaced with  Pkg.add(\"Lapidary\") .", 
            "title": ".travis.yml Configuration"
        }, 
        {
            "location": "/man/hosting/#the-deploydocs-function", 
            "text": "At the moment your  docs/make.jl  file probably only contains  using   Lapidary ,   PACKAGE_NAME  makedocs ()   We'll need to add an additional call to this file after  makedocs . Add the following at the end of the file:  deploydocs ( \n     repo   =   github.com/USER_NAME/PACKAGE_NAME.jl.git  )   where  USER_NAME  and  PACKAGE_NAME  must be set to the appropriate names.  By default  deploydocs  will deploy the documentation from the  nightly  Julia build for Linux. This can be changed using the  julia  and  osname  keywords as follows:  deploydocs ( \n     repo     =   github.com/USER_NAME/PACKAGE_NAME.jl.git , \n     julia    =   0.4 , \n     osname   =   osx  )   This will deploy the docs from the OSX Julia 0.4 Travis build bot.  See the  deploydocs  function documentation for more details.", 
            "title": "The deploydocs Function"
        }, 
        {
            "location": "/man/hosting/#the-mkdocs-mkdocsyml-file", 
            "text": "We'll be using  MkDocs  to convert the markdown files generated by Lapidary to HTML. (This, of course, is not the only option you have for this step. Any markdown to HTML converter should work fine with some amount of setting up.)  Add an  mkdocs.yml  file to your  docs/  directory with the following content:  site_name :          PACKAGE_NAME.jl  repo_url :           https://github.com/USER_NAME/PACKAGE_NAME.jl  site_description :   Description...  site_author :        USER_NAME  theme :   readthedocs  extra_css : \n   -   assets/Lapidary.css  extra_javascript : \n   -   https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML \n   -   assets/mathjaxhelper.js  markdown_extensions : \n   -   extra \n   -   tables \n   -   fenced_code  docs_dir :   build  pages : \n   -   Home :   index.md   This is only a basic skeleton. Read through the MkDocs documentation if you would like to know more about the available settings.", 
            "title": "The MkDocs mkdocs.yml File"
        }, 
        {
            "location": "/man/hosting/#gitignore", 
            "text": "Add the following to your package's  .gitignore  file  docs/build/\ndocs/site/  These are needed to avoid committing generated content to your repository.", 
            "title": ".gitignore"
        }, 
        {
            "location": "/man/hosting/#gh-pages-branch", 
            "text": "Create a new branch called  gh-pages  and push it to GitHub. If this branch already exists then you can skip this step, but do note that the generated content is automatically pushed to this branch from Travis.", 
            "title": "gh-pages Branch"
        }, 
        {
            "location": "/man/hosting/#documentation-versions", 
            "text": "When documentation is generated it is stored in one of the following folders:    latest  stores the most recent documentation that is committed to the  master  branch.    stable  stores the most recent documentation from a tagged commit. Older tagged versions   are stored in directories named after their tags. These tagged directories are persistent   and must be manually removed from the  gh-pages  branch if necessary.     Final Remarks  That should be all that is needed to enable automatic documentation building. Pushing new commits to your  master  branch should trigger doc builds. Note that other branches do not trigger these builds and neither do pull requests by potential contributors.  If you would like to see a more complete example of how this process is setup then take a look at this package's repository for some inspiration.", 
            "title": "Documentation Versions"
        }, 
        {
            "location": "/man/internals/", 
            "text": "Package Internals", 
            "title": "Internals"
        }, 
        {
            "location": "/man/internals/#package-internals", 
            "text": "", 
            "title": "Package Internals"
        }, 
        {
            "location": "/lib/public/", 
            "text": "Public Documentation\n\n\nDocumentation for \nLapidary.jl\n's public interface.\n\n\nSee \nInternal Documentation\n for internal package docs covering all submodules.\n\n\n\n\nContents\n\n\n\n\nPublic Documentation\n\n\nContents\n\n\nIndex\n\n\nLapidary\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nLapidary\n\n\nLapidary.deploydocs\n\n\nLapidary.makedocs\n\n\n\n\n\n\nLapidary\n\n\n#\n\n\nLapidary\n \n \nModule\n.\n\n\n\n\nMain module for \nLapidary.jl\n \u2013 a documentation generation package for Julia.\n\n\nTwo functions are exported from this module for public use:\n\n\n\n\nmakedocs\n. Generates documentation from docstrings and templated markdown files.\n\n\ndeploydocs\n. Deploys generated documentation from \nTravis-CI\n to \nGitHub Pages\n.\n\n\n\n\n#\n\n\nLapidary.makedocs\n \n \nFunction\n.\n\n\n\n\nmakedocs(\n    root    = \ncurrent-directory\n,\n    source  = \nsrc\n,\n    build   = \nbuild\n,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n)\n\n\n\n\n\nCombines markdown files and inline docstrings into an interlinked document. In most cases \nmakedocs\n should be run from a \nmake.jl\n file:\n\n\nusing\n \nLapidary\n\n\nmakedocs\n(\n\n    \n# keywords...\n\n\n)\n\n\n\n\n\n\nwhich is then run from the command line with:\n\n\n$ julia make.jl\n\n\n\n\n\nThe folder structure that \nmakedocs\n expects looks like:\n\n\ndocs/\n    build/\n    src/\n    make.jl\n\n\n\n\n\nKeywords\n\n\nroot\n is the directory from which \nmakedocs\n should run. When run from a \nmake.jl\n file this keyword does not need to be set. It is, for the most part, needed when repeatedly running \nmakedocs\n from the Julia REPL like so:\n\n\njulia\n makedocs(root = Pkg.dir(\nMyPackage\n, \ndocs\n))\n\n\n\n\n\nsource\n is the directory, relative to \nroot\n, where the markdown source files are read from. By convention this folder is called \nsrc\n. Note that any non-markdown files stored in \nsource\n are copied over to the build directory when \nmakedocs\n is run.\n\n\nbuild\n is the directory, relative to \nroot\n, into which generated files and folders are written when \nmakedocs\n is run. The name of the build directory is, by convention, called \nbuild\n, though, like with \nsource\n, users are free to change this to anything else to better suit their project needs.\n\n\nclean\n tells \nmakedocs\n whether to remove all the content from the \nbuild\n folder prior to generating new content from \nsource\n. By default this is set to \ntrue\n.\n\n\ndoctest\n instructs \nmakedocs\n on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to \ntrue\n. Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the \nDoctests\n manual section for details about running doctests.\n\n\nmodules\n specifies a vector of modules that should be documented in \nsource\n. If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of \nmakedocs\n. By default no modules are passed to \nmodules\n and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation. For example Lapidary's \nmake.jl\n file contains:\n\n\nusing\n \nLapidary\n\n\n\n# Build docs.\n\n\n# ===========\n\n\n\nmakedocs\n(\n\n    \nmodules\n \n=\n \nLapidary\n,\n\n    \nclean\n   \n=\n \nfalse\n\n\n)\n\n\n\n# Deploy docs.\n\n\n# ============\n\n\n\n# We need to install an additional dep, `mkdocs-material`, so provide a custom `deps`.\n\n\ncustom_deps\n()\n \n=\n \nrun\n(\n`pip install --user pygments mkdocs mkdocs-material`\n)\n\n\n\ndeploydocs\n(\n\n    \n# options\n\n    \ndeps\n \n=\n \ncustom_deps\n,\n\n    \nrepo\n \n=\n \ngithub.com/MichaelHatherly/Lapidary.jl.git\n\n\n)\n\n\n\n\n\n\nand so any docstring from the module \nLapidary\n that is not spliced into the generated documentation in \nbuild\n will raise a warning.\n\n\nSee Also\n\n\nA guide detailing how to document a package using Lapidary's \nmakedocs\n is provided in the \nUsage\n section of the manual.\n\n\n#\n\n\nLapidary.deploydocs\n \n \nFunction\n.\n\n\n\n\ndeploydocs(\n    root   = \ncurrent-directory\n,\n    target = \nsite\n,\n    repo   = \nrequired\n,\n    branch = \ngh-pages\n,\n    latest = \nmaster\n,\n    osname = \nlinux\n,\n    julia  = \nnightly\n,\n    deps   = \nFunction\n,\n    make   = \nFunction\n,\n)\n\n\n\n\n\nConverts markdown files generated by \nmakedocs\n to HTML and pushes them to \nrepo\n. This function should be called from within a package's \ndocs/make.jl\n file after the call to \nmakedocs\n, like so\n\n\nusing\n \nLapidary\n,\n \nPACKAGE_NAME\n\n\nmakedocs\n(\n\n    \n# options...\n\n\n)\n\n\ndeploydocs\n(\n\n    \nrepo\n \n=\n \ngithub.com/...\n\n\n)\n\n\n\n\n\n\nKeywords\n\n\nroot\n has the same purpose as the \nroot\n keyword for \nmakedocs\n.\n\n\ntarget\n is the directory, relative to \nroot\n, where generated HTML content should be written to. This directory \nmust\n be added to the repository's \n.gitignore\n file. The default value is \n\"site\"\n.\n\n\nrepo\n is the remote repository where generated HTML content should be pushed to. This keyword \nmust\n be set and will throw an error when left undefined. For example this package uses the following \nrepo\n value:\n\n\nrepo = \ngithub.com/MichaelHatherly/Lapidary.jl.git\n\n\n\n\n\n\nbranch\n is the branch where the generated documentation is pushed. By default this value is set to \n\"gh-pages\"\n.\n\n\nlatest\n is the branch that \"tracks\" the latest generated documentation. By default this value is set to \n\"master\"\n.\n\n\nosname\n is the operating system which will be used to deploy generated documentation. This defaults to \n\"linux\"\n. This value must be one of those specified in the \nos:\n section of the \n.travis.yml\n configuration file.\n\n\njulia\n is the version of Julia that will be used to deploy generated documentation. This defaults to \n\"nightly\"\n. This value must be one of those specified in the \njulia:\n section of the \n.travis.yml\n configuration file.\n\n\ndeps\n is the function used to install any dependancies needed to build the documentation. By default this function installs \npygments\n and \nmkdocs\n:\n\n\ndeps = () -\n run(`pip install --user pygments mkdocs`)\n\n\n\n\n\nmake\n is the function used to convert the markdown files to HTML. By default this just runs \nmkdocs build\n which populates the \ntarget\n directory.\n\n\nSee Also\n\n\nThe \nHosting Documentation\n section of the manual provides a step-by-step guide to using the \ndeploydocs\n function to automatically generate docs and push then to GitHub.", 
            "title": "Public"
        }, 
        {
            "location": "/lib/public/#public-documentation", 
            "text": "Documentation for  Lapidary.jl 's public interface.  See  Internal Documentation  for internal package docs covering all submodules.", 
            "title": "Public Documentation"
        }, 
        {
            "location": "/lib/public/#contents", 
            "text": "Public Documentation  Contents  Index  Lapidary", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/public/#index", 
            "text": "Lapidary  Lapidary.deploydocs  Lapidary.makedocs", 
            "title": "Index"
        }, 
        {
            "location": "/lib/public/#lapidary", 
            "text": "#  Lapidary     Module .   Main module for  Lapidary.jl  \u2013 a documentation generation package for Julia.  Two functions are exported from this module for public use:   makedocs . Generates documentation from docstrings and templated markdown files.  deploydocs . Deploys generated documentation from  Travis-CI  to  GitHub Pages .   #  Lapidary.makedocs     Function .   makedocs(\n    root    =  current-directory ,\n    source  =  src ,\n    build   =  build ,\n    clean   = true,\n    doctest = true,\n    modules = Module[],\n)  Combines markdown files and inline docstrings into an interlinked document. In most cases  makedocs  should be run from a  make.jl  file:  using   Lapidary  makedocs ( \n     # keywords...  )   which is then run from the command line with:  $ julia make.jl  The folder structure that  makedocs  expects looks like:  docs/\n    build/\n    src/\n    make.jl  Keywords  root  is the directory from which  makedocs  should run. When run from a  make.jl  file this keyword does not need to be set. It is, for the most part, needed when repeatedly running  makedocs  from the Julia REPL like so:  julia  makedocs(root = Pkg.dir( MyPackage ,  docs ))  source  is the directory, relative to  root , where the markdown source files are read from. By convention this folder is called  src . Note that any non-markdown files stored in  source  are copied over to the build directory when  makedocs  is run.  build  is the directory, relative to  root , into which generated files and folders are written when  makedocs  is run. The name of the build directory is, by convention, called  build , though, like with  source , users are free to change this to anything else to better suit their project needs.  clean  tells  makedocs  whether to remove all the content from the  build  folder prior to generating new content from  source . By default this is set to  true .  doctest  instructs  makedocs  on whether to try to test Julia code blocks that are encountered in the generated document. By default this keyword is set to  true . Doctesting should only ever be disabled when initially setting up a newly developed package where the developer is just trying to get their package and documentation structure correct. After that, it's encouraged to always make sure that documentation examples are runnable and produce the expected results. See the  Doctests  manual section for details about running doctests.  modules  specifies a vector of modules that should be documented in  source . If any inline docstrings from those modules are seen to be missing from the generated content then a warning will be printed during execution of  makedocs . By default no modules are passed to  modules  and so no warnings will appear. This setting can be used as an indicator of the \"coverage\" of the generated documentation. For example Lapidary's  make.jl  file contains:  using   Lapidary  # Build docs.  # ===========  makedocs ( \n     modules   =   Lapidary , \n     clean     =   false  )  # Deploy docs.  # ============  # We need to install an additional dep, `mkdocs-material`, so provide a custom `deps`.  custom_deps ()   =   run ( `pip install --user pygments mkdocs mkdocs-material` )  deploydocs ( \n     # options \n     deps   =   custom_deps , \n     repo   =   github.com/MichaelHatherly/Lapidary.jl.git  )   and so any docstring from the module  Lapidary  that is not spliced into the generated documentation in  build  will raise a warning.  See Also  A guide detailing how to document a package using Lapidary's  makedocs  is provided in the  Usage  section of the manual.  #  Lapidary.deploydocs     Function .   deploydocs(\n    root   =  current-directory ,\n    target =  site ,\n    repo   =  required ,\n    branch =  gh-pages ,\n    latest =  master ,\n    osname =  linux ,\n    julia  =  nightly ,\n    deps   =  Function ,\n    make   =  Function ,\n)  Converts markdown files generated by  makedocs  to HTML and pushes them to  repo . This function should be called from within a package's  docs/make.jl  file after the call to  makedocs , like so  using   Lapidary ,   PACKAGE_NAME  makedocs ( \n     # options...  )  deploydocs ( \n     repo   =   github.com/...  )   Keywords  root  has the same purpose as the  root  keyword for  makedocs .  target  is the directory, relative to  root , where generated HTML content should be written to. This directory  must  be added to the repository's  .gitignore  file. The default value is  \"site\" .  repo  is the remote repository where generated HTML content should be pushed to. This keyword  must  be set and will throw an error when left undefined. For example this package uses the following  repo  value:  repo =  github.com/MichaelHatherly/Lapidary.jl.git   branch  is the branch where the generated documentation is pushed. By default this value is set to  \"gh-pages\" .  latest  is the branch that \"tracks\" the latest generated documentation. By default this value is set to  \"master\" .  osname  is the operating system which will be used to deploy generated documentation. This defaults to  \"linux\" . This value must be one of those specified in the  os:  section of the  .travis.yml  configuration file.  julia  is the version of Julia that will be used to deploy generated documentation. This defaults to  \"nightly\" . This value must be one of those specified in the  julia:  section of the  .travis.yml  configuration file.  deps  is the function used to install any dependancies needed to build the documentation. By default this function installs  pygments  and  mkdocs :  deps = () -  run(`pip install --user pygments mkdocs`)  make  is the function used to convert the markdown files to HTML. By default this just runs  mkdocs build  which populates the  target  directory.  See Also  The  Hosting Documentation  section of the manual provides a step-by-step guide to using the  deploydocs  function to automatically generate docs and push then to GitHub.", 
            "title": "Lapidary"
        }, 
        {
            "location": "/lib/internals/", 
            "text": "Internal Documentation\n\n\n\n\nContents\n\n\n\n\nInternal Documentation\n\n\nContents\n\n\nIndex\n\n\nAnchors\n\n\nBuilder\n\n\nCrossReferences\n\n\nDocChecks\n\n\nDocuments\n\n\nExpanders\n\n\nFormats\n\n\nWalkers\n\n\nWriters\n\n\nUtilities\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nLapidary.Anchors\n\n\nLapidary.Anchors.Anchor\n\n\nLapidary.Anchors.AnchorMap\n\n\nLapidary.Anchors.add!\n\n\nLapidary.Anchors.anchor\n\n\nLapidary.Anchors.exists\n\n\nLapidary.Anchors.isunique\n\n\nLapidary.Builder\n\n\nLapidary.Builder.CheckDocument\n\n\nLapidary.Builder.ContentsBlocks\n\n\nLapidary.Builder.CopyAssetsDirectory\n\n\nLapidary.Builder.CrossReferences\n\n\nLapidary.Builder.DocsBlocks\n\n\nLapidary.Builder.EvalBlocks\n\n\nLapidary.Builder.ExpandTemplates\n\n\nLapidary.Builder.IndexBlocks\n\n\nLapidary.Builder.MetaBlocks\n\n\nLapidary.Builder.RenderDocument\n\n\nLapidary.Builder.SetupBuildDirectory\n\n\nLapidary.Builder.TrackHeaders\n\n\nLapidary.CrossReferences\n\n\nLapidary.CrossReferences.crossref\n\n\nLapidary.DocChecks\n\n\nLapidary.DocChecks.doctest\n\n\nLapidary.DocChecks.missingdocs\n\n\nLapidary.Documents\n\n\nLapidary.Documents.Document\n\n\nLapidary.Documents.Globals\n\n\nLapidary.Documents.Internal\n\n\nLapidary.Documents.Page\n\n\nLapidary.Documents.User\n\n\nLapidary.Expanders\n\n\nLapidary.Expanders.expand\n\n\nLapidary.Formats\n\n\nLapidary.Formats.Format\n\n\nLapidary.Formats.mimetype\n\n\nLapidary.Utilities\n\n\nLapidary.Utilities.Object\n\n\nLapidary.Utilities.assetsdir\n\n\nLapidary.Utilities.check_kwargs\n\n\nLapidary.Utilities.currentdir\n\n\nLapidary.Utilities.doccat\n\n\nLapidary.Utilities.docs\n\n\nLapidary.Utilities.filterdocs\n\n\nLapidary.Utilities.log\n\n\nLapidary.Utilities.logging\n\n\nLapidary.Utilities.nodocs\n\n\nLapidary.Utilities.object\n\n\nLapidary.Utilities.parseblock\n\n\nLapidary.Utilities.slugify\n\n\nLapidary.Utilities.submodules\n\n\nLapidary.Utilities.warn\n\n\nLapidary.Walkers\n\n\nLapidary.Walkers.walk\n\n\nLapidary.Writers\n\n\nLapidary.Writers.render\n\n\n\n\n\n\nAnchors\n\n\n#\n\n\nLapidary.Anchors\n \n \nModule\n.\n\n\n\n\nDefines the \nAnchor\n and \nAnchorMap\n types.\n\n\nAnchor\ns and \nAnchorMap\ns are used to represent links between objects within a document.\n\n\n#\n\n\nLapidary.Anchors.Anchor\n \n \nType\n.\n\n\n\n\nStores an arbitrary object called \n.object\n and it's location within a document.\n\n\nFields\n\n\n\n\nobject\n \u2013 the stored object.\n\n\norder\n  \u2013 ordering of \nobject\n within the entire document.\n\n\nfile\n   \u2013 the destination file, in \nbuild\n, where the object will be written to.\n\n\nid\n     \u2013 the generated \"slug\" identifying the object.\n\n\nnth\n    \u2013 integer that unique-ifies anchors with the same \nid\n.\n\n\n\n\n#\n\n\nLapidary.Anchors.AnchorMap\n \n \nType\n.\n\n\n\n\nTree structure representating anchors in a document and their relationships with eachother.\n\n\nObject Hierarchy\n\n\nid -\n file -\n anchors\n\n\n\n\n\nEach \nid\n maps to a \nfile\n which in turn maps to a vector of \nAnchor\n objects.\n\n\n#\n\n\nLapidary.Anchors.add!\n \n \nFunction\n.\n\n\n\n\nAdds a new \nAnchor\n to the \nAnchorMap\n for a given \nid\n and \nfile\n.\n\n\nEither an actual \nAnchor\n object may be provided or any other object which is automatically wrapped in an \nAnchor\n before being added to the \nAnchorMap\n.\n\n\n#\n\n\nLapidary.Anchors.anchor\n \n \nFunction\n.\n\n\n\n\nanchor(m, id)\nanchor(m, id, file)\nanchor(m, id, file, n)\n\n\n\n\n\nReturns the \nAnchor\n object matching \nid\n. \nfile\n and \nn\n may also be provided. A \nNullable{Anchor}\n is returned which must be unwrapped with \nisnull\n and \nget\n before use.\n\n\n#\n\n\nLapidary.Anchors.exists\n \n \nFunction\n.\n\n\n\n\nexists(m, id)\nexists(m, id, file)\nexists(m, id, file, n)\n\n\n\n\n\nDoes the given \nid\n exist within the \nAnchorMap\n? A \nfile\n and integer \nn\n may also be provided to narrow the search for existance.\n\n\n#\n\n\nLapidary.Anchors.isunique\n \n \nFunction\n.\n\n\n\n\nisunique(m, id)\nisunique(m, id, file)\n\n\n\n\n\nIs the \nid\n unique within the given \nAnchorMap\n? May also specify the \nfile\n.\n\n\n\n\nBuilder\n\n\n#\n\n\nLapidary.Builder\n \n \nModule\n.\n\n\n\n\nDefines the Lapidary build \"pipeline\".\n\n\nThe default pipeline consists of the following:\n\n\n\n\nSetupBuildDirectory\n\n\nCopyAssetsDirectory\n\n\nExpandTemplates\n\n\nCrossReferences\n\n\nCheckDocument\n\n\nRenderDocument\n\n\n\n\nEach stage of the pipeline performs an action on a \nDocuments.Document\n. These actions may involve creating directory structures, expanding templates, running doctests, etc.\n\n\n#\n\n\nLapidary.Builder.SetupBuildDirectory\n \n \nType\n.\n\n\n\n\nCreates the correct directory layout within the \nbuild\n folder and parses markdown files.\n\n\n#\n\n\nLapidary.Builder.CopyAssetsDirectory\n \n \nType\n.\n\n\n\n\nCopies the contents of the \nassets\n directory into the \nbuild\n folder.\n\n\n#\n\n\nLapidary.Builder.ExpandTemplates\n \n \nType\n.\n\n\n\n\nExecutes a sequence of actions on each node of the parsed markdown files in turn. These actions may be any of:\n\n\n\n\nTrackHeaders\n\n\nMetaBlocks\n\n\nDocsBlocks\n\n\nEvalBlocks\n\n\nIndexBlocks\n\n\nContentsBlocks\n\n\n\n\nSee the docs for each of the listed \"expanders\" for their description.\n\n\n#\n\n\nLapidary.Builder.TrackHeaders\n \n \nType\n.\n\n\n\n\nTracks all \nMarkdown.Header\n nodes found in the parsed markdown files and stores an \nAnchors.Anchor\n object for each one.\n\n\n#\n\n\nLapidary.Builder.MetaBlocks\n \n \nType\n.\n\n\n\n\nParses each code block where the first line is \n{meta}\n and evaluates the key/value pairs found within the block, i.e.\n\n\n    {meta}\n    CurrentModule = Lapidary\n    DocTestSetup  = quote\n        using Lapidary\n    end\n\n\n\n\n\n#\n\n\nLapidary.Builder.DocsBlocks\n \n \nType\n.\n\n\n\n\nParses each code block where the first line is \n{docs}\n and evaluates the expressions found within the block. Replaces the block with the docstrings associated with each expression.\n\n\n    {docs}\n    Lapidary\n    makedocs\n    deploydocs\n\n\n\n\n\n#\n\n\nLapidary.Builder.EvalBlocks\n \n \nType\n.\n\n\n\n\nParses each code block where the first line is \n{eval}\n and evaluates it's content. Replaces the block with the value resulting from the evaluation. This can be useful for inserting generated content into a document such as plots.\n\n\n    {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color = \nred\n)\n    savefig(\nplot.svg\n)\n\n    Markdown.Image(\nPlot\n, \nplot.svg\n)\n\n\n\n\n\n#\n\n\nLapidary.Builder.IndexBlocks\n \n \nType\n.\n\n\n\n\nParses each code block where the first line is \n{index}\n and replaces it with an index of all docstrings spliced into the document. The pages that are included can be set using a key/value pair \nPages = [...]\n such as\n\n\n    {index}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n\n\n\n\n\n#\n\n\nLapidary.Builder.ContentsBlocks\n \n \nType\n.\n\n\n\n\nParses each code block where the first line is \n{contents}\n and replaces it with a nested list of all \nHeader\n nodes in the generated document. The pages and depth of the list can be set using \nPages = [...]\n and \nDepth = N\n where \nN\n is and integer.\n\n\n    {contents}\n    Pages = [\nfoo.md\n, \nbar.md\n]\n    Depth = 1\n\n\n\n\n\nThe default \nDepth\n value is \n2\n.\n\n\n#\n\n\nLapidary.Builder.CrossReferences\n \n \nType\n.\n\n\n\n\nFinds and sets URLs for each \n{ref}\n link in the document to the correct destinations.\n\n\n#\n\n\nLapidary.Builder.CheckDocument\n \n \nType\n.\n\n\n\n\nChecks that all documented objects are included in the document and runs doctests on all valid Julia code blocks.\n\n\n#\n\n\nLapidary.Builder.RenderDocument\n \n \nType\n.\n\n\n\n\nWrites the document tree to the \nbuild\n directory.\n\n\n\n\nCrossReferences\n\n\n#\n\n\nLapidary.CrossReferences\n \n \nModule\n.\n\n\n\n\nProvides the \ncrossref\n function used to automatically calculate link URLs.\n\n\n#\n\n\nLapidary.CrossReferences.crossref\n \n \nFunction\n.\n\n\n\n\nTraverses a \nDocuments.Document\n and replaces links containg \n{ref}\n URLs with their real URLs.\n\n\n\n\nDocChecks\n\n\n#\n\n\nLapidary.DocChecks\n \n \nModule\n.\n\n\n\n\nProvides two functions, \nmissingdocs\n and \ndoctest\n, for checking docs.\n\n\n#\n\n\nLapidary.DocChecks.missingdocs\n \n \nFunction\n.\n\n\n\n\nChecks that a \nDocuments.Document\n contains all available docstrings that are defined in the \nmodules\n keyword passed to \nLapidary.makedocs\n.\n\n\nPrints out the name of each object that has not had its docs spliced into the document.\n\n\n#\n\n\nLapidary.DocChecks.doctest\n \n \nFunction\n.\n\n\n\n\nTraverses the document tree and tries to run each Julia code block encountered. Will abort the document generation when an error is thrown. Use \ndoctest = false\n keyword in \nLapidary.makedocs\n to disable doctesting.\n\n\n\n\nDocuments\n\n\n#\n\n\nLapidary.Documents\n \n \nModule\n.\n\n\n\n\nDefines \nDocument\n and its supporting types\n\n\n\n\nPage\n\n\nUser\n\n\nInternal\n\n\nGlobals\n\n\n\n\n#\n\n\nLapidary.Documents.Document\n \n \nType\n.\n\n\n\n\nRepresents an entire document.\n\n\n#\n\n\nLapidary.Documents.Page\n \n \nType\n.\n\n\n\n\nRepresents a single markdown file.\n\n\n#\n\n\nLapidary.Documents.User\n \n \nType\n.\n\n\n\n\nUser-specified values used to control the generation process.\n\n\n#\n\n\nLapidary.Documents.Internal\n \n \nType\n.\n\n\n\n\nPrivate state used to control the generation process.\n\n\n#\n\n\nLapidary.Documents.Globals\n \n \nType\n.\n\n\n\n\nPage\n-local values such as current module that are shared between nodes in a page.\n\n\n\n\nExpanders\n\n\n#\n\n\nLapidary.Expanders\n \n \nModule\n.\n\n\n\n\nDefines node \"expanders\" that transform nodes from the parsed markdown files.\n\n\n#\n\n\nLapidary.Expanders.expand\n \n \nFunction\n.\n\n\n\n\nexpand(ex, doc)\n\n\n\n\n\nExpands each node of a \nDocuments.Document\n using the expanders provided by \nex\n.\n\n\n\n\nFormats\n\n\n#\n\n\nLapidary.Formats\n \n \nModule\n.\n\n\n\n\nFiletypes used to decide which rendering methods in \nLapidary.Writers\n are called.\n\n\nThe only supported format is currently \nMarkdown\n.\n\n\n#\n\n\nLapidary.Formats.Format\n \n \nType\n.\n\n\n\n\nRepresents the output format. Possible values are \nMarkdown\n, \nLaTeX\n, and \nHTML\n.\n\n\n#\n\n\nLapidary.Formats.mimetype\n \n \nFunction\n.\n\n\n\n\nConverts a \nFormat\n value to a \nMIME\n type.\n\n\n\n\nWalkers\n\n\n#\n\n\nLapidary.Walkers\n \n \nModule\n.\n\n\n\n\nProvides the \nwalk\n function.\n\n\n#\n\n\nLapidary.Walkers.walk\n \n \nFunction\n.\n\n\n\n\nwalk(f, meta, element)\n\n\n\n\n\nCalls \nf\n on \nelement\n and any of its child elements. \nmeta\n is a \nDict\n containing metadata such as current module.\n\n\n\n\nWriters\n\n\n#\n\n\nLapidary.Writers\n \n \nModule\n.\n\n\n\n\nProvides a rendering function, \nrender\n, for writing each supported \nFormats.Format\n to file.\n\n\nNote that currently \nFormats.Markdown\n is the \nonly\n supported format.\n\n\n#\n\n\nLapidary.Writers.render\n \n \nFunction\n.\n\n\n\n\nWrites a \nDocuments.Document\n object to \nbuild\n directory in specified file format.\n\n\n\n\nUtilities\n\n\n#\n\n\nLapidary.Utilities\n \n \nModule\n.\n\n\n\n\nProvides a collection of utility functions and types that are used in other submodules.\n\n\n#\n\n\nLapidary.Utilities.currentdir\n \n \nFunction\n.\n\n\n\n\nReturns the current directory.\n\n\n#\n\n\nLapidary.Utilities.assetsdir\n \n \nFunction\n.\n\n\n\n\nReturns the path to the Lapidary \nassets\n directory.\n\n\n#\n\n\nLapidary.Utilities.check_kwargs\n \n \nFunction\n.\n\n\n\n\nPrints a formatted warning to the user listing unrecognised keyword arguments.\n\n\n#\n\n\nLapidary.Utilities.slugify\n \n \nFunction\n.\n\n\n\n\nSlugify a string into a suitable URL.\n\n\n#\n\n\nLapidary.Utilities.parseblock\n \n \nFunction\n.\n\n\n\n\nReturns a vector of parsed expressions and their corresponding raw strings.\n\n\nThe keyword argument \nskip = N\n drops the leading \nN\n lines from the input string.\n\n\n#\n\n\nLapidary.Utilities.log\n \n \nFunction\n.\n\n\n\n\nFormat and print a message to the user.\n\n\n#\n\n\nLapidary.Utilities.warn\n \n \nFunction\n.\n\n\n\n\nwarn(file, msg)\nwarn(msg)\n\n\n\n\n\nFormat and print a warning message to the user. Passing a \nfile\n will include the filename where the warning was raised.\n\n\n#\n\n\nLapidary.Utilities.logging\n \n \nFunction\n.\n\n\n\n\nlogging(flag::Bool)\n\n\n\n\n\nEnable or disable logging output for \nlog\n and \nwarn\n.\n\n\n#\n\n\nLapidary.Utilities.submodules\n \n \nFunction\n.\n\n\n\n\nReturns the set of submodules of a given root module/s.\n\n\n#\n\n\nLapidary.Utilities.filterdocs\n \n \nFunction\n.\n\n\n\n\nfilterdocs(doc, modules)\n\n\n\n\n\nRemove docstrings from the markdown object, \ndoc\n, that are not from one of \nmodules\n.\n\n\n#\n\n\nLapidary.Utilities.Object\n \n \nType\n.\n\n\n\n\nRepresents an object stored in the docsystem by its binding and signature.\n\n\n#\n\n\nLapidary.Utilities.object\n \n \nFunction\n.\n\n\n\n\nobject(ex, str)\n\n\n\n\n\nReturns a expression that, when evaluated, returns an \nObject\n representing \nex\n.\n\n\n#\n\n\nLapidary.Utilities.docs\n \n \nFunction\n.\n\n\n\n\ndocs(ex, str)\n\n\n\n\n\nReturns an expression that, when evaluated, returns the docstrings associated with \nex\n.\n\n\n#\n\n\nLapidary.Utilities.doccat\n \n \nFunction\n.\n\n\n\n\nReturns the category name of the provided \nObject\n.\n\n\n#\n\n\nLapidary.Utilities.nodocs\n \n \nFunction\n.\n\n\n\n\nDoes the given docstring represent actual documentation or a no docs error message?", 
            "title": "Internals"
        }, 
        {
            "location": "/lib/internals/#internal-documentation", 
            "text": "", 
            "title": "Internal Documentation"
        }, 
        {
            "location": "/lib/internals/#contents", 
            "text": "Internal Documentation  Contents  Index  Anchors  Builder  CrossReferences  DocChecks  Documents  Expanders  Formats  Walkers  Writers  Utilities", 
            "title": "Contents"
        }, 
        {
            "location": "/lib/internals/#index", 
            "text": "Lapidary.Anchors  Lapidary.Anchors.Anchor  Lapidary.Anchors.AnchorMap  Lapidary.Anchors.add!  Lapidary.Anchors.anchor  Lapidary.Anchors.exists  Lapidary.Anchors.isunique  Lapidary.Builder  Lapidary.Builder.CheckDocument  Lapidary.Builder.ContentsBlocks  Lapidary.Builder.CopyAssetsDirectory  Lapidary.Builder.CrossReferences  Lapidary.Builder.DocsBlocks  Lapidary.Builder.EvalBlocks  Lapidary.Builder.ExpandTemplates  Lapidary.Builder.IndexBlocks  Lapidary.Builder.MetaBlocks  Lapidary.Builder.RenderDocument  Lapidary.Builder.SetupBuildDirectory  Lapidary.Builder.TrackHeaders  Lapidary.CrossReferences  Lapidary.CrossReferences.crossref  Lapidary.DocChecks  Lapidary.DocChecks.doctest  Lapidary.DocChecks.missingdocs  Lapidary.Documents  Lapidary.Documents.Document  Lapidary.Documents.Globals  Lapidary.Documents.Internal  Lapidary.Documents.Page  Lapidary.Documents.User  Lapidary.Expanders  Lapidary.Expanders.expand  Lapidary.Formats  Lapidary.Formats.Format  Lapidary.Formats.mimetype  Lapidary.Utilities  Lapidary.Utilities.Object  Lapidary.Utilities.assetsdir  Lapidary.Utilities.check_kwargs  Lapidary.Utilities.currentdir  Lapidary.Utilities.doccat  Lapidary.Utilities.docs  Lapidary.Utilities.filterdocs  Lapidary.Utilities.log  Lapidary.Utilities.logging  Lapidary.Utilities.nodocs  Lapidary.Utilities.object  Lapidary.Utilities.parseblock  Lapidary.Utilities.slugify  Lapidary.Utilities.submodules  Lapidary.Utilities.warn  Lapidary.Walkers  Lapidary.Walkers.walk  Lapidary.Writers  Lapidary.Writers.render", 
            "title": "Index"
        }, 
        {
            "location": "/lib/internals/#anchors", 
            "text": "#  Lapidary.Anchors     Module .   Defines the  Anchor  and  AnchorMap  types.  Anchor s and  AnchorMap s are used to represent links between objects within a document.  #  Lapidary.Anchors.Anchor     Type .   Stores an arbitrary object called  .object  and it's location within a document.  Fields   object  \u2013 the stored object.  order   \u2013 ordering of  object  within the entire document.  file    \u2013 the destination file, in  build , where the object will be written to.  id      \u2013 the generated \"slug\" identifying the object.  nth     \u2013 integer that unique-ifies anchors with the same  id .   #  Lapidary.Anchors.AnchorMap     Type .   Tree structure representating anchors in a document and their relationships with eachother.  Object Hierarchy  id -  file -  anchors  Each  id  maps to a  file  which in turn maps to a vector of  Anchor  objects.  #  Lapidary.Anchors.add!     Function .   Adds a new  Anchor  to the  AnchorMap  for a given  id  and  file .  Either an actual  Anchor  object may be provided or any other object which is automatically wrapped in an  Anchor  before being added to the  AnchorMap .  #  Lapidary.Anchors.anchor     Function .   anchor(m, id)\nanchor(m, id, file)\nanchor(m, id, file, n)  Returns the  Anchor  object matching  id .  file  and  n  may also be provided. A  Nullable{Anchor}  is returned which must be unwrapped with  isnull  and  get  before use.  #  Lapidary.Anchors.exists     Function .   exists(m, id)\nexists(m, id, file)\nexists(m, id, file, n)  Does the given  id  exist within the  AnchorMap ? A  file  and integer  n  may also be provided to narrow the search for existance.  #  Lapidary.Anchors.isunique     Function .   isunique(m, id)\nisunique(m, id, file)  Is the  id  unique within the given  AnchorMap ? May also specify the  file .", 
            "title": "Anchors"
        }, 
        {
            "location": "/lib/internals/#builder", 
            "text": "#  Lapidary.Builder     Module .   Defines the Lapidary build \"pipeline\".  The default pipeline consists of the following:   SetupBuildDirectory  CopyAssetsDirectory  ExpandTemplates  CrossReferences  CheckDocument  RenderDocument   Each stage of the pipeline performs an action on a  Documents.Document . These actions may involve creating directory structures, expanding templates, running doctests, etc.  #  Lapidary.Builder.SetupBuildDirectory     Type .   Creates the correct directory layout within the  build  folder and parses markdown files.  #  Lapidary.Builder.CopyAssetsDirectory     Type .   Copies the contents of the  assets  directory into the  build  folder.  #  Lapidary.Builder.ExpandTemplates     Type .   Executes a sequence of actions on each node of the parsed markdown files in turn. These actions may be any of:   TrackHeaders  MetaBlocks  DocsBlocks  EvalBlocks  IndexBlocks  ContentsBlocks   See the docs for each of the listed \"expanders\" for their description.  #  Lapidary.Builder.TrackHeaders     Type .   Tracks all  Markdown.Header  nodes found in the parsed markdown files and stores an  Anchors.Anchor  object for each one.  #  Lapidary.Builder.MetaBlocks     Type .   Parses each code block where the first line is  {meta}  and evaluates the key/value pairs found within the block, i.e.      {meta}\n    CurrentModule = Lapidary\n    DocTestSetup  = quote\n        using Lapidary\n    end  #  Lapidary.Builder.DocsBlocks     Type .   Parses each code block where the first line is  {docs}  and evaluates the expressions found within the block. Replaces the block with the docstrings associated with each expression.      {docs}\n    Lapidary\n    makedocs\n    deploydocs  #  Lapidary.Builder.EvalBlocks     Type .   Parses each code block where the first line is  {eval}  and evaluates it's content. Replaces the block with the value resulting from the evaluation. This can be useful for inserting generated content into a document such as plots.      {eval}\n    using PyPlot\n\n    x = linspace(-\u03c0, \u03c0)\n    y = sin(x)\n\n    plot(x, y, color =  red )\n    savefig( plot.svg )\n\n    Markdown.Image( Plot ,  plot.svg )  #  Lapidary.Builder.IndexBlocks     Type .   Parses each code block where the first line is  {index}  and replaces it with an index of all docstrings spliced into the document. The pages that are included can be set using a key/value pair  Pages = [...]  such as      {index}\n    Pages = [ foo.md ,  bar.md ]  #  Lapidary.Builder.ContentsBlocks     Type .   Parses each code block where the first line is  {contents}  and replaces it with a nested list of all  Header  nodes in the generated document. The pages and depth of the list can be set using  Pages = [...]  and  Depth = N  where  N  is and integer.      {contents}\n    Pages = [ foo.md ,  bar.md ]\n    Depth = 1  The default  Depth  value is  2 .  #  Lapidary.Builder.CrossReferences     Type .   Finds and sets URLs for each  {ref}  link in the document to the correct destinations.  #  Lapidary.Builder.CheckDocument     Type .   Checks that all documented objects are included in the document and runs doctests on all valid Julia code blocks.  #  Lapidary.Builder.RenderDocument     Type .   Writes the document tree to the  build  directory.", 
            "title": "Builder"
        }, 
        {
            "location": "/lib/internals/#crossreferences", 
            "text": "#  Lapidary.CrossReferences     Module .   Provides the  crossref  function used to automatically calculate link URLs.  #  Lapidary.CrossReferences.crossref     Function .   Traverses a  Documents.Document  and replaces links containg  {ref}  URLs with their real URLs.", 
            "title": "CrossReferences"
        }, 
        {
            "location": "/lib/internals/#docchecks", 
            "text": "#  Lapidary.DocChecks     Module .   Provides two functions,  missingdocs  and  doctest , for checking docs.  #  Lapidary.DocChecks.missingdocs     Function .   Checks that a  Documents.Document  contains all available docstrings that are defined in the  modules  keyword passed to  Lapidary.makedocs .  Prints out the name of each object that has not had its docs spliced into the document.  #  Lapidary.DocChecks.doctest     Function .   Traverses the document tree and tries to run each Julia code block encountered. Will abort the document generation when an error is thrown. Use  doctest = false  keyword in  Lapidary.makedocs  to disable doctesting.", 
            "title": "DocChecks"
        }, 
        {
            "location": "/lib/internals/#documents", 
            "text": "#  Lapidary.Documents     Module .   Defines  Document  and its supporting types   Page  User  Internal  Globals   #  Lapidary.Documents.Document     Type .   Represents an entire document.  #  Lapidary.Documents.Page     Type .   Represents a single markdown file.  #  Lapidary.Documents.User     Type .   User-specified values used to control the generation process.  #  Lapidary.Documents.Internal     Type .   Private state used to control the generation process.  #  Lapidary.Documents.Globals     Type .   Page -local values such as current module that are shared between nodes in a page.", 
            "title": "Documents"
        }, 
        {
            "location": "/lib/internals/#expanders", 
            "text": "#  Lapidary.Expanders     Module .   Defines node \"expanders\" that transform nodes from the parsed markdown files.  #  Lapidary.Expanders.expand     Function .   expand(ex, doc)  Expands each node of a  Documents.Document  using the expanders provided by  ex .", 
            "title": "Expanders"
        }, 
        {
            "location": "/lib/internals/#formats", 
            "text": "#  Lapidary.Formats     Module .   Filetypes used to decide which rendering methods in  Lapidary.Writers  are called.  The only supported format is currently  Markdown .  #  Lapidary.Formats.Format     Type .   Represents the output format. Possible values are  Markdown ,  LaTeX , and  HTML .  #  Lapidary.Formats.mimetype     Function .   Converts a  Format  value to a  MIME  type.", 
            "title": "Formats"
        }, 
        {
            "location": "/lib/internals/#walkers", 
            "text": "#  Lapidary.Walkers     Module .   Provides the  walk  function.  #  Lapidary.Walkers.walk     Function .   walk(f, meta, element)  Calls  f  on  element  and any of its child elements.  meta  is a  Dict  containing metadata such as current module.", 
            "title": "Walkers"
        }, 
        {
            "location": "/lib/internals/#writers", 
            "text": "#  Lapidary.Writers     Module .   Provides a rendering function,  render , for writing each supported  Formats.Format  to file.  Note that currently  Formats.Markdown  is the  only  supported format.  #  Lapidary.Writers.render     Function .   Writes a  Documents.Document  object to  build  directory in specified file format.", 
            "title": "Writers"
        }, 
        {
            "location": "/lib/internals/#utilities", 
            "text": "#  Lapidary.Utilities     Module .   Provides a collection of utility functions and types that are used in other submodules.  #  Lapidary.Utilities.currentdir     Function .   Returns the current directory.  #  Lapidary.Utilities.assetsdir     Function .   Returns the path to the Lapidary  assets  directory.  #  Lapidary.Utilities.check_kwargs     Function .   Prints a formatted warning to the user listing unrecognised keyword arguments.  #  Lapidary.Utilities.slugify     Function .   Slugify a string into a suitable URL.  #  Lapidary.Utilities.parseblock     Function .   Returns a vector of parsed expressions and their corresponding raw strings.  The keyword argument  skip = N  drops the leading  N  lines from the input string.  #  Lapidary.Utilities.log     Function .   Format and print a message to the user.  #  Lapidary.Utilities.warn     Function .   warn(file, msg)\nwarn(msg)  Format and print a warning message to the user. Passing a  file  will include the filename where the warning was raised.  #  Lapidary.Utilities.logging     Function .   logging(flag::Bool)  Enable or disable logging output for  log  and  warn .  #  Lapidary.Utilities.submodules     Function .   Returns the set of submodules of a given root module/s.  #  Lapidary.Utilities.filterdocs     Function .   filterdocs(doc, modules)  Remove docstrings from the markdown object,  doc , that are not from one of  modules .  #  Lapidary.Utilities.Object     Type .   Represents an object stored in the docsystem by its binding and signature.  #  Lapidary.Utilities.object     Function .   object(ex, str)  Returns a expression that, when evaluated, returns an  Object  representing  ex .  #  Lapidary.Utilities.docs     Function .   docs(ex, str)  Returns an expression that, when evaluated, returns the docstrings associated with  ex .  #  Lapidary.Utilities.doccat     Function .   Returns the category name of the provided  Object .  #  Lapidary.Utilities.nodocs     Function .   Does the given docstring represent actual documentation or a no docs error message?", 
            "title": "Utilities"
        }
    ]
}